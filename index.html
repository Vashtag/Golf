<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>Dusk Drive ‚Äî Disc Golf (valley-driven water &amp; sand)</title>
<style>
  :root{
    /* defaults; overridden per biome at runtime */
    --bg1:#a54720; --bg2:#f38e41; --bg3:#ffe6ba; --water:#30160f;
    --fg:#050607; --text:#e6edf3; --muted:#a9b1ba;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(5,6,7,.65); --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .hud .btn{pointer-events:auto}

  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1100px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  #screenIntro{background:linear-gradient(180deg,rgba(10,10,10,.45),rgba(10,10,10,.35))}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center;max-height:calc(100vh - 2rem);max-height:calc(100dvh - 2rem);overflow-y:auto}
  /* Intro screen */
  .intro-card{padding:2.2rem 1.6rem 1.4rem;display:flex;flex-direction:column;align-items:center;gap:0;overflow:visible;background:rgba(5,6,7,.45);backdrop-filter:blur(14px)}
  .intro-disc{width:72px;height:72px;border-radius:50%;background:radial-gradient(circle at 38% 36%,rgba(255,255,255,.18),transparent 60%),conic-gradient(from 200deg,var(--accent),var(--accent2),var(--accent3),var(--accent));border:3px solid rgba(255,255,255,.12);box-shadow:0 0 28px rgba(255,138,61,.25),inset 0 0 14px rgba(0,0,0,.35);margin-bottom:1rem;animation:introSpin 8s linear infinite}
  @keyframes introSpin{to{transform:rotate(360deg)}}
  .intro-title{font-size:2.2rem;font-weight:800;letter-spacing:-.5px;margin:0 0 .15rem 0;background:linear-gradient(135deg,var(--text) 40%,var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
  .intro-sub{font-size:1rem;text-transform:uppercase;letter-spacing:.35em;color:var(--muted);margin:0 0 1.6rem 0;font-weight:500}
  .intro-btn{font-size:1.05rem;padding:.7rem 2.4rem;border-radius:999px;background:linear-gradient(135deg,var(--accent),#ff6a1a);border:none;color:#fff;font-weight:700;letter-spacing:.4px;box-shadow:0 4px 20px rgba(255,138,61,.3);transition:transform .15s,box-shadow .15s}
  .intro-btn:hover{transform:translateY(-1px);box-shadow:0 6px 28px rgba(255,138,61,.45)}
  .intro-btn:active{transform:translateY(1px);box-shadow:0 2px 12px rgba(255,138,61,.2)}
  .intro-ver{margin-top:1.2rem;font-size:.72rem;color:var(--muted);opacity:.5;letter-spacing:.08em}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}
  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .small{font-size:.9rem;color:var(--muted)}
  /* Disc bag modal */
  .bag-card{position:relative;overflow:visible}
  .bag-top{margin:-1rem auto .2rem auto;width:80px;height:32px;background:linear-gradient(180deg,#6b4226 0%,#8b5e3c 60%,#a0714f 100%);border-radius:14px 14px 0 0;border:2px solid rgba(255,255,255,.12);border-bottom:0;position:relative}
  .bag-top::after{content:'';position:absolute;top:6px;left:50%;transform:translateX(-50%);width:28px;height:10px;border:2px solid rgba(255,255,255,.18);border-radius:6px;background:rgba(0,0,0,.15)}
  .bag-card .card-body{background:linear-gradient(180deg,rgba(107,66,38,.15),rgba(107,66,38,.05));border-radius:0 0 14px 14px}
  .bag-discs{display:grid;grid-template-columns:repeat(2,1fr);gap:.7rem;margin-top:.6rem}
  .bag-slot{position:relative;background:rgba(255,255,255,.06);border:2px solid rgba(255,255,255,.10);border-radius:14px;padding:.8rem .6rem;text-align:center;transition:border-color .3s,box-shadow .3s}
  .bag-slot.unlocked{border-color:var(--accent);box-shadow:0 0 12px rgba(255,138,61,.15)}
  .bag-slot.locked{opacity:.55;filter:grayscale(.6);cursor:pointer}
  .bag-slot.locked:hover{opacity:.8;filter:grayscale(.2);border-color:var(--accent);box-shadow:0 0 10px rgba(255,138,61,.2)}
  .bag-slot .disc-icon{font-size:2rem;margin-bottom:.3rem}
  .bag-slot .disc-name{font-weight:700;font-size:.95rem}
  .bag-slot .disc-desc{font-size:.78rem;color:var(--muted);margin-top:.2rem}
  .bag-slot .lock-badge{position:absolute;top:.45rem;right:.45rem;font-size:.85rem;opacity:.7}
  .bag-slot.unlocked .lock-badge{display:none}
  .bag-slot .buy-hint{font-size:.75rem;color:var(--accent);margin-top:.3rem;font-weight:600}
  .skin-row{display:flex;gap:.35rem;justify-content:center;margin-top:.4rem;flex-wrap:wrap}
  .skin-btn{position:relative;width:26px;height:26px;border-radius:50%;border:2px solid rgba(255,255,255,.15);cursor:pointer;transition:transform .15s,border-color .15s;padding:0;background:none}
  .skin-btn:hover{transform:scale(1.15)}
  .skin-btn[aria-pressed="true"]{border-color:#fff;transform:scale(1.2);box-shadow:0 0 8px rgba(255,255,255,.3)}
  .skin-btn .swatch{display:block;width:100%;height:100%;border-radius:50%}
  .skin-btn.locked-skin{opacity:.4;border-style:dashed}
  .skin-btn.locked-skin:hover{opacity:.75;transform:scale(1.25)}
  .skin-btn .price-tip{display:none;position:absolute;bottom:calc(100% + 6px);left:50%;transform:translateX(-50%);background:rgba(0,0,0,.85);color:var(--accent);font-size:.7rem;padding:.2rem .45rem;border-radius:6px;white-space:nowrap;pointer-events:none;font-weight:600;z-index:5}
  .skin-btn.locked-skin:hover .price-tip{display:block}
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}
  @media (orientation:portrait){ #landscapeHint{display:flex} }

  /* ============================================================
     MOBILE-ONLY STYLES (max-width:768px + pointer:coarse)
     Desktop remains completely unchanged.
     ============================================================ */

  /* --- Safe-area insets (iPhone notch / Dynamic Island / gesture bar) --- */
  @supports(padding: env(safe-area-inset-top)){
    @media (max-width:768px) and (pointer:coarse){
      .topbar{
        padding-top:calc(.6rem + env(safe-area-inset-top));
        padding-left:calc(.8rem + env(safe-area-inset-left));
        padding-right:calc(.8rem + env(safe-area-inset-right));
      }
      .bottombar{
        padding-bottom:calc(.5rem + env(safe-area-inset-bottom));
        padding-left:calc(.5rem + env(safe-area-inset-left));
        padding-right:calc(.5rem + env(safe-area-inset-right));
      }
    }
  }

  /* --- Touch: prevent double-tap zoom on interactive elements --- */
  @media (pointer:coarse){
    .hud, .hud *{ touch-action:manipulation; }
    .screen, .screen *{ touch-action:manipulation; }
    button.btn, .seg button{ -webkit-tap-highlight-color:transparent; }
  }

  /* --- Small-screen landscape (phones in landscape) --- */
  @media (max-width:768px) and (pointer:coarse) and (orientation:landscape){
    /* Larger tap targets */
    button.btn{
      padding:.65rem .85rem;
      font-size:.85rem;
      min-height:40px;
      min-width:40px;
    }
    .seg button{
      padding:.6rem .75rem;
      font-size:.85rem;
      min-height:40px;
    }

    /* Compact top bar */
    .topbar{
      padding:.35rem .6rem;
      gap:.3rem;
    }
    .topbar .row{ gap:.3rem; }
    .chip{
      padding:.3rem .5rem;
      font-size:.75rem;
      gap:.35rem;
    }

    /* Compact bottom bar ‚Äî single row, scroll if needed */
    .bottombar{ padding:.35rem .5rem; }
    .panel{ padding:.35rem .5rem; }
    .controls{
      gap:.35rem;
      flex-wrap:nowrap;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
      max-width:100vw;
    }
    .controls::-webkit-scrollbar{ display:none; }

    /* Power meter: keep above the bottom bar */
    .powermeter{ bottom:56px; height:10px; }

    /* Scrollable cards for short landscape viewports */
    .screen{ overflow-y:auto; -webkit-overflow-scrolling:touch; align-items:safe center; }
    .card{ max-height:calc(100vh - 2rem); max-height:calc(100dvh - 2rem); overflow-y:auto; }
  }

  /* --- Small-screen portrait (phones in portrait) --- */
  @media (max-width:768px) and (pointer:coarse) and (orientation:portrait){
    /* Hide the "rotate to landscape" nag ‚Äî we support portrait now */
    #landscapeHint{ display:none !important; }

    /* Larger tap targets for thumbs */
    button.btn{
      padding:.7rem .9rem;
      font-size:.9rem;
      min-height:44px;
      min-width:44px;
    }
    .seg button{
      padding:.65rem .8rem;
      font-size:.9rem;
      min-height:44px;
    }

    /* Top bar: wrap into two rows if needed */
    .topbar{
      flex-wrap:wrap;
      gap:.3rem;
      padding:.5rem .6rem;
    }
    .topbar .row{
      gap:.3rem;
      flex-wrap:wrap;
      justify-content:center;
    }
    .chip{
      padding:.35rem .55rem;
      font-size:.8rem;
      gap:.4rem;
    }

    /* Bottom bar: stack controls into a grid */
    .bottombar{ padding:.5rem; }
    .panel{ padding:.5rem; width:100%; max-width:100vw; }
    .controls{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:.4rem;
      max-width:100%;
    }
    /* Disc selector spans full width */
    .controls #clubSeg{
      grid-column:1 / -1;
      display:grid;
      grid-template-columns:repeat(4,1fr);
    }
    /* Release angle and hand rows */
    .controls #spinSeg{
      display:grid;
      grid-template-columns:repeat(3,1fr);
    }
    .controls #handSeg{
      display:grid;
      grid-template-columns:repeat(2,1fr);
    }
    /* Restart button spans full width */
    .controls #btnNewRound{
      grid-column:1 / -1;
    }

    /* Power meter above the taller bottom bar */
    .powermeter{ bottom:auto; top:50%; transform:translate(-50%,-50%); }

    /* Scrollable cards */
    .screen{ overflow-y:auto; -webkit-overflow-scrolling:touch; padding:1rem; align-items:safe center; }
    .card{
      max-height:calc(100vh - 2rem);
      max-height:calc(100dvh - 2rem);
      overflow-y:auto;
    }
    .grid{ grid-template-columns:1fr; }
  }

  /* --- Medium tablets in portrait (keep mostly normal but bigger targets) --- */
  @media (min-width:769px) and (max-width:1024px) and (pointer:coarse){
    button.btn{ padding:.6rem .8rem; min-height:44px; }
    .seg button{ padding:.55rem .75rem; min-height:44px; }
  }
</style>
</head>
<body>
<div id="wrap"><canvas aria-label="Dusk Drive side-view game canvas" id="game"></canvas></div>
<!-- HUD -->
<div aria-live="polite" class="hud">
<div class="topbar">
<div class="row">
<div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
<div class="chip"><span class="label">Par</span> <strong id="parLabel">3</strong></div>
<div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
<div class="chip"><span class="label">ü™ô</span> <strong id="coinDisplay">0</strong></div>
</div>
<div class="row">
<div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
<div class="chip"><span class="label">To pin</span> <span id="distVal">‚Äî</span>m</div>
<div class="chip" id="projChip" style="display:none"><span class="label">Projected landing</span> <span id="projVal">‚Äî</span></div>
<div class="seg" id="zoomSeg" style="gap:0">
<button aria-label="Zoom out" class="btn" id="btnZoomOut" title="Zoom out">‚àí</button>
<button aria-label="Zoom in" class="btn" id="btnZoomIn" title="Zoom in">+</button>
</div>
<button aria-label="Settings" class="btn" id="btnSettings" title="Settings">‚öôÔ∏è</button>
</div>
</div>
<div class="bottombar">
<div class="panel controls">
<div style="display:flex;gap:.35rem;align-items:center">
<div aria-label="Disc select" class="seg" id="clubSeg" role="group"></div>
<button class="btn" id="btnBag" title="Open disc bag" style="font-size:1.1rem;padding:.45rem .6rem">üéí</button>
</div>
<div aria-label="Release angle" class="seg" id="spinSeg" role="group">
<button aria-pressed="false" class="btn" data-spin="-1" title="Hyzer (‚àí15¬∞)">Hyzer</button>
<button aria-pressed="true" class="btn" data-spin="0" title="Flat (0¬∞)">Flat</button>
<button aria-pressed="false" class="btn" data-spin="1" title="Anhyzer (+15¬∞)">Anhy</button>
</div>
<div aria-label="Throw style" class="seg" id="handSeg" role="group">
<button aria-pressed="true" class="btn" data-hand="RHBH" title="Right-hand backhand">RHBH</button>
<button aria-pressed="false" class="btn" data-hand="LHBH" title="Left-hand backhand">LHBH</button>
</div>
<!-- Daytime segment -->
<button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
</div>
</div>
<div aria-hidden="true" class="powermeter" id="powermeter"><div class="fill" id="powerfill"></div></div>
</div>
<!-- Screens -->
<div aria-modal="true" class="screen" id="screenIntro" role="dialog">
<div class="card intro-card">
<div class="intro-disc" aria-hidden="true"></div>
<h1 class="intro-title">Dusk Drive</h1>
<p class="intro-sub">Disc Golf</p>
<button class="btn intro-btn" id="btnPlay">Start Round</button>
<span class="intro-ver">v0.1.0</span>
</div>
</div>
<div aria-modal="true" class="screen" id="screenSummary" role="dialog" style="display:none">
<div class="card">
<h2>Round Complete</h2>
<p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
<div class="grid" id="holeBreakdown"></div>
<div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
</div>
</div>
<div aria-modal="true" class="screen" id="screenSettings" role="dialog" style="display:none">
<div class="card">
<h2>Settings</h2>
<div class="grid">
<label class="chip" style="justify-content:space-between">
<span>Reduced motion</span>
<input id="chkReduced" type="checkbox"/>
</label>
<label class="chip" style="justify-content:space-between">
<span>Audio (ambience &amp; SFX)</span>
<input id="chkAudio" type="checkbox"/>
</label>
<label class="chip" style="justify-content:space-between">
<span>Wind (toggle)</span>
<input checked="" id="chkWind" type="checkbox"/>
</label>
<label class="chip" style="justify-content:space-between">
<span>Boss mode (bosses only)</span>
<input id="chkBoss" type="checkbox"/>
</label>
</div>
<p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
<div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
</div>
</div>
<div aria-modal="true" class="screen" id="screenBag" role="dialog" style="display:none">
<div class="card bag-card">
<div class="bag-top"></div>
<h2 style="margin-top:.4rem">Disc Bag</h2>
<div class="sub">ü™ô <strong id="bagBalance">0</strong> coins</div>
<div class="bag-discs" id="bagDiscs"></div>
<div style="margin-top:.7rem;display:flex;gap:.5rem;justify-content:center"><button class="btn" id="btnCloseBag">Close</button></div>
</div>
</div>
<div id="landscapeHint"><div class="card small">Tip: Landscape gives a wider view of the course.</div></div>
<script>
(function initWhenReady(){
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', main, { once:true });
  } else { main(); }

  function main(){
    const TAU = Math.PI*2;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // ===== UI Elements
    const elHole = document.getElementById('holeNum');
    const elHolesTotal = document.getElementById('holesTotal');
    const elPar = document.getElementById('parLabel');
    const elStrokes = document.getElementById('strokes');
    const elWindVal = document.getElementById('windVal');
    const elWindArrow = document.getElementById('windArrow');
    const elDistVal = document.getElementById('distVal');
    const elProjChip = document.getElementById('projChip');
    const elProjVal = document.getElementById('projVal');
    const elPowermeter = document.getElementById('powermeter');
    const elPowerfill = document.getElementById('powerfill');
    const clubSeg = document.getElementById('clubSeg');
    const spinSeg = document.getElementById('spinSeg');
    const handSeg = document.getElementById('handSeg');
    const screenIntro = document.getElementById('screenIntro');
    const screenSummary = document.getElementById('screenSummary');
    const screenSettings = document.getElementById('screenSettings');
    const btnPlay = document.getElementById('btnPlay');
    const btnPlayAgain = document.getElementById('btnPlayAgain');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnSettings = document.getElementById('btnSettings');
    const btnCloseSettings = document.getElementById('btnCloseSettings');
    const screenBag = document.getElementById('screenBag');
    const bagDiscs = document.getElementById('bagDiscs');
    const btnBag = document.getElementById('btnBag');
    const btnCloseBag = document.getElementById('btnCloseBag');
    const chkReduced = document.getElementById('chkReduced');
    const chkAudio = document.getElementById('chkAudio');
    const chkWind = document.getElementById('chkWind');

    const sumStrokes = document.getElementById('sumStrokes');
    const sumPar = document.getElementById('sumPar');
    const sumScore = document.getElementById('sumScore');
    const holeBreakdown = document.getElementById('holeBreakdown');

    // ===== Game Config & State
    let bossMode = false;
    let HOLES_PER_ROUND = 18; elHolesTotal.textContent = HOLES_PER_ROUND;
    const WORLD = { w: 3400, h: 950 };
    let view = { x:0, y:0, w:0, h:0 };
    let zoomLevel = 1.0; // 1.0 = default, <1 = zoomed out, >1 = zoomed in
    const ZOOM_MIN = 0.5, ZOOM_MAX = 2.0, ZOOM_STEP = 0.15;

    // OPTIM: cached styles/gradients
    const cached = {
      skyGradient: null,
      colors: { accent:'#ff8a3d', accent2:'#49d0ff', accent3:'#86efac', water:'#30160f', fg:'#050607' }
    };
    function refreshColorsFromCSS(){
      const root = getComputedStyle(document.documentElement);
      cached.colors.accent  = root.getPropertyValue('--accent').trim()  || '#ff8a3d';
      cached.colors.accent2 = root.getPropertyValue('--accent2').trim() || '#49d0ff';
      cached.colors.accent3 = root.getPropertyValue('--accent3').trim() || '#86efac';
      cached.colors.water   = root.getPropertyValue('--water').trim()   || '#30160f';
      cached.colors.fg      = root.getPropertyValue('--fg').trim()      || '#050607';
    }
    function rebuildSkyGradient(){
      const h = canvas.height / DPR;
      const cs = getComputedStyle(document.documentElement);
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,    cs.getPropertyValue('--bg3').trim());
      g.addColorStop(0.55, cs.getPropertyValue('--bg2').trim());
      g.addColorStop(1,    cs.getPropertyValue('--bg1').trim());
      cached.skyGradient = g;
    }

    // ===== Daytime / Atmosphere =====
    const atmo = {
      cloudAlpha: 1.0,
      sun: { visible: true, intensity: 1.0, radiusMul: 1.0, halo: 1.0 },
      vignette: 0.35,
      waterShine: 1.0,
      haze: 0.0,
      groundFog: 0.0,
      mistOverWater: 0.0,
      mtnAlphaNear: 1.0,
      mtnAlphaFar: 1.0,
      fogDrift: { speed: 0.015, amp: 24 },
      tint: { color: null, amount: 0 },
      night: 0.0 // 0..1 (drives stars/fireflies, etc.)
    };

    // base sky cache so tinting doesn't accumulate between holes
    let baseSky = { bg1:'#a54720', bg2:'#f38e41', bg3:'#ffe6ba', water:'#30160f' };

    const DAYTIMES = {
      clear: {
        label:'Clear',
        cloudAlpha: 1.0,
        sun: { visible:true, intensity:1.0, radiusMul:1.0, halo:1.0 },
        vignette: 0.35, waterShine:1.0,
        haze: 0.0, groundFog: 0.0, mistOverWater: 0.0,
        mtnAlphaNear: 1.0, mtnAlphaFar: 1.0,
        tint: null,
        night: 0.0
      },
      dusk: {
        label:'Dusk',
        cloudAlpha: 0.70,
        sun: { visible:false, intensity:0.55, radiusMul:1.0, halo:0.75 },
        vignette: 0.45, waterShine:0.55,
        haze: 0.0, groundFog: 0.0, mistOverWater: 0.0,
        mtnAlphaNear: 0.80, mtnAlphaFar: 0.45,
        tint: { color:'#7c6cff', amount:0.18 },
        night: 0.55
      },
      night: {
        label:'Night',
        cloudAlpha: 0.55,
        sun: { visible:false, intensity:0.0, radiusMul:1.0, halo:0.0 },
        vignette: 0.60, waterShine:0.30,
        haze: 0.00, groundFog: 0.00, mistOverWater: 0.00,
        mtnAlphaNear: 0.60, mtnAlphaFar: 0.18,
        // use explicit sky override for strong, consistent night rendering across biomes
        skyOverride: { bg1:'#050812', bg2:'#101b33', bg3:'#1b2d55', water:'#050916' },
        tint: null,
        night: 1.0
      }
    };
    // Day/night is randomized per hole (no player-facing controls).
    let currentDaytimeVariant = DAYTIMES.clear;

    // Color helpers
    function hexToRgb(hex){
      const h = hex.replace('#','');
      const n = parseInt(h.length===3 ? h.replace(/(.)/g,'$1$1') : h, 16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHex({r,g,b}){
      const h = (v)=>('0'+Math.max(0,Math.min(255,v|0)).toString(16)).slice(-2);
      return '#'+h(r)+h(g)+h(b);
    }
    function blend(aHex, bHex, t){
      const a=hexToRgb(aHex), b=hexToRgb(bHex);
      return rgbToHex({ r:a.r+(b.r-a.r)*t, g:a.g+(b.g-a.g)*t, b:a.b+(b.b-a.b)*t });
    }

    // Apply variant over the biome baseline (avoids tint stacking)
    function tintSkyForVariant(variant){
      const root = document.documentElement.style;

      // Always restore biome baseline first
      root.setProperty('--bg1', baseSky.bg1);
      root.setProperty('--bg2', baseSky.bg2);
      root.setProperty('--bg3', baseSky.bg3);
      root.setProperty('--water', baseSky.water);

      if(variant.skyOverride){
        root.setProperty('--bg1', variant.skyOverride.bg1);
        root.setProperty('--bg2', variant.skyOverride.bg2);
        root.setProperty('--bg3', variant.skyOverride.bg3);
        root.setProperty('--water', variant.skyOverride.water || baseSky.water);
        rebuildSkyGradient();
        refreshColorsFromCSS();
        return;
      }

      if(!variant.tint || !variant.tint.color || !variant.tint.amount){
        rebuildSkyGradient();
        refreshColorsFromCSS();
        return;
      }

      const bg1 = baseSky.bg1, bg2 = baseSky.bg2, bg3 = baseSky.bg3;
      const c = variant.tint.color, t = variant.tint.amount;
      root.setProperty('--bg1', blend(bg1, c, t*0.9));
      root.setProperty('--bg2', blend(bg2, c, t));
      root.setProperty('--bg3', blend(bg3, c, t*0.7));
      rebuildSkyGradient();
      refreshColorsFromCSS();
    }

    function applyDaytime(variant){
      currentDaytimeVariant = variant;
      atmo.cloudAlpha   = variant.cloudAlpha ?? 1.0;
      atmo.vignette     = variant.vignette ?? 0.35;
      atmo.waterShine   = variant.waterShine ?? 1.0;
      atmo.haze         = variant.haze ?? 0.0;
      atmo.groundFog    = variant.groundFog ?? 0.0;
      atmo.mistOverWater= variant.mistOverWater ?? 0.0;
      atmo.mtnAlphaNear = variant.mtnAlphaNear ?? 1.0;
      atmo.mtnAlphaFar  = variant.mtnAlphaFar ?? 1.0;
      if(variant.fogDrift) atmo.fogDrift = variant.fogDrift;

      atmo.sun.visible   = variant.sun?.visible ?? true;
      atmo.sun.intensity = variant.sun?.intensity ?? 1.0;
      atmo.sun.radiusMul = variant.sun?.radiusMul ?? 1.0;
      atmo.sun.halo      = variant.sun?.halo ?? 1.0;

      atmo.night = clamp(variant.night ?? 0.0, 0, 1);

      tintSkyForVariant(variant);
    }

    // Day/night selection is randomized per hole (no player-facing controls).
// Distribution:
//   Clear 60%, Night 20%, Dusk 20%.
const DAY_VARIANT_WEIGHTS = { clear: 0.60, night: 0.20, dusk: 0.20 };

function weightedPickKey(weights){
  let total = 0;
  for (const k in weights) total += weights[k];
  let r = Math.random() * Math.max(1e-9, total);
  for (const k in weights){
    r -= weights[k];
    if (r <= 0) return k;
  }
  return Object.keys(weights)[0] || 'clear';
}

function pickAutoVariantForHole(){
  if (!hole) return 'clear';
  // Cache so the hole doesn't flicker if resolve is called multiple times.
  if (!hole._dayVariantId) hole._dayVariantId = weightedPickKey(DAY_VARIANT_WEIGHTS);
  return hole._dayVariantId;
}

function resolveVariantForHole(){
  const id = pickAutoVariantForHole();
  return DAYTIMES[id] || DAYTIMES.clear;
}


    // Quality scaling (Reduced Motion + simple frame EMA)
    let reducedMotion = false;
    let frameEMA = 1/60; // seconds
    function qualityScale(){
      let q = reducedMotion ? 0.6 : 1.0;
      if(frameEMA > 0.028) q = Math.min(q, 0.6);
      else if(frameEMA > 0.022) q = Math.min(q, 0.75);
      return q;
    }

    // Discs
    const DISCS = [
      { id:'DRV', name:'Driver',  speed:1.20, glide:1.00, turn:-2.0, fade:2.5 },
      { id:'FAI', name:'Fairway', speed:0.92, glide:1.05, turn:-1.5, fade:2.0 },
      { id:'MID', name:'Mid',     speed:0.80, glide:1.10, turn:-1.0, fade:1.4 },
      { id:'PUT', name:'Putter',  speed:0.62, glide:1.00, turn:-0.3, fade:0.9 }
    ];

    // Disc skins per type
    const DISC_SKINS = {
      DRV: [
        { name:'Ice',     fill:'#49d0ff', rim:'rgba(0,60,90,.5)' },
        { name:'Fire',    fill:'#ff4422', rim:'rgba(120,20,0,.5)' },
        { name:'Lime',    fill:'#7cfc00', rim:'rgba(30,80,0,.5)' },
        { name:'Gold',    fill:'#ffd700', rim:'rgba(100,80,0,.5)' },
        { name:'Violet',  fill:'#b266ff', rim:'rgba(60,0,100,.5)' },
      ],
      FAI: [
        { name:'Pearl',   fill:'#e8e0f0', rim:'rgba(80,60,100,.45)' },
        { name:'Teal',    fill:'#20c9b0', rim:'rgba(0,70,60,.5)' },
        { name:'Rose',    fill:'#ff6b8a', rim:'rgba(100,20,40,.5)' },
        { name:'Slate',   fill:'#7a8b9a', rim:'rgba(30,40,50,.5)' },
        { name:'Sunset',  fill:'#ff9a56', rim:'rgba(100,50,0,.5)' },
      ],
      MID: [
        { name:'Cloud',   fill:'#f8fafc', rim:'rgba(0,0,0,.45)' },
        { name:'Ocean',   fill:'#2288cc', rim:'rgba(0,40,80,.5)' },
        { name:'Berry',   fill:'#cc44aa', rim:'rgba(80,0,60,.5)' },
        { name:'Mint',    fill:'#66ddaa', rim:'rgba(0,70,50,.5)' },
        { name:'Storm',   fill:'#556677', rim:'rgba(20,30,40,.55)' },
      ],
      PUT: [
        { name:'Blaze',   fill:'#ff8a3d', rim:'rgba(100,40,0,.5)' },
        { name:'Sky',     fill:'#66bbff', rim:'rgba(0,50,100,.5)' },
        { name:'Neon',    fill:'#39ff14', rim:'rgba(0,80,0,.5)' },
        { name:'Pink',    fill:'#ff69b4', rim:'rgba(100,20,60,.5)' },
        { name:'Bone',    fill:'#e8dcc8', rim:'rgba(60,50,30,.5)' },
      ]
    };
    const selectedSkins = {};
    (function initSkins(){
      const saved = localStorage.getItem('discSkins');
      if(saved){ try{ Object.assign(selectedSkins, JSON.parse(saved)); }catch(e){} }
      DISCS.forEach(d=>{ if(!(d.id in selectedSkins)) selectedSkins[d.id] = 0; });
    })();
    function saveSkins(){ localStorage.setItem('discSkins', JSON.stringify(selectedSkins)); }
    function getDiscSkin(discId){
      const si = selectedSkins[discId] || 0;
      if(typeof ownsSkin === 'function' && !ownsSkin(discId, si)) return DISC_SKINS[discId][0];
      return DISC_SKINS[discId][si];
    }

    // Disc bag progression ‚Äì always start with Driver & Putter; buy Fairway & Mid each session
    const unlockedDiscs = new Set(['DRV', 'PUT']);
    function saveDiscUnlocks(){ /* no-op: disc unlocks are session-only */ }
    function unlockDisc(discId){ if(unlockedDiscs.has(discId)) return false; unlockedDiscs.add(discId); saveDiscUnlocks(); return true; }

    // ===== Coin System =====
    let coins = 0;
    (function initCoins(){
      const saved = localStorage.getItem('coins');
      if(saved !== null){ coins = parseInt(saved, 10) || 0; }
    })();
    function saveCoins(){ localStorage.setItem('coins', String(coins)); }
    function addCoins(n){ coins += n; saveCoins(); updateCoinDisplay(); }
    function spendCoins(n){ if(coins < n) return false; coins -= n; saveCoins(); updateCoinDisplay(); return true; }
    function updateCoinDisplay(){
      const el = document.getElementById('coinDisplay');
      if(el) el.textContent = coins;
      const bb = document.getElementById('bagBalance');
      if(bb) bb.textContent = coins;
    }

    // Coin rewards per hole: base coins for par, bonus/penalty per stroke under/over
    function calcHoleCoins(par, strokes){
      if(strokes === 1) return 50;           // Hole in one bonus
      const delta = strokes - par;
      if(delta <= -3) return 40;             // Albatross
      if(delta === -2) return 30;            // Eagle
      if(delta === -1) return 20;            // Birdie
      if(delta === 0) return 12;             // Par
      if(delta === 1) return 6;              // Bogey
      if(delta === 2) return 3;              // Double bogey
      return 1;                              // Triple+ bogey still gets something
    }

    // Disc prices
    const DISC_PRICES = { FAI: 60, MID: 60 };
    // Skin prices (per skin index > 0, index 0 is the default free skin)
    const SKIN_PRICE = 25;

    // Track which skins are purchased
    const ownedSkins = {};
    (function initOwnedSkins(){
      const saved = localStorage.getItem('ownedSkins');
      if(saved){ try{ Object.assign(ownedSkins, JSON.parse(saved)); }catch(e){} }
      // Default skins (index 0) for each disc are always owned
      DISCS.forEach(d => {
        if(!ownedSkins[d.id]) ownedSkins[d.id] = [0];
      });
    })();
    function saveOwnedSkins(){ localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins)); }
    function ownsSkin(discId, skinIdx){ return ownedSkins[discId] && ownedSkins[discId].includes(skinIdx); }
    function buySkin(discId, skinIdx){
      if(ownsSkin(discId, skinIdx)) return false;
      if(!spendCoins(SKIN_PRICE)) return false;
      if(!ownedSkins[discId]) ownedSkins[discId] = [0];
      ownedSkins[discId].push(skinIdx);
      saveOwnedSkins();
      return true;
    }

    // Surfaces
    const SURF = {
  ice:{ fric:0.004, rest:0.02 },
      fairway: { fric: 740,  rest: 0.14 },
      rough:   { fric: 1000, rest: 0.10, powerMul: 0.88 },
      sand:    { fric: 1400, rest: 0.05, powerMul: 0.70 },
      green:   { fric: 520,  rest: 0.10 },
      rock:    { fric: 620,  rest: 0.18 }
    };

    // ==== DISC PHYSICS ====
    const GRAV = 1500;
  // Display-only conversion (world units are pixels)
  const PX_PER_M = 10;
    const NOSE_FAST_DEG = -6;
    const NOSE_SLOW_DEG =  7;

    // ===== Wind
    let windOn = true;
    let windLift = 0;             // -1 .. +1 (down .. up)
    let windSide = 0;             // -1 .. +1 (headwind .. tailwind)

    // ===== Persistent Powerups (round-long)
    const Owned = new Set();
    const PU = {
      dragMul:1, curveMul:1, spinDecayMul:1, windScaleMul:1, sandFricMul:1, sandPowerMin:0.70, rimHalfBonus:0, vyThreshMul:1
    };
    function resetPowerups(){
      Owned.clear();
      PU.dragMul=1; PU.curveMul=1; PU.spinDecayMul=1; PU.windScaleMul=1;
      PU.sandFricMul=1; PU.sandPowerMin=0.70; PU.rimHalfBonus=0; PU.vyThreshMul=1;
    }
    function grantRandomPowerup(){
      const pool = ['airfoil','gyro','wind','sand','chain'].filter(id=>!Owned.has(id));
      if(!pool.length){ addToast('All powerups acquired'); return; }
      const id = pool[(Math.random()*pool.length)|0];
      Owned.add(id);
      if(id==='airfoil'){ PU.dragMul *= 0.93; addToast('Powerup: Airfoil Polish'); }
      else if(id==='gyro'){ PU.spinDecayMul *= 0.88; PU.curveMul *= 0.97; addToast('Powerup: Gyro Stabilizer'); }
      else if(id==='wind'){ PU.windScaleMul *= 0.80; addToast('Powerup: Wind Tamer'); }
      else if(id==='sand'){ PU.sandFricMul *= 0.90; PU.sandPowerMin = Math.max(PU.sandPowerMin, 0.80); addToast('Powerup: Sand Wedges'); }
      else if(id==='chain'){ PU.rimHalfBonus = Math.min(3, PU.rimHalfBonus + 2); PU.vyThreshMul *= 0.90; addToast('Powerup: Chain Magnet'); }
    }

    function grantBalloonReward(){
      grantRandomPowerup();
    }

    // Release angle / throw style
    let releaseMode = 0;
    let hand = 'RHBH';

    // ---------- Helpers ----------
    const RAND_MAX = 4294967295;
    function hash32(x){ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return x>>>0; }
    function rand01(seed, i){ return hash32((seed ^ (i|0))>>>0) / RAND_MAX; }
    function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function normalizeAngle(a){ while(a > Math.PI) a -= Math.PI*2; while(a < -Math.PI) a += Math.PI*2; return a; }

    // ===== Ambient Audio (hum + wind) with context suspend/resume
    const AudioMini = (()=>{ let ctx=null, windNode=null, masterGain=null; let inited=false;
      function init(){ if(inited) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = ctx.createGain(); masterGain.gain.value=0.18; masterGain.connect(ctx.destination);
        const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
        const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
        const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(masterGain); o1.start(); o2.start();
        const buff = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
        const data = buff.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
        const noise = ctx.createBufferSource(); noise.buffer=buff; noise.loop=true;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=400;
        const wg = ctx.createGain(); wg.gain.value=0.05; noise.connect(lp); lp.connect(wg); wg.connect(masterGain); noise.start();
        windNode = wg; inited=true; if(!windOn) wg.gain.value=0.0;
      }
      async function setEnabled(on){
        if(on){
          init();
          try{ if(ctx.state==='suspended') await ctx.resume(); }catch{}
          if(masterGain) masterGain.gain.value = 0.18;
        } else {
          if(masterGain) masterGain.gain.value = 0.0;
          try{ if(ctx && ctx.state==='running') await ctx.suspend(); }catch{}
        }
      }
      function setWind(on){ if(!inited||!windNode) return; windNode.gain.value = on?0.05:0.0; }
      return { setEnabled, setWind, init };
    })();

    // ===== SFX: randomized throw & chain samples from /audio (kept as <audio>)
    const Sfx = (()=>{
      let enabled = false;
      let unlocked = false; // user-gesture gate (iOS/Chrome mobile)
      const throws = [];
      const chains = [];

      function make(path, vol=1.0){
        const a = new Audio(path); a.preload = 'auto'; a.volume = vol; return a;
      }
      function preload(){
        if(throws.length || chains.length) return;
        for(let i=1;i<=7;i++) throws.push(make(`./audio/throw${i}.mp3`, 0.9));
        for(let i=1;i<=4;i++) chains.push(make(`./audio/chain${i}.mp3`, 1.0));
      }
      function init(){ preload(); unlocked = true; }
      function setEnabled(on){
        enabled = !!on;
        if(!enabled){
          [...throws, ...chains].forEach(a=>{ try{ a.pause(); a.currentTime = 0; }catch{} });
        }
      }
      function playFrom(arr, vol=1.0, rateMin=0.98, rateMax=1.02){
        if(!enabled || !unlocked || !arr.length) return;
        const i = (Math.random()*arr.length)|0;
        const srcUrl = arr[i].src || arr[i].currentSrc;
        const a = new Audio(srcUrl);
        a.preload = 'auto';
        a.volume = vol;
        a.playbackRate = rateMin + Math.random()*(rateMax-rateMin);
        a.onended = function(){ this.src = ''; };
        a.play().catch(()=>{});
      }
      return {
        init,
        setEnabled,
        playThrow(){ playFrom(throws, 0.9, 0.97, 1.06); },
        playChain(){ playFrom(chains, 1.0, 0.96, 1.04); }
      };
    })();

    // Particles
    const particles=[];
    function spawnParticles(type, x, y, count){
      const q = qualityScale();
      const N = Math.max(1, Math.floor(count * (0.7 + 0.3*q)));
      for(let i=0;i<N;i++){
        const a = Math.random()*TAU; const sp = (type==='spark'? 160 + Math.random()*160 : 80+Math.random()*120);
        const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp - (type==='spark'?0:200);
        particles.push({ type, x, y, vx, vy, life: type==='spark'? 0.25: (type==='sand'?0.5:0.6) });
      }
    }

    // Canvas toasts (minimal) with cached width
    const toasts=[];
    function addToast(msg){
      ctx.save(); ctx.font = '600 14px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial';
      const width = Math.ceil(ctx.measureText(msg).width);
      ctx.restore();
      toasts.push({ msg, t:0, dur:2.2, width });
    }

    // === Biomes (colors + mountain profiles) ===
    const BIOMES = [
      { name:'dunes',
        sky:{ bg1:'#9d3e25', bg2:'#f38e41', bg3:'#ffe6ba', water:'#30160f' },
        layers:[
          {par:0.08, base:0.52, a1:30,  a2:16,  f1:0.00050, f2:0.00020, shade:0.02, shape:'sin'},
          {par:0.12, base:0.56, a1:50,  a2:24,  f1:0.00065, f2:0.00026, shade:0.035,shape:'sin'},
          {par:0.18, base:0.61, a1:70,  a2:34,  f1:0.00082, f2:0.00032, shade:0.05, shape:'sin'},
          {par:0.26, base:0.66, a1:104, a2:48,  f1:0.00100, f2:0.00042, shade:0.07,shape:'sin'},
          {par:0.33, base:0.70, a1:116, a2:54,  f1:0.00115, f2:0.00048, shade:0.085,shape:'sin'},
          {par:0.40, base:0.74, a1:126, a2:58,  f1:0.00125, f2:0.00052, shade:0.10, shape:'sin'}
        ]
      },
      { name:'crags',
        sky:{ bg1:'#5b1a2b', bg2:'#d5425a', bg3:'#f8c3da', water:'#2c0f19' },
        layers:[
          {par:0.06, base:0.50, a1:60,  a2:36,  f1:0.00055, f2:0.00022, shade:0.02, shape:'crag'},
          {par:0.10, base:0.58, a1:95,  a2:52,  f1:0.00075, f2:0.00030, shade:0.05, shape:'crag'},
          {par:0.16, base:0.64, a1:140, a2:70,  f1:0.00095, f2:0.00040, shade:0.08, shape:'crag'},
          {par:0.24, base:0.70, a1:170, a2:86,  f1:0.00115, f2:0.00055, shade:0.11,shape:'crag'},
          {par:0.36, base:0.76, a1:190, a2:96,  f1:0.00135, f2:0.00065, shade:0.13,shape:'crag'}
        ]
      },
      { name:'hills',
        sky:{ bg1:'#233d6d', bg2:'#5d79b0', bg3:'#cfe2ff', water:'#0e2233' },
        layers:[
          {par:0.10, base:0.54, a1:36,  a2:18,  f1:0.00044, f2:0.00018, shade:0.02, shape:'round'},
          {par:0.16, base:0.60, a1:60,  a2:28,  f1:0.00062, f2:0.00024, shade:0.04, shape:'round'},
          {par:0.22, base:0.66, a1:90,  a2:42,  f1:0.00080, f2:0.00032, shade:0.06, shape:'round'},
          {par:0.30, base:0.71, a1:115, a2:56,  f1:0.00098, f2:0.00040, shade:0.08, shape:'round'},
          {par:0.38, base:0.75, a1:132, a2:64,  f1:0.00112, f2:0.00048, shade:0.10, shape:'round'}
        ]
      },
      { name:'mesas',
        sky:{ bg1:'#6e3b1b', bg2:'#cf7b35', bg3:'#ffe1b0', water:'#2a1a12' },
        layers:[
          {par:0.08, base:0.54, a1:42,  a2:20,  f1:0.00058, f2:0.00022, shade:0.02, shape:'mesa'},
          {par:0.13, base:0.60, a1:70,  a2:32,  f1:0.00076, f2:0.00030, shade:0.04, shape:'mesa'},
          {par:0.20, base:0.66, a1:96,  a2:46,  f1:0.00096, f2:0.00038, shade:0.06, shape:'mesa'},
          {par:0.28, base:0.72, a1:120, a2:56,  f1:0.00116, f2:0.00046, shade:0.08, shape:'mesa'},
          {par:0.36, base:0.76, a1:140, a2:64,  f1:0.00128, f2:0.00054, shade:0.10, shape:'mesa'}
        ]
      }
    ];


    // ===== Biome selection weights & variants (visual diversity)
const BIOME_WEIGHTS = {
  dunes: 0.28,
  crags: 0.22,
  hills: 0.28,
  mesas: 0.22
};

const BIOME_VARIANTS = {
  dunes: [
    { id:'oasis',  label:'Oasis Dunes',    weight:0.55, treeStyle:'palm',    extras:{ mixCacti:true } },
    { id:'cactus', label:'Cactus Flats',  weight:0.45, treeStyle:'cactus' }
  ],
  crags: [
    { id:'deadwood', label:'Deadwood',     weight:0.70, treeStyle:'dead' },
    { id:'pines',    label:'Sparse Pines', weight:0.30, treeStyle:'pine' }
  ],
  hills: [
    { id:'pine', label:'Highland Pines',   weight:0.55, treeStyle:'pine' },
    { id:'snow', label:'Snowfield',        weight:0.45, treeStyle:'snowpine', extras:{ snowbanks:true },
      skyOverride:{ bg1:'#1e2a40', bg2:'#5b7aa6', bg3:'#dbe8ff', water:'#0b1a2a' } }
  ],
  mesas: [
    { id:'juniper', label:'Juniper Mesa',  weight:0.40, treeStyle:'juniper' },
    { id:'cactus',  label:'Cactus Mesa',   weight:0.60, treeStyle:'cactus' }
  ]
};

function pickWeighted(list, weightFn){
  let total = 0;
  for(const item of list){ total += Math.max(0, (weightFn(item) ?? 1)); }
  if(total <= 0) return list[(Math.random()*list.length)|0];
  let r = Math.random() * total;
  for(const item of list){
    r -= Math.max(0, (weightFn(item) ?? 1));
    if(r <= 0) return item;
  }
  return list[list.length-1];
}

    function applyTheme(biome, biomeVariant){
  // Establish biome baseline for later tint/overrides (clear/dusk/night)
  const sky = Object.assign({}, biome.sky, (biomeVariant && biomeVariant.skyOverride) ? biomeVariant.skyOverride : null);
  baseSky = { bg1: sky.bg1, bg2: sky.bg2, bg3: sky.bg3, water: sky.water };

  const r = document.documentElement;
  r.style.setProperty('--bg1', sky.bg1);
  r.style.setProperty('--bg2', sky.bg2);
  r.style.setProperty('--bg3', sky.bg3);
  r.style.setProperty('--water', sky.water);

  // Time-of-day variant will re-tint the sky variables after this call.
}

    // Backdrop (sun + clouds + mountains) with pre-rendered layers/sprites
    let currentBiome = BIOMES[0];
    let currentBiomeVariant = null;
    const backdrop = {
      seed:(Math.random()*1e9)|0,
      mountains:[],
      mountainsImg:[], // offscreen canvases per layer
      sun:null,
      clouds:[],
      cloudDir:1,
      windmills:[],
      bgStructures:[], // silos, water towers, radio towers, etc.
      stars:[],
      moon:null
    };

    function triangleWave(x){ return (2/Math.PI)*Math.asin(Math.sin(x)); }
    function mesaWave(x){ const k=2.2; return Math.tanh(Math.sin(x)*k)/Math.tanh(k); }
    function roundWave(x){ const s=Math.sin(x); return Math.sign(s)*Math.pow(Math.abs(s),0.85); }
    function cragWave(x){ return 0.7*triangleWave(x) + 0.3*Math.sin(x*3.0); }
    function shapeSample(shape, x){
      switch(shape){
        case 'mesa':   return mesaWave(x);
        case 'round':  return roundWave(x);
        case 'crag':   return cragWave(x);
        case 'sin':
        default:       return Math.sin(x);
      }
    }

    function buildBackdrop(){
      const L = [];
      currentBiome.layers.forEach((spec, i)=>{
        const s = (backdrop.seed ^ hash32((spec.par*1000)|0) ^ i)>>>0;
        const base = WORLD.h*spec.base;
        const ph   = rand01(s,1)*TAU;
        const curv = { a: 10 + rand01(s,3)*16, f: 0.0012 + rand01(s,4)*0.0006, ph: rand01(s,2)*TAU };
        L.push({ parallax:spec.par, base, a1:spec.a1, a2:spec.a2, f1:spec.f1, f2:spec.f2, ph, shade:spec.shade, curv, shape:spec.shape });
      });
      backdrop.mountains = L;

      // Sun
      const u = 0.20 + rand01(backdrop.seed,101)*0.60;
      const v = 0.16 + rand01(backdrop.seed,102)*0.20;
      const phase = rand01(backdrop.seed,103)*TAU;
      const baseR = 20 + Math.floor(rand01(backdrop.seed,104)*12);
      backdrop.sun = { u, v, phase, baseR };

      // Clouds
      backdrop.cloudDir = rand01(backdrop.seed,399) < 0.5 ? -1 : 1;
      buildCloudField();

      // Windmills
      buildWindmills();

      // Background structures (silos, water towers, radio towers, etc.)
      buildBgStructures();

      // Stars & moon (for night/dusk; drawn with alpha driven by atmo.night)
      buildStarsAndMoon();

      // pre-render mountain layers
      rebuildMountainsOffscreen();
    }

    function buildStarsAndMoon(){
      backdrop.stars.length = 0;
      backdrop.moon = null;

      const sseed = hash32(backdrop.seed ^ 0x51A7BEEF);
      const count = 90 + Math.floor(rand01(sseed,1)*140);
      for(let i=0;i<count;i++){
        const u = rand01(sseed, 10+i*3+1);
        const v = rand01(sseed, 10+i*3+2);
        const r = 0.6 + rand01(sseed, 10+i*3+3)*1.8;
        const tw = 0.6 + rand01(sseed, 900+i)*1.8;
        const ph = rand01(sseed, 1200+i)*TAU;
        // Keep stars in upper ~60% to avoid "stars in ground fog"
        const vv = 0.05 + v*0.55;
        backdrop.stars.push({ u, v: vv, r, tw, ph });
      }

      // Moon (position similar to sun but distinct)
      const mu = 0.22 + rand01(sseed,2201)*0.60;
      const mv = 0.10 + rand01(sseed,2202)*0.22;
      const mr = 18 + rand01(sseed,2203)*10;
      const wax = rand01(sseed,2204);
      backdrop.moon = { u:mu, v:mv, r:mr, wax };
    }

    function buildCloudField(){
      backdrop.clouds.length = 0;
      const count = 3 + Math.floor(rand01(backdrop.seed,300)*4);
      for(let i=0;i<count;i++){
        const s = hash32(backdrop.seed ^ (0xA11C10 + i*131));
        const u = rand01(s,1);
        const v = 0.12 + (i+1)/(count+1) * 0.42 + (rand01(s,2)-0.5)*0.05;
        const parX = 0.04 + rand01(s,3)*0.05;
        const parY = 0.015 + rand01(s,4)*0.02;
        const speed = backdrop.cloudDir * (4 + rand01(s,6)*6);
        const alpha = 0.05 + rand01(s,7)*0.08;
        const scale = 0.9 + rand01(s,8)*1.6;
        const cloud = { seed:s, u, v, parX, parY, speed, alpha, scale, sprite:null, spriteW:0, spriteH:0 };
        cloud.sprite = makeCloudSprite(cloud);
        backdrop.clouds.push(cloud);
      }
    }

    function makeCloudSprite(C){
      const cvs = document.createElement('canvas');
      const cctx = cvs.getContext('2d');
      const pad = Math.ceil(80 * C.scale);
      const width  = Math.ceil(240 * C.scale) + pad * 2;
      const height = Math.ceil(120 * C.scale) + pad * 2;
      cvs.width = width; cvs.height = height;
      const cx = width/2, cy = height/2;

      cctx.globalCompositeOperation = 'lighter';
      cctx.globalAlpha = C.alpha;

      const baseR = 28 * C.scale;
      const puffCount = 4 + Math.floor(rand01(C.seed,11)*4);
      for(let i=0;i<puffCount;i++){
        const r  = (baseR + rand01(C.seed,20+i)*22*C.scale);
        const ox = (i - (puffCount-1)/2) * (r*0.9) + (rand01(C.seed,30+i)-0.5)*r*0.3;
        const oy = (rand01(C.seed,40+i)-0.5) * r * 0.35;
        const px = cx + ox, py = cy + oy;
        const g = cctx.createRadialGradient(px, py, r*0.2, px, py, r*1.5);
        g.addColorStop(0,'rgba(255,255,255,0.45)');
        g.addColorStop(0.4,'rgba(255,255,255,0.22)');
        g.addColorStop(1,'rgba(255,255,255,0.00)');
        cctx.fillStyle = g; cctx.beginPath(); cctx.arc(px, py, r*1.5, 0, TAU); cctx.fill();
      }

      cctx.globalAlpha = C.alpha;
      const coreR = Math.min(width, height) * 0.28;
      const core = cctx.createRadialGradient(cx, cy, coreR*0.1, cx, cy, coreR);
      core.addColorStop(0,'rgba(255,255,255,0.18)');
      core.addColorStop(1,'rgba(255,255,255,0.00)');
      cctx.fillStyle = core; cctx.beginPath(); cctx.arc(cx, cy, coreR, 0, TAU); cctx.fill();

      const sh = cctx.createRadialGradient(cx + coreR*0.1, cy + coreR*0.4, coreR*0.15, cx + coreR*0.1, cy + coreR*0.4, coreR*1.1);
      sh.addColorStop(0, 'rgba(0,0,0,0.06)'); sh.addColorStop(1, 'rgba(0,0,0,0.00)');
      cctx.fillStyle = sh; cctx.beginPath(); cctx.arc(cx + coreR*0.1, cy + coreR*0.4, coreR*1.1, 0, TAU); cctx.fill();

      C.spriteW = width; C.spriteH = height;
      return cvs;
    }

    function buildWindmills(){
      backdrop.windmills.length = 0;
      const count = 1 + Math.floor(rand01(backdrop.seed,810)*4);
      const used = [];
      for(let i=0, tries=count*8; i<tries && backdrop.windmills.length<count; i++){
        const s = hash32(backdrop.seed ^ (0xC0FFEE + i*997));
        const u = 0.12 + rand01(s,1)*0.76;
        const x = WORLD.w * u;
        if(!used.every(px => Math.abs(px - x) > 420)) continue;
        used.push(x);

        const h = 90 + rand01(s,2)*48;
        const r = 26 + rand01(s,3)*10;
        const speed = 0.8 + rand01(s,4)*1.0;
        const spin0 = rand01(s,5)*TAU;
        const tilt = (rand01(s,6)-0.5) * (14*Math.PI/180);

        backdrop.windmills.push({ x, h, r, speed, spin0, tilt });
      }
    }

    // Background structures: silhouettes rendered on the farthest mountain layer
    function buildBgStructures(){
      backdrop.bgStructures.length = 0;
      const types = ['silo','water_tower','radio_tower','church','grain_elevator','power_lines','barn_bg','lookout_tower'];
      const count = 2 + Math.floor(rand01(backdrop.seed,900)*4); // 2-5 structures
      const used = [];
      for(let i=0, tries=count*10; i<tries && backdrop.bgStructures.length<count; i++){
        const s = hash32(backdrop.seed ^ (0xBEEF00 + i*1301));
        const u = 0.08 + rand01(s,1)*0.84;
        const x = WORLD.w * u;
        // Min spacing from other structures and from windmills
        if(!used.every(px => Math.abs(px - x) > 300)) continue;
        if(backdrop.windmills.some(w => Math.abs(w.x - x) < 300)) continue;
        used.push(x);
        const type = types[Math.floor(rand01(s,2)*types.length)];
        const scale = 0.7 + rand01(s,3)*0.6;
        const seed = s;
        backdrop.bgStructures.push({ x, type, scale, seed });
      }
    }

    function mountainYAt(L, wx){
      let y = L.base
        - shapeSample(L.shape, wx*L.f1)*L.a1
        - shapeSample(L.shape, wx*L.f2 + L.ph)*L.a2;
      if(L.curv){
        y -= Math.sin(wx*L.curv.f   + L.curv.ph)      * L.curv.a;
        y -= Math.sin(wx*L.curv.f*2 + L.curv.ph*1.3) * (L.curv.a*0.45);
      }
      return y;
    }

    function rebuildMountainsOffscreen(){
      backdrop.mountainsImg = [];
      const w = WORLD.w, h = WORLD.h;
      for(let idx=0; idx<backdrop.mountains.length; idx++){
        const L = backdrop.mountains[idx];
        const off = document.createElement('canvas');
        off.width = w; off.height = h;
        const ox = off.getContext('2d');
        ox.fillStyle = `rgba(0,0,0,${0.18 + L.shade})`;
        const step = Math.max(8, 16 - idx*2);
        ox.beginPath(); ox.moveTo(0,h);
        for(let x=0;x<=w;x+=step){
          const y = mountainYAt(L, x);
          ox.lineTo(x, y);
        }
        ox.lineTo(w,h); ox.closePath(); ox.fill();
        backdrop.mountainsImg.push(off);
      }
    }

    // ===== World / Hole
    const disc = { x:0,y:0,vx:0,vy:0,r:7.5, atRest:true, onGround:true, lastSafe:{x:0,y:0}, orient:0,
                   spin:0, spin0:1, bank:0 };
    let strokes=0;
    let holeIndex=0, roundData=null;
    let hole=null;

    // Aim/meter state
    let aiming=false, aimAngle=0, meter=0, meterDir=1, meterOn=false;

// --- Aim prediction preview (during hold-to-throw) ---
const PRED_PATH_SEC = 1.7;   // draw arc for ~2s
const PRED_LAND_SEC = 4.0;   // simulate longer for landing estimate
const PRED_DT = 1/30; // coarser sim for preview (perf)
let predPath = null;         // [{x,y}, ...] world coords
let predLanding = null;      // {x,y}
let predDeltaText = '';
let predLastCalcMs = 0;
let predCache = { angle:NaN, power:NaN, windLift:NaN, windSide:NaN, releaseMode:NaN, hand:'' };

    // Scenery
    let scenery = { trees:[], rocks:[], fences:[], snowbanks:[] };

    // Fireflies (night/dusk chance)
    let fireflies = [];
    function buildFireflies(){
      fireflies = [];
      const q = qualityScale();
      const night = clamp(atmo.night, 0, 1);
      // Chance-based: dusk/night = likely; other variants = rare
      const baseChance = 0.05 + 0.25*night; // 0.05..0.30 (reduced firefly frequency)
      if(Math.random() > baseChance) return;

      const count = Math.floor((6 + Math.random()*8) * (0.55 + 0.45*q) * (0.35 + 0.65*night));
      const x0 = clamp(view.x + 40, 0, WORLD.w);
      const x1 = clamp(view.x + view.w - 40, 0, WORLD.w);

      for(let i=0;i<count;i++){
        const x = lerp(x0, x1, Math.random());
        const gy = groundYAt(x);
        const y = gy - (40 + Math.random()*160);
        const phase = Math.random()*TAU;
        const speed = 0.8 + Math.random()*1.4;
        const amp = 7 + Math.random()*18;
        const glow = 0.5 + Math.random()*0.7;
        const r = 0.7 + Math.random()*1.0;
        const hue = 46 + Math.random()*24; // warm yellow-green
        fireflies.push({ x, y, baseY:y, phase, speed, amp, glow, r, hue, vx:(Math.random()*18-9) });
      }
    }
    function updateFireflies(dt){
      if(!fireflies.length) return;
      const night = clamp(atmo.night, 0, 1);
      if(night <= 0.05){
        // fade out quickly when switching to daytime
        if(Math.random() < 0.15) fireflies.length = Math.max(0, fireflies.length - 1);
        return;
      }

      const left = view.x - 120, right = view.x + view.w + 120;
      for(let i=fireflies.length-1;i>=0;i--){
        const F = fireflies[i];
        F.phase += F.speed * dt;
        F.x += F.vx * dt;
        const gy = groundYAt(clamp(F.x, 0, hole.w));
        // keep hovering above ground and gently bobbing
        const bob = Math.sin(F.phase) * F.amp;
        F.y = (gy - 70) + (F.baseY - (gy - 70))*0.02 + bob;

        if(F.x < left) { F.x = right; F.baseY = gy - (60 + Math.random()*160); }
        if(F.x > right) { F.x = left; F.baseY = gy - (60 + Math.random()*160); }
      }
    }
    function drawFireflies(){
      if(!fireflies.length) return;
      const night = clamp(atmo.night, 0, 1);
      if(night <= 0.05) return;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const alphaMul = (reducedMotion ? 0.85 : 1.0) * night;

      for(const F of fireflies){
        const sx = F.x - view.x;
        const sy = F.y - view.y;
        if(sx < -30 || sx > canvas.width/DPR + 30 || sy < -30 || sy > canvas.height/DPR + 30) continue;

        const tw = 0.5 + 0.5*Math.sin(F.phase*2.4 + F.x*0.01);
        const a = Math.max(0, (0.14 + 0.38*tw) * F.glow * alphaMul);

        const col = `hsla(${F.hue}, 90%, 70%, ${a})`;
        const r = F.r;

        // halo
        const g = ctx.createRadialGradient(sx, sy, r*0.5, sx, sy, r*4.5);
        g.addColorStop(0, col);
        g.addColorStop(1, `hsla(${F.hue}, 90%, 70%, 0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(sx, sy, r*4.5, 0, TAU); ctx.fill();

        // core
        ctx.globalAlpha = 0.85*a;
        ctx.fillStyle = '#fff8c8';
        ctx.beginPath(); ctx.arc(sx, sy, r, 0, TAU); ctx.fill();
        ctx.globalAlpha = 1;
      }
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    }

    
    // --- Ravens (sometimes, dusk + night) ---
    const ravens = [];
    function updateRavens(dt){
      if(reducedMotion){ ravens.length = 0; return; }
      const nightiness = (atmo && typeof atmo.night === 'number') ? atmo.night : 0;
      if(nightiness >= 0.55){
        const rate = nightiness > 0.8 ? 0.070 : 0.045; // spawns per second
        if(Math.random() < rate * dt){
          const sw = canvas.width / DPR;
          const dir = (Math.random() < 0.5) ? 1 : -1;
          const x = (dir === 1) ? -70 : (sw + 70);
          const y = 40 + Math.random() * 140;
          const speed = (80 + Math.random()*120) * dir;
          const vy = (-12 + Math.random()*24);
          ravens.push({
            x, y, vx: speed, vy,
            span: 12 + Math.random()*10,
            flapAmp: 2.5 + Math.random()*4.5,
            flapSpeed: 7 + Math.random()*7,
            phase: Math.random()*Math.PI*2
          });
          if(ravens.length > 10) ravens.shift();
        }
      }
      const sw = canvas.width / DPR;
      const sh = canvas.height / DPR;
      for(let i=ravens.length-1;i>=0;i--){
        const r = ravens[i];
        r.x += r.vx * dt;
        r.y += r.vy * dt;
        r.phase += dt * r.flapSpeed;
        if(r.x < -120 || r.x > sw + 120 || r.y < -120 || r.y > sh + 120){
          ravens.splice(i,1);
        }
      }
    }
    function drawRavens(){
      const nightiness = (atmo && typeof atmo.night === 'number') ? atmo.night : 0;
      if(nightiness < 0.55 || ravens.length === 0) return;
      ctx.save();
      ctx.globalAlpha = 0.18 + 0.22 * Math.min(1, nightiness);
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.strokeStyle = (nightiness > 0.8) ? 'rgba(0,0,0,0.85)' : 'rgba(10,10,10,0.70)';
      for(const r of ravens){
        const flap = Math.sin(r.phase) * r.flapAmp;
        const s = r.span;
        ctx.beginPath();
        ctx.moveTo(r.x - s, r.y + flap);
        ctx.quadraticCurveTo(r.x, r.y - flap*0.25, r.x + s, r.y + flap);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(r.x - 3, r.y + 1);
        ctx.lineTo(r.x + 3, r.y + 1);
        ctx.stroke();
      }
      ctx.restore();
    }

// ===== Procedural hole
    function genHole(){
      const w = WORLD.w, h = WORLD.h;
      const step=40;
      const teeX = 120; // fixed tee position

      const tilt = (Math.random()*2-1) * 0.16;
      const tiltAmp = 160;

      let seed = Math.random()*9999;
      function nrand(){ seed = Math.sin(seed)*10000; return seed - Math.floor(seed); }
      const amp1 = 70 + nrand()*110, freq1 = 1/(520+ nrand()*420);
      const amp2 = 22 + nrand()*42,  freq2 = 1/(220 + nrand()*250);

      const baseY0 = h*0.72;
      const points=[];

      for(let x=0;x<=w;x+=step){
        const t = x/w;
        const tiltOffset = (t-0.5) * tiltAmp * tilt;
        const y = baseY0 + tiltOffset
                - Math.sin(x*freq1)*amp1
                - Math.sin(x*freq2)*amp2;
        points.push({x,y});
      }

      const featureCount = Math.floor(Math.random()*3);
      for(let f=0; f<featureCount; f++){
        const cx = lerp(w*0.18, w*0.82, Math.random());
        const sigma = 120 + Math.random()*220;
        const amp = (Math.random()<0.5? -1:1) * (50 + Math.random()*90);
        for(let i=0;i<points.length;i++){
          const dx = points[i].x - cx;
          const k = Math.exp(-(dx*dx)/(2*sigma*sigma));
          points[i].y += amp * k;
        }
      }

      if(Math.random() < 0.33){
        const cx = lerp(w*0.30, w*0.70, Math.random());
        const up = Math.random() < 0.5 ? -1 : 1;
        const drop = up * (120 + Math.random()*120);
        const sharp = 60 + Math.random()*80;
        for(let i=0;i<points.length;i++){
          const dx = (points[i].x - cx) / sharp;
          const s = 1/(1+Math.exp(-dx));
          points[i].y += drop * s;
        }
      }

      // Choose hole length so pars vary meaningfully across holes.
      const rLen = Math.random();
      let targetDist;
if (rLen < 0.40) targetDist = lerp(800, 1150, Math.random());         // short (often par 3)
else if (rLen < 0.80) targetDist = lerp(1200, 1900, Math.random());   // medium (often par 4)
else if (rLen < 0.95) targetDist = lerp(2000, 2600, Math.random());   // long (often par 5)
else targetDist = lerp(2600, 3000, Math.random());                    // very long (often par 6)
const cupX = clamp(teeX + targetDist, teeX + 820, w - 220);
const gWidth = 200 + Math.random()*160;
      const gx0=cupX-gWidth/2, gx1=cupX+gWidth/2;
      const greenSlope = (Math.random()*0.6-0.3);
      let greenY = 0;

      for(let i=0;i<points.length;i++){
        if(points[i].x>=gx0 && points[i].x<=gx1){
          const t = (points[i].x-gx0)/gWidth;
          const gy = (baseY0-30) + (Math.sin(points[i].x*freq2)*6) + greenSlope*(t-0.5)*40;
          points[i].y = gy;
          greenY = gy;
        }
      }

      // ===== HOLE LAYOUT VARIANTS =====
      // Each layout sculpts terrain into a distinctive shape. Picked randomly (~40% of holes get a special layout).
      const HOLE_LAYOUTS = ['valley_carry','island_green','ridgeback','canyon','plateau_green','downhill'];
      const layoutRoll = Math.random();
      const holeLayout = layoutRoll < 0.40 ? HOLE_LAYOUTS[(Math.random()*HOLE_LAYOUTS.length)|0] : 'standard';

      if(holeLayout === 'valley_carry'){
        // Deep valley with water between tee and green; green is raised.
        const valleyCx = lerp(teeX + 200, cupX - 200, 0.45 + Math.random()*0.1);
        const valleyW = 260 + Math.random()*180;
        const valleyD = 100 + Math.random()*60; // depth (canvas Y down = deeper)
        for(let i=0;i<points.length;i++){
          const dx = points[i].x - valleyCx;
          const t = dx / (valleyW * 0.5);
          if(Math.abs(t) < 1.0){
            const shape = Math.cos(t * Math.PI * 0.5); // smooth U shape
            points[i].y += valleyD * shape;
          }
        }
        // Raise the green side
        for(let i=0;i<points.length;i++){
          if(points[i].x >= gx0 - 80 && points[i].x <= gx1 + 80){
            const edgeT = (points[i].x < gx0) ? (points[i].x - (gx0-80))/80 :
                          (points[i].x > gx1) ? (gx1+80 - points[i].x)/80 : 1;
            points[i].y -= 45 * Math.max(0, edgeT);
          }
        }
      }
      else if(holeLayout === 'island_green'){
        // Depress terrain around the green to create a water-surrounded island.
        const moatInner = gWidth * 0.5 + 20;
        const moatOuter = moatInner + 140 + Math.random()*80;
        const moatDepth = 80 + Math.random()*40;
        for(let i=0;i<points.length;i++){
          const dx = Math.abs(points[i].x - cupX);
          if(dx > moatInner && dx < moatOuter){
            const t = (dx - moatInner) / (moatOuter - moatInner);
            const shape = Math.sin(t * Math.PI); // deepest in middle of moat
            points[i].y += moatDepth * shape;
          }
        }
        // Slightly raise the green island itself
        for(let i=0;i<points.length;i++){
          if(points[i].x >= gx0 && points[i].x <= gx1){
            points[i].y -= 20;
          }
        }
      }
      else if(holeLayout === 'ridgeback'){
        // Raised spine down the middle third of the fairway; disc rolls off to sides.
        const ridgeStart = lerp(teeX + 160, cupX - 300, 0.1);
        const ridgeEnd = lerp(teeX + 400, cupX - 100, 0.9);
        const ridgeH = 55 + Math.random()*35;
        for(let i=0;i<points.length;i++){
          const px = points[i].x;
          if(px >= ridgeStart && px <= ridgeEnd){
            const along = (px - ridgeStart) / (ridgeEnd - ridgeStart);
            const envelope = Math.sin(along * Math.PI); // taper at ends
            // Raise center, creating a crown
            const midFairway = lerp(teeX, cupX, along);
            const cross = (px - midFairway);
            const crossW = 140 + Math.random()*60;
            const crown = Math.exp(-(cross*cross)/(2*crossW*crossW));
            points[i].y -= ridgeH * envelope * crown;
          }
        }
      }
      else if(holeLayout === 'canyon'){
        // Tight corridor: raise walls on both sides of the fairway mid-section.
        const canyonStart = lerp(teeX + 180, cupX * 0.4, Math.random()*0.3);
        const canyonEnd = lerp(cupX * 0.6, cupX - 160, 0.7 + Math.random()*0.3);
        const wallH = 70 + Math.random()*50;
        const corridorW = 160 + Math.random()*100;
        for(let i=0;i<points.length;i++){
          const px = points[i].x;
          if(px >= canyonStart && px <= canyonEnd){
            const along = (px - canyonStart) / (canyonEnd - canyonStart);
            const envelope = Math.sin(along * Math.PI);
            // Fairway center line
            const centerLine = lerp(teeX, cupX, along);
            const off = Math.abs(px - centerLine);
            if(off > corridorW * 0.5){
              const wallT = Math.min(1, (off - corridorW*0.5) / 120);
              points[i].y -= wallH * envelope * wallT;
            }
          }
        }
      }
      else if(holeLayout === 'plateau_green'){
        // Green sits on a raised flat mesa with steep drop-offs.
        const plateauW = gWidth + 100 + Math.random()*60;
        const plateauH = 65 + Math.random()*40;
        const rampW = 60 + Math.random()*40;
        for(let i=0;i<points.length;i++){
          const dx = points[i].x - cupX;
          const adx = Math.abs(dx);
          if(adx < plateauW * 0.5){
            points[i].y -= plateauH;
          } else if(adx < plateauW * 0.5 + rampW){
            const t = (adx - plateauW*0.5) / rampW;
            points[i].y -= plateauH * (1 - t*t); // quadratic ramp
          }
        }
      }
      else if(holeLayout === 'downhill'){
        // Dramatic elevation drop from tee to green.
        const dropAmt = 100 + Math.random()*80;
        for(let i=0;i<points.length;i++){
          const t = clamp((points[i].x - teeX) / (cupX - teeX), 0, 1);
          // Smooth S-curve drop
          const s = t*t*(3-2*t);
          points[i].y += dropAmt * s;
        }
      }

      function scanBasins(){
        const n = points.length, out=[];
        const bankMin = 32, bankMax = 64;
        for(let i=2;i<n-2;i++){
          const yL = points[i-1].y, yC = points[i].y, yR = points[i+1].y;
          if(!(yC < yL && yC < yR)) continue;

          const bottom = yC;
          let surface = bottom + (bankMin + Math.random()*(bankMax - bankMin));

          let L=i, R=i;
          while(L>0 && points[L].y <= surface) L--;
          while(R<n-1 && points[R].y <= surface) R++;
          const leftShoulder  = Math.max(points[Math.max(L-1,0)].y,   points[Math.max(L-2,0)].y);
          const rightShoulder = Math.max(points[Math.min(R+1,n-1)].y, points[Math.min(R+2,n-1)].y);
          // IMPORTANT: Canvas Y increases downward. Keep the water surface *below* both banks
          // to prevent the lake from clipping through ground/walls.
          const spillY = Math.max(leftShoulder, rightShoulder) + 8;
          if(surface < spillY) surface = spillY;

          L=i; R=i;
          while(L>0 && points[L].y <= surface) L--;
          while(R<n-1 && points[R].y <= surface) R++;

          let x0 = points[L].x, x1 = points[R].x;
          // Compute exact shoreline intersections with the water surface to avoid visual clipping
          if(L < n-1){
            const a = points[L], b = points[L+1];
            if(a.y !== b.y){
              const t = (surface - a.y) / (b.y - a.y);
              if(t > 0 && t < 1) x0 = a.x + t*(b.x - a.x);
            }
          }
          if(R > 0){
            const a = points[R-1], b = points[R];
            if(a.y !== b.y){
              const t = (surface - a.y) / (b.y - a.y);
              if(t > 0 && t < 1) x1 = a.x + t*(b.x - a.x);
            }
          }
          const width = x1 - x0;
          const cx = (x0 + x1) * 0.5;
          out.push({ i, x0, x1, width, cx, surfaceY:surface, bottomY:bottom });
        }
        return out;
      }

      const basinsAll = scanBasins();

      const waters=[];
      (function buildWaters(){
        // Water frequency tuning: allow narrower basins so water appears more often.
        const minWidth = 120;      // preferred minimum basin width for water
        const minWidthFinal = 90;  // allow shorter spans after clipping away from green/edges
        const waterCandidates = basinsAll
          .filter(b => b.width >= minWidth)
          .sort((a,b)=>{
            const dw = b.width - a.width;
            if(Math.abs(dw) > 1) return dw;
            const ma = Math.abs(a.cx - w*0.5);
            const mb = Math.abs(b.cx - w*0.5);
            return ma - mb;
          });

        function clipAwayFromGreen(x0,x1){
          if(x0 < gx1 && x1 > gx0){
            const leftOverlap  = Math.max(0, gx1 - x0);
            const rightOverlap = Math.max(0, x1 - gx0);
            if(leftOverlap < rightOverlap) x0 = gx1; else x1 = gx0;
          }
          return [x0,x1];
        }

        for(const b of waterCandidates){
          if(waters.length >= 2) break;
          let x0 = clamp(b.x0 + 1, 60, w-60);
          let x1 = clamp(b.x1 - 1, 60, w-60);
          [x0,x1] = clipAwayFromGreen(x0,x1);
          if (x1 - x0 < minWidthFinal) continue;
          const overlaps = waters.some(p => Math.min(p.x+p.w, x1) - Math.max(p.x, x0) > 40);
          if(overlaps) continue;
          waters.push({ x:x0, w:(x1-x0), y:b.surfaceY, h: h - b.surfaceY + 60, seed:(Math.random()*1e9)|0 });
        }

        if(!waters.length){
          const near = basinsAll.sort((a,b)=>Math.abs(a.cx-cupX)-Math.abs(b.cx-cupX))[0];
          if(near){
            let x0 = clamp(near.x0 + 1,60,w-60), x1 = clamp(near.x1 - 1,60,w-60);
            [x0,x1] = clipAwayFromGreen(x0,x1);
            if (x1 - x0 >= minWidthFinal) {
              waters.push({ x:x0, w:(x1-x0), y:near.surfaceY, h:h-near.surfaceY+60, seed:(Math.random()*1e9)|0 });
            }
          }
        }
      })();

      const sands=[];
      const roughs=[];
      const roughN = Math.floor(Math.random()*4);
      for(let i=0;i<roughN;i++){
        const rx = lerp(w*0.20, cupX-140, Math.random());
        const ry = sampleY(points, rx) - 6;
        roughs.push({ x:rx, y:ry, r: 42 + Math.random()*30 });
      }

      const teeIdx = Math.floor(teeX/step);
      const teeY = points[teeIdx].y - 2;
      points[teeIdx].y = teeY;

      if(Math.random()<0.6){
        const vX = lerp(w*0.40, w*0.62, Math.random());
        const vIdx = Math.floor(vX/step);
        for(let i=-3;i<=3;i++){
          const k=vIdx+i; if(points[k]) points[k].y += Math.abs(i)* (16 + Math.random()*12);
        }
      }

      const dist = cupX - teeX;
let par = 3;
if (dist >= 2700) par = 6;
else if (dist >= 2000) par = 5;
else if (dist >= 1200) par = 4;

      // For island_green, ensure moat basins get water even if natural basin detection is sparse.
      if(holeLayout === 'island_green' && waters.length === 0){
        const moatInner = gWidth * 0.5 + 20;
        const moatOuter = moatInner + 140;
        // Left moat
        const lx0 = cupX - moatOuter, lx1 = cupX - moatInner;
        const lSurf = sampleY(points, (lx0+lx1)*0.5) + 10;
        if(lx1 > lx0 + 60) waters.push({ x:lx0, w:lx1-lx0, y:lSurf, h:h-lSurf+60, seed:(Math.random()*1e9)|0 });
        // Right moat
        const rx0 = cupX + moatInner, rx1 = cupX + moatOuter;
        const rSurf = sampleY(points, (rx0+rx1)*0.5) + 10;
        if(rx1 > rx0 + 60) waters.push({ x:rx0, w:rx1-rx0, y:rSurf, h:h-rSurf+60, seed:(Math.random()*1e9)|0 });
      }

      const result = {
        w, h, points, step, cupX,
        green:{x0:gx0,x1:gx1,y:0},
        waters,
        sands,
        roughs,
        tee:{x:teeX,y:teeY},
        par,
        layout: holeLayout
      };
// Wind Geyser
(function addGeyser(H){
  // Updraft vent (visual + physics). Spawns probabilistically and chooses a varied position.
  let chance = 0.45;
  if (typeof currentBiomeVariant !== 'undefined' && currentBiomeVariant){
    if (currentBiomeVariant.id === 'snow')  chance = 0.28;
    if (currentBiomeVariant.id === 'oasis') chance = 0.38;
  }
  if (Math.random() >= chance){ H.geyser = null; return; }

  // Placement: pick one of three longitudinal zones so it doesn't always land in the same spot.
  const leftEdge  = Math.min(H.tee.x, H.cupX) + 280;
  const rightEdge = Math.max(H.tee.x, H.cupX) - 240;

  const minX = clamp(Math.min(leftEdge, rightEdge), 140, H.w - 140);
  const maxX = clamp(Math.max(leftEdge, rightEdge), 140, H.w - 140);
  const span = Math.max(260, maxX - minX);

  const z0 = minX;
  const z1 = minX + span*0.33;
  const z2 = minX + span*0.66;
  const zones = [
    [z0, z1],
    [z1 - 40, z2 + 40],
    [z2, minX + span]
  ];
  const z = zones[(Math.random()*zones.length)|0];
  const gx = clamp(z[0] + Math.random()*(z[1]-z[0]), 140, H.w - 140);

  H.geyser = {
    x: gx,
    rx: 70 + Math.random()*55,
    height: 320 + Math.random()*240,
    // 0.78‚Äì1.12 (used as a multiplier in the physics updraft)
    strength: 0.78 + Math.random()*0.34,
    drift: { amp: 26 + Math.random()*40, speed: 0.45 + Math.random()*0.85, phase: Math.random()*TAU },
    seed: (Math.random()*1e9)|0
  };
})(result);


      return result;
    }

    // ===== BOSS HOLES (Holes 9 & 18) =====
    const BOSS_TYPES = ['gauntlet','volcano','archipelago','fortress','switchback','storm','labyrinth','colosseum'];
    const BOSS_NAMES = {
      gauntlet:'The Gauntlet', volcano:'The Volcano', archipelago:'The Archipelago',
      fortress:'The Fortress', switchback:'The Switchback', storm:'The Storm',
      labyrinth:'The Labyrinth', colosseum:'The Colosseum'
    };

    function genBossHole(bossType){
      const w = WORLD.w, h = WORLD.h;
      const step = 40;
      const teeX = 120;
      const baseY0 = h * 0.72;
      const points = [];

      // flat baseline
      for(let x=0; x<=w; x+=step) points.push({x, y: baseY0});

      // gentle base undulation
      const freq1 = 1/(600 + Math.random()*300);
      const freq2 = 1/(250 + Math.random()*200);
      const amp1 = 30 + Math.random()*30;
      const amp2 = 10 + Math.random()*15;
      for(let i=0;i<points.length;i++){
        points[i].y -= Math.sin(points[i].x*freq1)*amp1 + Math.sin(points[i].x*freq2)*amp2;
      }

      let cupX, gWidth, par;
      const waters = [], sands = [], roughs = [];
      let geysers = []; // boss holes can have multiple geysers

      // ===== Boss-specific terrain sculpting =====

      if(bossType === 'gauntlet'){
        // Long narrow canyon with multiple geysers. Par 6.
        par = 6;
        cupX = clamp(teeX + lerp(2600, 3000, Math.random()), teeX+820, w-220);
        gWidth = 180 + Math.random()*80;

        // Raise canyon walls along the entire fairway
        const cStart = teeX + 200, cEnd = cupX - 160;
        const corridorW = 130 + Math.random()*60;
        const wallH = 90 + Math.random()*40;
        for(let i=0;i<points.length;i++){
          const px = points[i].x;
          if(px >= cStart && px <= cEnd){
            const along = (px-cStart)/(cEnd-cStart);
            const env = Math.sin(along*Math.PI);
            const center = lerp(teeX, cupX, along);
            const off = Math.abs(px - center);
            if(off > corridorW*0.5){
              points[i].y -= wallH * env * Math.min(1, (off-corridorW*0.5)/100);
            }
          }
        }
        // 3‚Äì4 geysers spaced through the canyon
        const gCount = 3 + Math.floor(Math.random()*2);
        for(let g=0;g<gCount;g++){
          const gx = lerp(cStart+100, cEnd-100, (g+0.5)/gCount + (Math.random()-0.5)*0.1);
          geysers.push({
            x:gx, rx:50+Math.random()*40, height:280+Math.random()*200,
            strength:0.85+Math.random()*0.3,
            drift:{amp:20+Math.random()*30, speed:0.5+Math.random()*0.8, phase:Math.random()*TAU},
            seed:(Math.random()*1e9)|0
          });
        }
      }
      else if(bossType === 'volcano'){
        // Massive crater with green inside. Strong central geyser. Par 5.
        par = 5;
        cupX = clamp(teeX + lerp(1800, 2400, Math.random()), teeX+820, w-220);
        gWidth = 160 + Math.random()*80;

        const craterCx = cupX;
        const craterR = 300 + Math.random()*100;
        const craterD = 130 + Math.random()*50;
        const rimH = 70 + Math.random()*30;

        for(let i=0;i<points.length;i++){
          const dx = points[i].x - craterCx;
          const dist = Math.abs(dx);
          if(dist < craterR){
            const t = dist / craterR;
            // Rim rises at edge, drops into crater
            const rim = rimH * Math.pow(t, 2) * Math.exp(-((t-0.85)*(t-0.85))*20);
            const bowl = craterD * (1 - t*t);
            points[i].y += bowl - rim;
          } else if(dist < craterR + 120){
            const t = (dist - craterR) / 120;
            points[i].y -= rimH * 0.5 * (1-t);
          }
        }
        // Water in crater floor (lava pool)
        const wX0 = craterCx - craterR*0.4, wX1 = craterCx + craterR*0.4;
        const wSurf = sampleY(points, craterCx) + 15;
        waters.push({x:wX0, w:wX1-wX0, y:wSurf, h:h-wSurf+60, seed:(Math.random()*1e9)|0});
        // Big central geyser
        geysers.push({
          x:craterCx, rx:90+Math.random()*40, height:400+Math.random()*200,
          strength:1.0+Math.random()*0.2,
          drift:{amp:30+Math.random()*30, speed:0.4+Math.random()*0.6, phase:Math.random()*TAU},
          seed:(Math.random()*1e9)|0
        });
      }
      else if(bossType === 'archipelago'){
        // Island-hopping: multiple small islands separated by water. Par 6.
        par = 6;
        cupX = clamp(teeX + lerp(2400, 3000, Math.random()), teeX+820, w-220);
        gWidth = 140 + Math.random()*60;

        // Create 4-5 islands with water channels between them
        const islandCount = 4 + Math.floor(Math.random()*2);
        const totalSpan = cupX - teeX - 200;
        const islandW = 140 + Math.random()*60;
        const channelDepth = 100 + Math.random()*40;

        for(let isle=0; isle<islandCount; isle++){
          const t = (isle + 0.5) / islandCount;
          const cx = teeX + 100 + t * totalSpan;
          const gapStart = cx + islandW*0.5;
          const gapEnd = (isle < islandCount-1) ? teeX + 100 + ((isle+1.5)/islandCount)*totalSpan - islandW*0.5 : w;

          // Depress channels between islands
          if(isle < islandCount-1){
            for(let i=0;i<points.length;i++){
              const px = points[i].x;
              if(px > gapStart && px < gapEnd){
                const mid = (gapStart+gapEnd)/2;
                const half = (gapEnd-gapStart)/2;
                const dt = (px-mid)/half;
                points[i].y += channelDepth * Math.cos(dt*Math.PI*0.5);
              }
            }
            // Water in each channel
            const wSurf = baseY0 + channelDepth*0.6;
            waters.push({x:gapStart, w:gapEnd-gapStart, y:wSurf, h:h-wSurf+60, seed:(Math.random()*1e9)|0});
          }
          // Slight island hump
          for(let i=0;i<points.length;i++){
            const dx = points[i].x - cx;
            if(Math.abs(dx) < islandW*0.6){
              const it = dx / (islandW*0.6);
              points[i].y -= 20 * Math.cos(it*Math.PI*0.5);
            }
          }
        }
      }
      else if(bossType === 'fortress'){
        // Plateau green with moat AND approach walls. Sand everywhere. Par 5.
        par = 5;
        cupX = clamp(teeX + lerp(1800, 2400, Math.random()), teeX+820, w-220);
        gWidth = 180 + Math.random()*80;

        // Raise the green plateau
        const platW = gWidth + 120;
        const platH = 80 + Math.random()*30;
        for(let i=0;i<points.length;i++){
          const dx = Math.abs(points[i].x - cupX);
          if(dx < platW*0.5) points[i].y -= platH;
          else if(dx < platW*0.5 + 50){
            const t = (dx - platW*0.5)/50;
            points[i].y -= platH * (1-t*t);
          }
        }
        // Moat around the plateau
        const moatInner = platW*0.5 + 30, moatOuter = moatInner + 100;
        const moatD = 70 + Math.random()*30;
        for(let i=0;i<points.length;i++){
          const dx = Math.abs(points[i].x - cupX);
          if(dx > moatInner && dx < moatOuter){
            const t = (dx-moatInner)/(moatOuter-moatInner);
            points[i].y += moatD * Math.sin(t*Math.PI);
          }
        }
        // Water in moat
        const lSurf = sampleY(points, cupX - (moatInner+moatOuter)*0.5) + 8;
        waters.push({x:cupX-moatOuter, w:moatOuter-moatInner, y:lSurf, h:h-lSurf+60, seed:(Math.random()*1e9)|0});
        const rSurf = sampleY(points, cupX + (moatInner+moatOuter)*0.5) + 8;
        waters.push({x:cupX+moatInner, w:moatOuter-moatInner, y:rSurf, h:h-rSurf+60, seed:(Math.random()*1e9)|0});
        // Approach walls
        const wallStart = cupX - moatOuter - 300, wallEnd = cupX - moatOuter - 60;
        for(let i=0;i<points.length;i++){
          const px = points[i].x;
          if(px >= wallStart && px <= wallEnd){
            const along = (px-wallStart)/(wallEnd-wallStart);
            const env = Math.sin(along*Math.PI);
            const center = (wallStart+wallEnd)/2;
            const off = Math.abs(px-center);
            if(off > 60) points[i].y -= 55 * env;
          }
        }
        // Sand bunkers guarding approach
        for(let s=0;s<3;s++){
          const sx = lerp(cupX-moatOuter-250, cupX-moatOuter-80, (s+0.5)/3);
          sands.push({x:sx, y:sampleY(points,sx)-4, r:35+Math.random()*20});
        }
      }
      else if(bossType === 'switchback'){
        // Dramatic zig-zag elevation: down, up, down. Max wind. Par 6.
        par = 6;
        cupX = clamp(teeX + lerp(2400, 3000, Math.random()), teeX+820, w-220);
        gWidth = 180 + Math.random()*80;

        const span = cupX - teeX;
        for(let i=0;i<points.length;i++){
          const px = points[i].x;
          const t = clamp((px - teeX) / span, 0, 1);
          // Three-phase zigzag
          let elev = 0;
          if(t < 0.33){
            const lt = t / 0.33;
            elev = 120 * lt*lt*(3-2*lt); // down
          } else if(t < 0.66){
            const lt = (t-0.33)/0.33;
            elev = 120 - 200 * lt*lt*(3-2*lt); // steep up
          } else {
            const lt = (t-0.66)/0.34;
            elev = -80 + 130 * lt*lt*(3-2*lt); // down to green
          }
          points[i].y += elev;
        }
        // Rough patches on the slopes
        for(let r=0;r<5;r++){
          const rx = lerp(teeX+200, cupX-200, Math.random());
          roughs.push({x:rx, y:sampleY(points,rx)-4, r:40+Math.random()*25});
        }
      }
      else if(bossType === 'storm'){
        // Tiny green, water and rough everywhere. Wind override in nextHole. Par 5.
        par = 5;
        cupX = clamp(teeX + lerp(1600, 2200, Math.random()), teeX+820, w-220);
        gWidth = 110 + Math.random()*40; // tiny green

        // Rough terrain with sharp features
        for(let f=0;f<5;f++){
          const cx = lerp(teeX+100, cupX+100, Math.random());
          const sigma = 80 + Math.random()*120;
          const amp = (Math.random()<0.5?-1:1) * (40 + Math.random()*60);
          for(let i=0;i<points.length;i++){
            const dx = points[i].x - cx;
            points[i].y += amp * Math.exp(-(dx*dx)/(2*sigma*sigma));
          }
        }
        // Multiple water hazards
        for(let wt=0;wt<3;wt++){
          const wx = lerp(teeX+200, cupX-100, (wt+0.5)/3);
          const ww = 120 + Math.random()*80;
          // Depress terrain for water basins
          for(let i=0;i<points.length;i++){
            const dx = points[i].x - wx;
            if(Math.abs(dx) < ww*0.6){
              const t = dx/(ww*0.6);
              points[i].y += 50 * Math.cos(t*Math.PI*0.5);
            }
          }
          const wSurf = sampleY(points, wx) + 10;
          waters.push({x:wx-ww*0.5, w:ww, y:wSurf, h:h-wSurf+60, seed:(Math.random()*1e9)|0});
        }
        // Rough everywhere
        for(let r=0;r<8;r++){
          const rx = lerp(teeX+150, cupX-80, Math.random());
          roughs.push({x:rx, y:sampleY(points,rx)-4, r:45+Math.random()*30});
        }
        // Sand bunkers around the tiny green
        for(let s=0;s<3;s++){
          const angle = (s/3)*Math.PI - Math.PI*0.3;
          const dist = gWidth*0.5 + 30 + Math.random()*20;
          sands.push({x:cupX+Math.cos(angle)*dist, y:sampleY(points,cupX)-4, r:30+Math.random()*15});
        }
      }
      else if(bossType === 'labyrinth'){
        // Dense obstacles with narrow channels. Multiple route options. Par 5.
        par = 5;
        cupX = clamp(teeX + lerp(1600, 2200, Math.random()), teeX+820, w-220);
        gWidth = 180 + Math.random()*80;

        // Create maze-like ridges
        const ridgeCount = 5 + Math.floor(Math.random()*3);
        for(let r=0;r<ridgeCount;r++){
          const rx = lerp(teeX+250, cupX-200, (r+0.5)/ridgeCount);
          const rw = 40 + Math.random()*30;
          const rh = 50 + Math.random()*40;
          // Each ridge has a gap (passage) at a random height
          const gapCenter = rx + (Math.random()-0.5)*rw*0.8;
          const gapW = 80 + Math.random()*60;
          for(let i=0;i<points.length;i++){
            const dx = points[i].x - rx;
            if(Math.abs(dx) < rw){
              const dgap = Math.abs(points[i].x - gapCenter);
              if(dgap > gapW*0.5){
                const t = dx/rw;
                points[i].y -= rh * Math.cos(t*Math.PI*0.5);
              }
            }
          }
        }
        // Sand traps in dead ends
        for(let s=0;s<4;s++){
          const sx = lerp(teeX+300, cupX-150, Math.random());
          sands.push({x:sx, y:sampleY(points,sx)-4, r:28+Math.random()*18});
        }
        // Rough patches
        for(let r=0;r<4;r++){
          const rx = lerp(teeX+200, cupX-100, Math.random());
          roughs.push({x:rx, y:sampleY(points,rx)-4, r:35+Math.random()*20});
        }
      }
      else if(bossType === 'colosseum'){
        // Massive bowl: tee on one rim, green on opposite rim, huge water valley between. Par 4.
        par = 4;
        cupX = clamp(teeX + lerp(2000, 2800, Math.random()), teeX+820, w-220);
        gWidth = 200 + Math.random()*80;

        const bowlCx = (teeX + cupX) * 0.5;
        const bowlR = (cupX - teeX) * 0.55;
        const bowlD = 160 + Math.random()*50;

        for(let i=0;i<points.length;i++){
          const dx = points[i].x - bowlCx;
          const dist = Math.abs(dx);
          if(dist < bowlR){
            const t = dist / bowlR;
            points[i].y += bowlD * (1 - t*t); // parabolic bowl
          }
        }
        // Raise the rims (tee side and green side)
        for(let i=0;i<points.length;i++){
          const px = points[i].x;
          // Tee rim
          if(px >= teeX-40 && px <= teeX+120){
            points[i].y -= 30;
          }
          // Green rim
          if(px >= cupX-gWidth*0.5-40 && px <= cupX+gWidth*0.5+40){
            points[i].y -= 40;
          }
        }
        // Huge water body in the bowl
        const wX0 = bowlCx - bowlR*0.7, wX1 = bowlCx + bowlR*0.7;
        const wSurf = sampleY(points, bowlCx) - 10;
        waters.push({x:wX0, w:wX1-wX0, y:wSurf, h:h-wSurf+60, seed:(Math.random()*1e9)|0});
      }

      // === Green placement (flatten area around cupX) ===
      const gx0 = cupX - gWidth/2, gx1 = cupX + gWidth/2;
      const greenBaseY = sampleY(points, cupX);
      for(let i=0;i<points.length;i++){
        if(points[i].x >= gx0 && points[i].x <= gx1){
          const t = (points[i].x - gx0) / gWidth;
          points[i].y = greenBaseY + (Math.random()-0.5)*3 + (t-0.5)*8;
        }
      }

      // === Tee placement ===
      const teeIdx = Math.floor(teeX/step);
      const teeY = points[teeIdx].y - 2;
      points[teeIdx].y = teeY;

      const result = {
        w, h, points, step, cupX,
        green:{x0:gx0, x1:gx1, y:0},
        waters, sands, roughs,
        tee:{x:teeX, y:teeY},
        par,
        layout: 'boss_' + bossType,
        boss: bossType
      };

      // Geysers: boss holes can have multiple, store as array
      if(geysers.length > 0){
        result.geyser = geysers[0]; // primary geyser for existing physics
        result.extraGeysers = geysers.slice(1); // additional geysers
      } else {
        result.geyser = null;
      }

      return result;
    }

    function sampleY(points, x){
      const step = points[1].x - points[0].x;
      const i = Math.min(Math.max(Math.floor(x/step),0), points.length-2);
      const p0 = points[i], p1 = points[i+1];
      const t = (x - p0.x)/(p1.x - p0.x);
      return lerp(p0.y, p1.y, t);
    }

    function groundYAt(x){ x = clamp(x, 0, hole.w); const i = Math.min(Math.floor(x/hole.step), hole.points.length-2); const p0 = hole.points[i], p1 = hole.points[i+1]; const t = (x - p0.x)/(p1.x - p0.x); return lerp(p0.y, p1.y, t); }

    function surfaceAt(x){ if(hole && hole.icePatches){for(const p of hole.icePatches){if(Math.abs(x-p.x)<p.r) return 'ice';}}
      if(x>=hole.green.x0 && x<=hole.green.x1) return 'green';
      const y = groundYAt(x);
      for(const s of hole.sands){ if(Math.hypot(x - s.x, y - s.y) <= s.r) return 'sand'; }
      for(const r of hole.roughs){ if(Math.hypot(x - r.x, y - r.y) <= r.r) return 'rough'; }
      return 'fairway';
    }

    function inWater(x,y){
      for(const w of hole.waters){
        if(x>=w.x && x<=w.x+w.w && y>=w.y) return true;
      }
      return false;
    }

    // ===== Balloons
    function buildBalloons(){
      hole.balloons = [];
      if(Math.random() < 0.55){
        const count = 1 + (Math.random()<0.5?0:1);
        for(let i=0;i<count;i++){
          const fromLeft = Math.random()<0.5;
          const x = fromLeft ? -120 - Math.random()*220 : hole.w + 120 + Math.random()*220;
          const dir = fromLeft ? 1 : -1;
          hole.balloons.push({
            x, dir,
            speed: 32 + Math.random()*38,
            baseH: 160 + Math.random()*240,
            r: 18 + Math.random()*6,
            hue: (Math.random()*360)|0,
            seed:(Math.random()*1e9)|0,
            popped:false
          });
        }
      }
    }
    function updateBalloons(dt){
      if(!hole?.balloons) return;
      for(let i=hole.balloons.length-1;i>=0;i--){
        const B = hole.balloons[i];
        B.x += B.dir * B.speed * dt;
        const cx = B.x;
        const cy = groundYAt(cx) - (B.baseH + Math.sin(clock*0.9 + (B.seed%1000))*12);
        if((B.dir>0 && cx > hole.w + 260) || (B.dir<0 && cx < -260)){ hole.balloons.splice(i,1); continue; }
        const dx = disc.x - cx, dy = disc.y - cy;
        if(Math.hypot(dx,dy) < (disc.r + B.r)){
          spawnParticles('spark', cx, cy, 18);
          grantBalloonReward();
          hole.balloons.splice(i,1);
        }
      }
    }
    function drawBalloons(){
      if(!hole?.balloons) return;
      ctx.save();
      for(const B of hole.balloons){
        const cx = B.x - view.x;
        if(cx < -60 || cx > canvas.width/DPR + 60) continue;
        const cyWorld = groundYAt(B.x) - (B.baseH + Math.sin(clock*0.9 + (B.seed%1000))*12);
        const cy = cyWorld - view.y;

        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy + B.r - 2);
        ctx.lineTo(cx, cy + B.r + 22);
        ctx.stroke();

        const col = `hsl(${B.hue},80%,66%)`;
        ctx.fillStyle = col;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath(); ctx.ellipse(cx, cy, B.r*0.9, B.r*1.1, 0, 0, TAU); ctx.fill(); ctx.stroke();

        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(cx - B.r*0.35, cy - B.r*0.25, B.r*0.22, B.r*0.18, 0, 0, TAU); ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(cx - 2, cy + B.r*0.8);
        ctx.lineTo(cx + 2, cy + B.r*0.8);
        ctx.lineTo(cx,     cy + B.r*0.95);
        ctx.closePath(); ctx.fill();
      }
      ctx.restore();
    }

    // ===== Round flow
    function newRound(){
      holeIndex=0;
      roundData={ holes:[], totalPar:0, totalStrokes:0 };
      resetPowerups();
      screenIntro.style.display='none';
      screenSummary.style.display='none';
      nextHole();
    }

    function nextHole(){
      const biome = pickWeighted(BIOMES, b => BIOME_WEIGHTS[b.name] ?? 1);
currentBiome = biome;

const variants = BIOME_VARIANTS[biome.name];
currentBiomeVariant = variants ? pickWeighted(variants, v => v.weight ?? 1) : null;

applyTheme(biome, currentBiomeVariant);
// IMPORTANT FIX: generate hole before selecting "auto" variants (auto uses hole.waters)
      // Boss holes on 9 and 18 (or every hole in boss mode)
      const isBossHole = bossMode || (holeIndex === 8 || holeIndex === 17);
      if(isBossHole){
        const bossType = BOSS_TYPES[Math.floor(Math.random()*BOSS_TYPES.length)];
        hole = genBossHole(bossType);
      } else {
        hole = genHole();
      }

      // Apply daytime for this hole now that hole exists
      applyDaytime(resolveVariantForHole());

      buildScenery();
      buildBalloons();

      backdrop.seed = (Math.random()*1e9)|0;
      buildBackdrop();

      roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par;
      elHole.textContent = (holeIndex+1); elPar.textContent = hole.par;

      windLift = windOn ? (Math.random()*2 - 1) : 0;
      windSide = windOn ? (Math.random()*2 - 1) : 0;

      // Storm boss: override wind to max intensity
      if(hole.boss === 'storm'){
        windLift = windOn ? (Math.random() < 0.5 ? -1 : 1) * (0.85 + Math.random()*0.15) : 0;
        windSide = windOn ? (Math.random() < 0.5 ? -1 : 1) * (0.85 + Math.random()*0.15) : 0;
      }
      // Switchback boss: strong headwind
      if(hole.boss === 'switchback'){
        windSide = windOn ? -(0.7 + Math.random()*0.3) : 0;
        windLift = windOn ? (Math.random()*2 - 1) * 0.6 : 0;
      }

      updateWindUI();
      updateDistanceUI();
      updateAimPrediction();

      disc.x = hole.tee.x; disc.y = hole.tee.y - disc.r - 1; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; disc.orient=0; disc.spin=0; disc.bank=0; strokes=0; elStrokes.textContent=strokes;
      centerCameraOnDisc();

      // Boss callout (dramatic)
      if(hole.boss && BOSS_NAMES[hole.boss]){
        addToast('BOSS HOLE');
        setTimeout(()=> addToast(BOSS_NAMES[hole.boss]), 600);
      }
      // Layout callout (normal holes)
      else {
        const LAYOUT_NAMES = { valley_carry:'Valley Carry', island_green:'Island Green', ridgeback:'Ridgeback', canyon:'Canyon Shot', plateau_green:'Plateau Green', downhill:'Downhill Run' };
        if(hole.layout && LAYOUT_NAMES[hole.layout]) addToast(LAYOUT_NAMES[hole.layout]);
      }

      // Fireflies depend on view + nighttime
      buildFireflies();
    }

    function endHole(){
      roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes;
      // Score callout
      if(strokes === 1){ addToast('Hole in One!'); }
      else {
        const delta = strokes - hole.par;
        const callout = delta <= -3 ? 'Albatross!' : delta === -2 ? 'Eagle!' : delta === -1 ? 'Birdie!' : delta === 0 ? 'Par' : delta === 1 ? 'Bogey' : delta === 2 ? 'Double Bogey' : delta === 3 ? 'Triple Bogey' : '+' + delta;
        addToast(callout);
      }
      // Award coins based on performance
      const earned = calcHoleCoins(hole.par, strokes);
      addCoins(earned);
      addToast('+' + earned + ' coins');
      holeIndex++;
      if(holeIndex>=HOLES_PER_ROUND){
        sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar; const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
        holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
        screenSummary.style.display='grid';
      } else { nextHole(); }
    }

    // ===== UI build: discs, release, hand (persisted)
    function buildDiscs(){
      clubSeg.innerHTML='';
      DISCS.forEach((d,idx)=>{
        if(!unlockedDiscs.has(d.id)) return;
        const b=document.createElement('button'); b.className='btn'; b.textContent=d.name; b.dataset.disc=idx;
        b.setAttribute('aria-pressed','false');
        b.addEventListener('click',()=>selectDisc(idx,true));
        clubSeg.appendChild(b);
      });
      const savedIdx = parseInt(localStorage.getItem('discIdx')||'0',10);
      const idx = (isFinite(savedIdx) && DISCS[savedIdx] && unlockedDiscs.has(DISCS[savedIdx].id)) ? savedIdx : DISCS.findIndex(d=>unlockedDiscs.has(d.id));
      selectDisc(idx, false);
    }
    let currentDisc = DISCS[0];
    function selectDisc(i, persist){ currentDisc = DISCS[i]; [...clubSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', parseInt(b.dataset.disc)===i? 'true':'false')); if(persist) localStorage.setItem('discIdx', String(i)); }
    spinSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; releaseMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); localStorage.setItem('releaseMode', String(releaseMode)); });
    handSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; hand = btn.dataset.hand; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); localStorage.setItem('hand', hand); });

    (function restoreControls(){
      const rm = parseInt(localStorage.getItem('releaseMode')||'0',10);
      if([-1,0,1].includes(rm)){ releaseMode = rm; [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', parseInt(b.dataset.spin,10)===rm?'true':'false')); }
      const h = localStorage.getItem('hand')||'RHBH';
      if(['RHBH','LHBH'].includes(h)){ hand = h; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b.dataset.hand===h?'true':'false')); }
    })();

    // ===== Wind UI
    function updateWindUI(){
      const wl = windOn ? windLift : 0;
      const ws = windOn ? windSide : 0;
      const mag = Math.hypot(wl, ws);
      elWindVal.textContent = mag.toFixed(1)+'x';
      // Arrow points in the wind direction (up = updraft, right = tailwind)
      const rot = Math.atan2(ws, wl) * (180 / Math.PI);
      elWindArrow.style.transform = `rotate(${rot}deg)`;
    }

    // ===== Input (Pointer Events + capture)
    function screenToWorld(x,y){ return { x: x/(DPR*zoomLevel) + view.x, y: y/(DPR*zoomLevel) + view.y }; }
    function onPointerDown(e){
      if(!hole || !disc.atRest) return;
      try{ canvas.setPointerCapture?.(e.pointerId); }catch{}
      const w=screenToWorld(e.clientX*DPR,e.clientY*DPR); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x)); aiming = true; meterOn = true; meter = 0; meterDir=1; elPowermeter.dataset.on='1'; e.preventDefault();
    }
    function onPointerMove(e){
      if(!aiming) return;
      const w=screenToWorld(e.clientX*DPR,e.clientY*DPR); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x));
    }
    function onPointerUp(e){
      if(!aiming) return;
      try{ canvas.releasePointerCapture?.(e.pointerId); }catch{}
      aiming=false; meterOn=false; elPowermeter.dataset.on='0'; throwDisc(); predPath=null; predLanding=null; if(elProjChip) elProjChip.style.display='none';
    }

    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    // ===== Throw
    function throwDisc(){
      if(!hole || !disc.atRest) return;
      const d = currentDisc;
      const surface = surfaceAt(disc.x); let powerMul = 1.0; if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
      if(surface === 'sand' && PU.sandPowerMin > powerMul) powerMul = PU.sandPowerMin;
      const base = 1650;
      const power = (0.25 + 0.75*meter) * d.speed * powerMul;

      // Release angle affects launch angle, speed, and spin
      // Hyzer (-1): steeper launch, more speed, more spin (stable fade)
      // Anhyzer (+1): flatter launch, less speed, less spin (more turn/flip)
      const hyz = releaseMode; // -1, 0, or 1
      const launchOffset = hyz * 0.055; // ~3.2¬∞ adjustment
      const speedMod = 1 + hyz * -0.05; // hyzer +5% speed, anhyzer -5%
      const spinMod  = 1 + hyz * -0.12; // hyzer +12% spin, anhyzer -12%

      const speed = base * power * speedMod;
      const dir = aimAngle + launchOffset;

      // Hand affects spin direction / curve sign, but also slight launch offset
      const handSign = (hand === 'RHBH' ? 1 : -1);

      disc.vx = Math.cos(dir) * speed;
      disc.vy = Math.sin(dir) * speed;

      disc.orient = dir + (NOSE_FAST_DEG * Math.PI/180);
      disc.spin0  = (14 + 20*power) * spinMod;
      disc.spin   = disc.spin0;
      disc.bank   = (hyz * 24) * Math.PI/180; // ¬±24¬∞ (was ¬±16¬∞)

      disc.atRest=false; disc.onGround=false; strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; if(navigator.vibrate) navigator.vibrate(16);
      Sfx.playThrow();
    }

    // ===== Physics update
    function update(dt){ updateRavens(dt);
      if(meterOn){ meter += meterDir * 1.6 * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width = (meter*100).toFixed(1)+'%'; }

      if(!hole){ return; }

      // toasts lifetime
      for(let i=toasts.length-1;i>=0;i--){ const T=toasts[i]; T.t+=dt; if(T.t>T.dur) toasts.splice(i,1); }

      // particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.vy += 1200*dt; p.vx*= (1-0.4*dt); p.vy*=(1-0.06*dt); p.x += p.vx*dt; p.y += p.vy*dt; }

      // balloons
      updateBalloons(dt);

      // fireflies
      updateFireflies(dt);

      if(!disc.atRest){
        if(!disc.onGround){
          const v = Math.hypot(disc.vx, disc.vy) || 0.0001;
          const vx = disc.vx, vy = disc.vy;
          const vAngle = Math.atan2(vy, vx);

          const tPow = clamp(v / 1600, 0, 1);
          const spinNorm = clamp(disc.spin / (disc.spin0 || 1), 0, 1);

          const aoaRaw = normalizeAngle(disc.orient - vAngle);
          const aoa = clamp(aoaRaw + 0.06, -0.6, 0.6);
          const dragMulEff = Math.max(0.85, PU.dragMul);
          const dragMag = 0.00050 * v * (1 + 0.7*Math.abs(aoa)) * dragMulEff;
          const dragX = -dragMag * vx;
          const dragY = -dragMag * vy;

          const windScaleEff = 0.50 * Math.max(0.65, PU.windScaleMul);
          const windMul = (windOn ? (1 + clamp(windLift, -1, 1) * windScaleEff) : 1);

          // Base aero lift ‚Äî anhyzer adds glide (stays aloft), hyzer reduces it (comes down)
          const glideMod = 1 + releaseMode * 0.14; // anhyzer +14% glide, hyzer -14%
          let lift = 0.00450 * currentDisc.glide * glideMod * v*v * aoa * windMul;

          // Wind Geyser: add pure vertical updraft
          if (hole?.geyser) {
  const G = hole.geyser;
  const gx = G.x;
  const baseY = groundYAt(gx);

  const dx = Math.abs(disc.x - gx);
  const xFall = Math.exp(-0.5 * (dx*dx) / (G.rx*G.rx));

  // Height fraction above ground: 0 near ground, 1 near the top of the column
  const h = clamp((baseY - disc.y) / G.height, 0, 1);

  // Strongest near the base, tapering with height
  const profile = xFall * (1 - h);

  if (profile > 0.001) {
    // Mild turbulence so it feels "alive", but keep it stable (no NaNs / no sign flips)
    const turb = 0.08 * Math.sin(clock*14 + (disc.x + disc.y)*0.02 + (G.seed & 1023));
    const column = clamp(1 + turb, 0.6, 1.4);

    // Updraft should be noticeable even at low disc speed
    const vScale = 0.70 + 0.30 * Math.min(1, v / 18);
    const aoaScale = 0.85 + 0.30 * Math.min(1, Math.abs(aoa) / 0.70);

    // px/s^2 (acts like negative gravity inside the column)
    const base = 1200 + 900 * G.strength;

    const updraft = base * profile * column * vScale * aoaScale;
    lift += updraft;
  }
}

          // Extra geysers (boss holes can have multiple)
          if(hole?.extraGeysers){
            for(const G of hole.extraGeysers){
              const gx = G.x;
              const baseY = groundYAt(gx);
              const dx = Math.abs(disc.x - gx);
              const xFall = Math.exp(-0.5*(dx*dx)/(G.rx*G.rx));
              const hh = clamp((baseY - disc.y)/G.height, 0, 1);
              const profile = xFall * (1 - hh);
              if(profile > 0.001){
                const turb = 0.08*Math.sin(clock*14 + (disc.x+disc.y)*0.02 + (G.seed&1023));
                const column = clamp(1+turb, 0.6, 1.4);
                const vScale = 0.70 + 0.30*Math.min(1, v/18);
                const aoaScale = 0.85 + 0.30*Math.min(1, Math.abs(aoa)/0.70);
                const base = 1200 + 900*G.strength;
                lift += base * profile * column * vScale * aoaScale;
              }
            }
          }


          const turnPhase = tPow*tPow;
          const fadePhase = (1 - tPow);
          const hyz = releaseMode;
          // Hyzer: suppresses turn, amplifies fade ‚Üí steeper descent, hooks hard at end
          // Anhyzer: amplifies turn, suppresses fade ‚Üí stays flatter, flips over
          let turnAmt = currentDisc.turn * turnPhase * (0.7 + 0.6*spinNorm) * (1 + 0.55*hyz);
          let fadeAmt = currentDisc.fade * fadePhase * (0.9 + 0.5*(1 - spinNorm)) * (1 - 0.45*hyz);
          const bankBias = 0.28 * Math.sin(disc.bank);
          const curve = (turnAmt - fadeAmt + bankBias);
          const curveMulEff = Math.max(0.90, PU.curveMul);
          const side = (hand==='RHBH'?1:-1);

          // Horizontal wind force (headwind/tailwind)
          const windSideForce = (windOn ? windSide * 280 * Math.max(0.65, PU.windScaleMul) : 0);

          // 1) Integrate forces without curve "push"
          const ax = dragX + windSideForce;
          const ay = GRAV + dragY - lift;
          disc.vx += ax*dt; disc.vy += ay*dt;

          // 2) Apply heading rotation to simulate turn/fade
          // Flip curve sign when flying leftward so the vertical effect is symmetric
          const dirSign = (disc.vx >= 0 ? 1 : -1);
          const curveRate = 54 * curveMulEff * curve * side * dirSign;
          const speedNow = Math.hypot(disc.vx, disc.vy);
          if (speedNow > 1e-3) {
            const dTheta = (curveRate / speedNow) * dt;
            if (dTheta) {
              const cosT = Math.cos(dTheta), sinT = Math.sin(dTheta);
              const vx0 = disc.vx, vy0 = disc.vy;
              disc.vx = vx0 * cosT - vy0 * sinT;
              disc.vy = vx0 * sinT + vy0 * cosT;
            }
          }

          // Spin decay and bank relax ‚Äî slower relaxation so release angle matters longer
          disc.spin *= Math.exp(-0.35 * PU.spinDecayMul * dt);
          const bankRelax = 0.12 + 0.55*(1 - spinNorm);
          disc.bank += (-disc.bank) * (1 - Math.exp(-dt*bankRelax));

          const noseBias = (lerp(NOSE_FAST_DEG, NOSE_SLOW_DEG, 1 - tPow)) * Math.PI/180;
          const targetOrient = vAngle + noseBias;
          disc.orient += (targetOrient - disc.orient) * (1 - Math.exp(-dt*3.4));

          // FIX: integrate position while airborne (was missing)
          disc.x += disc.vx * dt;
          disc.y += disc.vy * dt;

          const gy = groundYAt(disc.x);
          if(disc.y + disc.r >= gy){
            const surface = surfaceAt(disc.x);
            disc.y = gy - disc.r - 0.01;

            if(Math.abs(disc.vy) > 120){
              if(surface==='sand') spawnParticles('sand',  disc.x, disc.y+disc.r, 12);
              else                 spawnParticles('dust',  disc.x, disc.y+disc.r,  8);
            }

            const speed = Math.hypot(disc.vx, disc.vy);
            const entryAngle = Math.atan2(Math.abs(disc.vy), Math.abs(disc.vx));
            const shallow = entryAngle < (12 * Math.PI/180);
            const fast    = speed > 900;

            if(surface!=='sand' && surface!=='green' && shallow && fast){
              disc.vy = -Math.max(180, Math.abs(disc.vy)*0.55);
              disc.vx *= 0.88;
              disc.onGround = false;
            } else {
              const rest = SURF[surface]?.rest ?? 0.14;
              disc.vy = -disc.vy * rest;
              let fric = SURF[surface]?.fric ?? 740;
              if(surface==='sand') fric *= PU.sandFricMul;
              disc.vx *= 0.84;
              if(Math.abs(disc.vy) < 120) disc.vy = 0;
              disc.onGround = true;
            }
          }

          if(checkBasketCatch()){
            Sfx.playChain();
            const cupX = hole.cupX;
            const gY = groundYAt(cupX);
            spawnParticles('spark', cupX, gY - 35, 18);
            if(navigator.vibrate) navigator.vibrate([30,40,30]);
            disc.atRest=true; disc.vx=disc.vy=0;
            setTimeout(()=>{ endHole(); }, 520);
          }
        } else {
          const gy = groundYAt(disc.x);
          if(disc.y + disc.r < gy-0.5){
            disc.onGround=false;
          } else {
            disc.y = gy - disc.r;
            const surface = surfaceAt(disc.x);
            let fric = SURF[surface]?.fric ?? 740;
            if(surface==='sand') fric *= PU.sandFricMul;
            const speed = Math.abs(disc.vx);
            let dec = fric * 2.1;
            if(surface === 'sand')  dec = fric * 2.6;
            if(surface === 'green') dec = fric * 2.3;

            const s = Math.sign(disc.vx) || 0;
            let newSpeed = speed - dec*dt;
            if(newSpeed<0) newSpeed=0;
            disc.vx = s * newSpeed;
            disc.x += disc.vx*dt;
            if(Math.abs(disc.vx) < 8){ disc.vx=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; }
          }
        }
        if(inWater(disc.x, disc.y+disc.r*0.6)){
          spawnParticles('splash', disc.x, disc.y, 16);
          if(navigator.vibrate) navigator.vibrate([40,40,30]);
          strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes;
          disc.x = disc.lastSafe.x - 24; disc.y = groundYAt(disc.x)-disc.r; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true;
        }
        if(disc.x<0){ disc.x=0; disc.vx=0; } if(disc.x>hole.w){ disc.x=hole.w; disc.vx=0; }
      }
      centerCameraOnDisc();
    }

function simulateAimTrajectory(angle, power){
  // Mirror throwDisc() + update() airborne/ground physics for aim preview.
  const d = currentDisc;
  const surface = surfaceAt(disc.x);
  let powerMul = 1.0;
  if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
  if(surface === 'sand' && PU.sandPowerMin > powerMul) powerMul = PU.sandPowerMin;
  const throwPower = (0.25 + 0.75 * power) * d.speed * powerMul;

  // Mirror release angle modifiers from throwDisc
  const hyz = releaseMode;
  const launchOffset = hyz * 0.055;
  const speedMod = 1 + hyz * -0.05;
  const spinMod  = 1 + hyz * -0.12;
  const throwSpeed = 1650 * throwPower * speedMod;
  const dir = angle + launchOffset;

  const spin0 = (14 + 20 * throwPower) * spinMod;
  const s = {
    x: disc.x,
    y: disc.y,
    vx: Math.cos(dir) * throwSpeed,
    vy: Math.sin(dir) * throwSpeed,
    orient: dir + (NOSE_FAST_DEG * Math.PI / 180),
    spin: spin0,
    spin0: spin0,
    bank: (hyz * 24) * Math.PI / 180,
    onGround: false
  };

  const path = [];
  const dt = PRED_DT;
  const pathSteps = Math.floor(PRED_PATH_SEC / dt);
  const totalSteps = Math.floor(PRED_LAND_SEC / dt);

  for(let i=0;i<totalSteps;i++){
    if(i <= pathSteps && (i % 2 === 0)) path.push({x:s.x, y:s.y});

    if(!s.onGround){
      const v = Math.hypot(s.vx, s.vy) || 0.0001;
      const vAngle = Math.atan2(s.vy, s.vx);
      const tPow = clamp(v / 1600, 0, 1);
      const spinNorm = clamp(s.spin / (s.spin0 || 1), 0, 1);

      const aoaRaw = normalizeAngle(s.orient - vAngle);
      const aoa = clamp(aoaRaw + 0.06, -0.6, 0.6);
      const dragMulEff = Math.max(0.85, PU.dragMul);
      const dragMag = 0.00050 * v * (1 + 0.7 * Math.abs(aoa)) * dragMulEff;
      const dragX = -dragMag * s.vx;
      const dragY = -dragMag * s.vy;

      const windScaleEff = 0.50 * Math.max(0.65, PU.windScaleMul);
      const windMul = (windOn ? (1 + clamp(windLift, -1, 1) * windScaleEff) : 1);
      const glideMod = 1 + releaseMode * 0.14;
      const lift = 0.00450 * d.glide * glideMod * v * v * aoa * windMul;

      const windSideForce = (windOn ? windSide * 280 * Math.max(0.65, PU.windScaleMul) : 0);

      const turnPhase = tPow * tPow;
      const fadePhase = (1 - tPow);
      const hyzP = releaseMode;
      const turnAmt = d.turn * turnPhase * (0.7 + 0.6 * spinNorm) * (1 + 0.55 * hyzP);
      const fadeAmt = d.fade * fadePhase * (0.9 + 0.5 * (1 - spinNorm)) * (1 - 0.45 * hyzP);
      const bankBias = 0.28 * Math.sin(s.bank);
      const curve = (turnAmt - fadeAmt + bankBias);
      const curveMulEff = Math.max(0.90, PU.curveMul);
      const side = (hand === 'RHBH' ? 1 : -1);

      const ax = dragX + windSideForce;
      const ay = GRAV + dragY - lift;
      s.vx += ax * dt;
      s.vy += ay * dt;

      // Flip curve sign when flying leftward so the vertical effect is symmetric
      const dirSign = (s.vx >= 0 ? 1 : -1);
      const curveRate = 54 * curveMulEff * curve * side * dirSign;
      const speedNow = Math.hypot(s.vx, s.vy);
      if(speedNow > 1e-3){
        const dTheta = (curveRate / speedNow) * dt;
        if(dTheta){
          const cosT = Math.cos(dTheta), sinT = Math.sin(dTheta);
          const vx0 = s.vx, vy0 = s.vy;
          s.vx = vx0 * cosT - vy0 * sinT;
          s.vy = vx0 * sinT + vy0 * cosT;
        }
      }

      s.spin *= Math.exp(-0.35 * PU.spinDecayMul * dt);
      const bankRelax = 0.12 + 0.55 * (1 - spinNorm);
      s.bank += (-s.bank) * (1 - Math.exp(-dt * bankRelax));

      const noseBias = (lerp(NOSE_FAST_DEG, NOSE_SLOW_DEG, 1 - tPow)) * Math.PI / 180;
      const targetOrient = vAngle + noseBias;
      s.orient += (targetOrient - s.orient) * (1 - Math.exp(-dt * 3.4));

      s.x += s.vx * dt;
      s.y += s.vy * dt;

      const gy = groundYAt(clamp(s.x, 0, hole.w));
      if(s.y + disc.r >= gy){
        s.y = gy - disc.r - 0.01;
        const surf = surfaceAt(s.x);
        const entryAngle = Math.atan2(Math.abs(s.vy), Math.abs(s.vx));
        const shallow = entryAngle < (12 * Math.PI / 180);
        const fast = Math.hypot(s.vx, s.vy) > 900;

        if(surf !== 'sand' && surf !== 'green' && shallow && fast){
          s.vy = -Math.max(180, Math.abs(s.vy) * 0.55);
          s.vx *= 0.88;
        } else {
          const rest = SURF[surf]?.rest ?? 0.14;
          s.vy = -s.vy * rest;
          s.vx *= 0.84;
          if(Math.abs(s.vy) < 120) s.vy = 0;
          s.onGround = true;
        }
      }
    } else {
      const gy = groundYAt(clamp(s.x, 0, hole.w));
      if(s.y + disc.r < gy - 0.5){
        s.onGround = false;
      } else {
        s.y = gy - disc.r;
        const surf = surfaceAt(s.x);
        let fric = SURF[surf]?.fric ?? 740;
        if(surf === 'sand') fric *= PU.sandFricMul;
        let dec = fric * 2.1;
        if(surf === 'sand') dec = fric * 2.6;
        if(surf === 'green') dec = fric * 2.3;

        const sign = Math.sign(s.vx) || 0;
        let newSpeed = Math.abs(s.vx) - dec * dt;
        if(newSpeed < 0) newSpeed = 0;
        s.vx = sign * newSpeed;
        s.x += s.vx * dt;
        if(Math.abs(s.vx) < 8) break;
      }
    }

    s.x = clamp(s.x, 0, hole.w);
    if(inWater(s.x, s.y + disc.r * 0.6)) break;
  }

  const dx = hole.cupX - s.x;
  const dM = Math.abs(dx) / PX_PER_M;
  let deltaText;
  if(dM < 1.0) deltaText = 'pin-high';
  else deltaText = `${Math.round(dM)} m ${dx > 0 ? 'short' : 'long'}`;

  return { path, landing: {x:s.x, y:s.y}, deltaText };
}

function updateAimPrediction(force=false){
  if(!elProjChip || !elProjVal) return;

  if(!aiming || !meterOn || !hole){
    predPath = null;
    predLanding = null;
    elProjChip.style.display = 'none';
    return;
  }

  const now = performance.now();
  const power = clamp(meter, 0, 1);
  const angle = aimAngle;

  // Throttle + only recompute when inputs have moved meaningfully
  const shouldRecalc =
    force ||
    (now - predLastCalcMs) > 120 ||
    Math.abs(angle - predCache.angle) > 0.003 ||
    Math.abs(power - predCache.power) > 0.02 ||
    Math.abs(windLift - predCache.windLift) > 0.05 ||
    Math.abs(windSide - predCache.windSide) > 0.05 ||
    releaseMode !== predCache.releaseMode ||
    hand !== predCache.hand;

  if(!shouldRecalc) return;

  predLastCalcMs = now;
  predCache = { angle, power, windLift, windSide, releaseMode, hand };

  const res = simulateAimTrajectory(angle, power);
  predPath = res.path;
  predLanding = res.landing;
  predDeltaText = res.deltaText;

  elProjChip.style.display = 'flex';
  elProjVal.textContent = predDeltaText;
}

function drawPredictedArc(){
  if(!predPath || predPath.length < 2) return;

  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 10]);
  ctx.strokeStyle = 'rgba(255,255,255,0.75)';

  ctx.beginPath();
  for(let i=0;i<predPath.length;i++){
    const p = predPath[i];
    const sx = p.x - view.x;
    const sy = p.y - view.y;
    if(i===0) ctx.moveTo(sx, sy);
    else ctx.lineTo(sx, sy);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  if(predLanding){
    const sx = predLanding.x - view.x;
    const sy = predLanding.y - view.y;
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.arc(sx, sy, 7, 0, Math.PI*2);
    ctx.stroke();
  }

  ctx.restore();
}


    function centerCameraOnDisc(){
      if(!hole){ return; }
      view.x = clamp(disc.x - view.w*0.45, 0, WORLD.w - view.w);
      view.y = clamp(groundYAt(disc.x) - view.h*0.65, 0, WORLD.h - view.h);
    }

    // ===== Scenery
    function buildScenery(){
      scenery.trees = [];
      scenery.rocks = [];
      scenery.fences = [];
scenery.snowbanks = [];
      scenery.icePatches = [];
      scenery.landmark = null;
const rng = (i)=>rand01(backdrop.seed, 2000+i);

const treeStyleBase = (currentBiomeVariant && currentBiomeVariant.treeStyle) ? currentBiomeVariant.treeStyle : 'pine';
const extras = (currentBiomeVariant && currentBiomeVariant.extras) ? currentBiomeVariant.extras : null;

// Snowbanks: purely visual mounds near the ground (snow variant)
if(extras && extras.snowbanks){
  const banks = 3 + Math.floor(rng(810)*5);
  for(let i=0;i<banks;i++){
    const x = 120 + rng(820+i)*(WORLD.w - 240);
    const y = groundYAt(x) + 3;
    const w = 120 + rng(830+i)*240;
    const h = 14 + rng(840+i)*24;
    const a = 0.22 + rng(850+i)*0.25;
    scenery.snowbanks.push({ x, y, w, h, a });
  }
}
      const countTrees = 24 + Math.floor(rng(1)*18);
      const avoid = [
        [hole.green.x0-80, hole.green.x1+80],
      ];
      for(const w of hole.waters){ avoid.push([w.x-60, w.x+w.w+60]); }
      function allowedX(x){
        for(const r of avoid){ if(x>=r[0] && x<=r[1]) return false; }
        return x>40 && x < hole.w-40;
      }
      // Trees
      for(let i=0;i<countTrees;i++){
        let x = 80 + rng(10+i)*(WORLD.w-160);
        let tries=0; while(!allowedX(x) && tries++<10){ x = 80 + rng(100+i*7)*(WORLD.w-160); }
        const y = groundYAt(x);
        let type = treeStyleBase;
if(extras && extras.mixCacti && rng(950+i) < 0.35) type = 'cactus';

let h = 56 + rng(200+i)*96;
let baseW = 14 + rng(300+i)*18;
let levels = 4 + Math.floor(rng(500+i)*2);

// Slight silhouette adjustments per tree style (purely visual)
if(type==='cactus'){ h *= 1.15; baseW *= 0.55; levels = 3; }
else if(type==='palm'){ h *= 1.15; baseW *= 0.55; levels = 3; }
else if(type==='juniper'){ h *= 0.90; baseW *= 1.15; levels = Math.max(3, levels); }
else if(type==='dead'){ h *= 1.05; baseW *= 0.70; levels = 3; }
else if(type==='snowpine'){ /* keep default */ }

scenery.trees.push({ x, y, h, w: baseW, levels, sway:rng(400+i)*TAU, type, snow:(type==='snowpine') });
      }
      // Rocks
      const rockN = 6 + Math.floor(Math.random()*6);
      for(let i=0;i<rockN;i++){
        const x = 80 + Math.random()*(WORLD.w-160);
        const y = groundYAt(x);
        const r = 3 + Math.random()*5;
        const seed = (Math.random()*1e9)|0;
        scenery.rocks.push({ x, y, r, seed, skew: (Math.random()*0.6-0.3) });
      }

      // Fences ‚Äî deterministic
      function addFence(x0, x1){
        if(x1 < x0){ const t=x0; x0=x1; x1=t; }
        x0 = clamp(x0, 40, hole.w-40);
        x1 = clamp(x1, 40, hole.w-40);
        if(x0 < hole.green.x1 && x1 > hole.green.x0){
          if(Math.abs(x0 - hole.green.x0) < Math.abs(x1 - hole.green.x1)) x0 = hole.green.x1 + 16;
          else x1 = hole.green.x0 - 16;
        }
        if(x1 - x0 < 80) return;

        const F = {
          x0, x1,
          step: 28 + Math.random()*10,
          height: 16 + Math.random()*8,
          rails: (Math.random()<0.35?3:2),
          seed: (Math.random()*1e9)|0,
          posts: []
        };

        let idx = 0;
        for(let x = x0; x <= x1; x += F.step){
          const tilt  = (rand01(F.seed, idx*2+1) - 0.5) * 0.12;
          const hMul  = 0.88 + rand01(F.seed, idx*2+2) * 0.25;
          F.posts.push({ x, tilt, hMul });
          idx++;
        }

        scenery.fences.push(F);
      }

      const baseX = hole.tee.x + 140;
      if(baseX < hole.cupX - 120) addFence(baseX, baseX + 260 + Math.random()*200);
      if(Math.random() < 0.65){
        const mid = lerp(hole.tee.x+320, hole.cupX-200, Math.random());
        addFence(mid - (120+Math.random()*120), mid + (120+Math.random()*120));
      }
      if(Math.random() < 0.45){
        addFence(hole.cupX - (260+Math.random()*120), hole.cupX - 80);
      }

      // Ice patches only in snow biome (disc can still fly through snowbanks; ice affects ground slide)
      if(currentBiomeVariant && currentBiomeVariant.id === 'snow'){
        const count = 1 + Math.floor(Math.random()*3);
        for(let i=0;i<count;i++){
          const x = lerp(hole.tee.x+180, hole.cupX-180, Math.random());
          const r = 18 + Math.random()*38;
          scenery.icePatches.push({ x, r });
        }
      }

      // Foreground landmark (purely decorative) ‚Äî ~35% chance per hole
      if(Math.random() < 0.35){
        const biomeId = currentBiomeVariant ? currentBiomeVariant.id : 'forest';
        let choices;
        if(biomeId === 'snow') choices = ['ice_cave', 'bridge', 'cabin', 'stone_wall', 'campfire'];
        else if(biomeId === 'desert' || biomeId === 'cactus') choices = ['abandoned_bus', 'bridge', 'water_well', 'tent_camp', 'stone_wall'];
        else if(biomeId === 'oasis') choices = ['bridge', 'tent_camp', 'water_well', 'abandoned_bus'];
        else if(biomeId === 'prairie' || biomeId === 'juniper') choices = ['barn', 'windmill_cluster', 'hay_bales', 'shed', 'fence_gate'];
        else if(biomeId === 'deadwood') choices = ['abandoned_bus', 'stone_wall', 'campfire', 'shed'];
        else choices = ['barn', 'bridge', 'abandoned_bus', 'windmill_cluster', 'cabin', 'hay_bales', 'shed', 'fence_gate', 'campfire', 'tent_camp'];
        const type = choices[Math.floor(Math.random()*choices.length)];
        const x = lerp(hole.tee.x+220, hole.cupX-220, Math.random());
        scenery.landmark = { type, x, y: groundYAt(x), s: 1.0, seed: (Math.random()*1e9)|0 };
      }

      // Expose per-hole arrays for helpers
      hole.icePatches = scenery.icePatches;
      hole.landmark  = scenery.landmark;

    }

// ===== Rendering
    function draw(){
      ctx.setTransform(DPR*zoomLevel,0,0,DPR*zoomLevel,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);

      drawSkyGradient();

      // Night layer (stars/moon) on top of sky
      drawStars();
      drawMoon();
      drawRavens();

      drawSun();
      drawClouds();
      drawMountains();

      drawDistanceHaze();

      if(!hole){ drawVignette(); drawToasts(); return; }

      drawWindmills();
      drawBgStructures();
      drawWaterBodies();

      // Ground fill (extend to bottom of visible area so zoom-out has no gap)
      ctx.fillStyle = cached.colors.fg;
      const groundBottom = Math.max(hole.h - view.y + 100, view.h + 10);
      ctx.beginPath(); ctx.moveTo(hole.points[0].x - view.x, groundBottom);
      for(const p of hole.points){ ctx.lineTo(p.x - view.x, p.y - view.y); }
      ctx.lineTo(hole.points[hole.points.length-1].x - view.x, groundBottom); ctx.closePath(); ctx.fill();

      drawIcePatches();
      drawGrass();
      drawGroundFog();
      drawGeyser();

      for(const s of hole.sands){ drawBunkerHole(s); }

      drawScenery();
      drawLandmark();
      drawFireflies();
      drawBalloons();
      drawBasket();

      for(const p of particles){
        let c = '#ffffff';
        if(p.type==='spark') c = cached.colors.accent;
        else if(p.type==='sand') c = '#b48a5a';
        else if(p.type==='dust') c = '#9aa2aa';
        else if(p.type==='splash') c = cached.colors.accent2;
        ctx.globalAlpha = Math.max(0, p.life/0.6);
        ctx.fillStyle=c; ctx.beginPath(); ctx.arc(p.x - view.x, p.y - view.y, 2.2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
      }

      if(aiming && meterOn) drawPredictedArc();
      drawDisc();
      if(aiming){ drawAimArrow(); }

      drawVignette();
      drawToasts();
      updateDistanceUI();
    }

    function drawSkyGradient(){
      if(!cached.skyGradient) rebuildSkyGradient();
      ctx.fillStyle = cached.skyGradient;
      ctx.fillRect(0,0,view.w,view.h);
    }

    function drawStars(){
      const night = clamp(atmo.night, 0, 1);
      if(night <= 0.05 || !backdrop.stars.length) return;

      const w = canvas.width / DPR, h = canvas.height / DPR;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.9 * night;

      // Subtle deepening overlay
      ctx.fillStyle = `rgba(0,0,0,${0.18 * night})`;
      ctx.fillRect(0,0,w,h);

      for(const S of backdrop.stars){
        const x = w * S.u;
        const y = h * S.v;
        const tw = 0.65 + 0.35*Math.sin(clock*(0.6+S.tw*0.25) + S.ph);
        const a = (0.10 + 0.35*tw) * night;
        ctx.globalAlpha = a;
        ctx.fillStyle = '#e8f1ff';
        ctx.beginPath(); ctx.arc(x, y, S.r*tw, 0, TAU); ctx.fill();
      }

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    }

    function drawMoon(){
      const night = clamp(atmo.night, 0, 1);
      if(night <= 0.10 || !backdrop.moon) return;

      const m = backdrop.moon;
      const w = canvas.width / DPR, h = canvas.height / DPR;
      const parX = 0.05, parY = 0.02;
      const drift = Math.sin(clock*0.03 + m.u*TAU) * 8;

      const xw = WORLD.w * m.u, yw = WORLD.h * m.v;
      const x = (xw - view.x*parX) + drift;
      const y = (yw - view.y*parY);
      const r = m.r * (0.95 + 0.10*Math.sin(clock*0.02));

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      // halo
      const halo = ctx.createRadialGradient(x, y, r*0.9, x, y, r*4.2);
      halo.addColorStop(0, `rgba(210,230,255,${0.10*night})`);
      halo.addColorStop(1, 'rgba(210,230,255,0)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, r*4.2, 0, TAU); ctx.fill();

      // moon body
      ctx.globalAlpha = 0.85 * night;
      ctx.fillStyle = '#e7eefc';
      ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();

      // subtle shading to hint at phase (wax 0..1)
      const phase = (m.wax*2 - 1); // -1..1
      ctx.globalCompositeOperation = 'source-atop';
      ctx.globalAlpha = 0.22 * night;
      ctx.fillStyle = '#0b1020';
      ctx.beginPath();
      ctx.ellipse(x + phase*r*0.28, y, r*0.95, r*1.02, 0, 0, TAU);
      ctx.fill();

      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawSun(){
      const m = backdrop.sun; if(!m) return;
      if(!atmo.sun.visible){ return; }

      const parX = 0.05, parY = 0.02;
      const drift = Math.sin(clock*0.05 + m.phase) * 12;
      const xw = WORLD.w * m.u, yw = WORLD.h * m.v;
      const x = (xw - view.x*parX) + drift;
      const y = (yw - view.y*parY);
      const r = m.baseR * (atmo.sun.radiusMul || 1.0);

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const halo = ctx.createRadialGradient(x, y, r*0.8, x, y, r*4.0);
      const haloAlpha = 0.22 * (atmo.sun.halo || 1.0);
      halo.addColorStop(0, `rgba(255,210,130,${haloAlpha})`);
      halo.addColorStop(1, 'rgba(255,210,130,0.00)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, r*4.0, 0, TAU); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.globalAlpha = (atmo.sun.intensity || 1.0);
      ctx.fillStyle = '#fff2cf';
      ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = 'rgba(0,0,0,0.10)'; ctx.lineWidth = 1; ctx.stroke();
      ctx.restore();
    }

    function drawClouds(){
      const w = canvas.width / DPR;
      const span = WORLD.w;
      const q = qualityScale();
      const alphaMul = (q < 0.9 ? 0.85 : 1.0) * (atmo.cloudAlpha || 1.0);
      backdrop.clouds.forEach(C=>{
        const baseX = WORLD.w * C.u - clock * C.speed;
        const y = WORLD.h * C.v - view.y * C.parY;
        for(let k=-1; k<=1; k++){
          const x = baseX + k*span - view.x * C.parX;
          if(x < -260 || x > w + 260) continue;
          ctx.save();
          ctx.globalAlpha = alphaMul;
          ctx.drawImage(C.sprite, x - C.spriteW/2, y - C.spriteH/2);
          ctx.restore();
        }
      });
    }

    function drawMountains(){
      const layers = backdrop.mountains.length;
      for(let idx=0; idx<layers; idx++){
        const L = backdrop.mountains[idx];
        const img = backdrop.mountainsImg[idx];
        if(!img) continue;
        const parX = L.parallax;
        const parY = 0.06 * idx;
        const sx = -view.x * parX;
        const sy = -view.y * parY;

        const t = (layers<=1) ? 0 : (idx / (layers-1));
        const alpha = (atmo.mtnAlphaNear || 1.0) + ((atmo.mtnAlphaFar || 1.0) - (atmo.mtnAlphaNear || 1.0)) * t;

        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.drawImage(img, sx, sy);
        ctx.restore();
      }
    }

    function drawDistanceHaze(){
      if(atmo.haze <= 0) return;
      const w = canvas.width / DPR, h = canvas.height / DPR;

      ctx.save();
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0.00, `rgba(255,255,255,${0.35*atmo.haze})`);
      g.addColorStop(0.45, `rgba(255,255,255,${0.28*atmo.haze})`);
      g.addColorStop(0.80, `rgba(255,255,255,${0.08*atmo.haze})`);
      g.addColorStop(1.00, 'rgba(255,255,255,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();
    }

    function drawGroundFog(){
      if(atmo.groundFog <= 0) return;

      const w = canvas.width / DPR;
      const cxw = view.x + view.w*0.5;
      const gyLocal = groundYAt(clamp(cxw, 0, WORLD.w));
      const y = gyLocal - view.y;

      const height = Math.min(220, Math.max(140, (canvas.height/DPR)*0.35));
      const drift = Math.sin(clock * (atmo.fogDrift.speed || 0.012)) * (atmo.fogDrift.amp || 24);

      ctx.save();
      const blur = reducedMotion ? 0 : 2.2;
      ctx.filter = `blur(${blur}px)`;
      ctx.globalAlpha = 0.75 * atmo.groundFog;
      ctx.beginPath();
      const steps = 20;
      ctx.moveTo(-20, y);
      for(let i=0; i<=steps; i++){
        const t = i/steps;
        const xx = t*w;
        const wave = Math.sin(t*6 + clock*0.8) * 6 + Math.sin(t*3.2 + clock*0.6 + 1.3)*4;
        ctx.lineTo(xx, y - 18 + wave + drift*0.05);
      }
      ctx.lineTo(w+20, y + height);
      ctx.lineTo(-20, y + height);
      ctx.closePath();
      ctx.fillStyle = 'rgba(255,255,255,0.30)';
      ctx.fill();
      ctx.filter = 'none';
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // ===== Water rendering
    function drawWaterBodies(){
      if(!hole || !hole.waters?.length) return;
      for(const W of hole.waters){ drawWater(W); }
    }
    function drawWater(W){
      const baseCol = cached.colors.water;

      const left = W.x - view.x;
      const top  = W.y - view.y;
      const width = W.w;
      const height = hole.h - W.y + 80;

      ctx.save();
      ctx.beginPath();
      ctx.rect(left, top, width, height);
      ctx.clip();

      ctx.fillStyle = baseCol;
      ctx.fillRect(left, top, width, height);

      const g = ctx.createLinearGradient(0, top, 0, top + height);
      g.addColorStop(0.00, 'rgba(0,0,0,0.10)');
      g.addColorStop(0.65, 'rgba(0,0,0,0.18)');
      g.addColorStop(1.00, 'rgba(0,0,0,0.28)');
      ctx.fillStyle = g;
      ctx.fillRect(left, top, width, height);

      const q = qualityScale();
      const rippleA = { freq: 0.035, amp: 1.3, speed: 1.6 };
      const rippleB = { freq: 0.070, amp: 0.9,  speed: -1.2 };
      const step = (q < 0.9 ? 18 : 14);
      ctx.lineWidth = 1;

      ctx.strokeStyle = `rgba(255,255,255,${0.09 * (atmo.waterShine||1.0)})`;
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin((x * rippleA.freq) + clock * rippleA.speed * 2.0) * rippleA.amp +
          Math.sin((x * rippleB.freq) + clock * rippleB.speed * 2.0) * rippleB.amp;
        const y = top + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      ctx.strokeStyle = `rgba(0,0,0,${0.10 * (atmo.waterShine ? (1.4 - atmo.waterShine*0.7) : 1.0)})`;
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin((x * rippleA.freq) + clock * rippleA.speed * 2.0 + 1.2) * (rippleA.amp*0.9) +
          Math.sin((x * rippleB.freq) + clock * rippleB.speed * 2.0 + 0.7) * (rippleB.amp*0.9);
        const y = top + 2 + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      const rr = (i)=> (hash32((W.seed ^ (i*2654435761))>>>0) >>> 0) / 4294967295;
      const streaks = (q < 0.9 ? 3 : 4) + Math.floor(rr(1) * (q < 0.9 ? 3 : 4));
      for(let i=0;i<streaks;i++){
        const yRand = rr(10+i);
        const y = top + 6 + yRand * Math.min(38, height - 10);
        const drift = ((clock * 18) + rr(100+i)*2000) % (width + 160);
        const x0 = left + drift - 160;
        const x1 = Math.min(left + width, x0 + (60 + rr(200+i)*120));

        ctx.globalAlpha = (0.07 + rr(300+i)*0.05) * (atmo.waterShine || 1.0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x0, y, x1 - x0, 1);
        ctx.globalAlpha = 1;
      }

      drawFoamBand(left, top, width, W.seed);

      // Mist above water
      if(atmo.mistOverWater > 0){
        const fog = Math.min(1, atmo.mistOverWater);
        const cap = Math.min(46, height*0.28);
        const baseY = top - 2;
        const N = 6;

        ctx.save();
        ctx.filter = reducedMotion ? 'none' : 'blur(1.8px)';
        for(let i=0;i<N;i++){
          const t = i/(N-1);
          const yy = baseY + t * cap;
          const a  = (0.26 - 0.04*t) * fog * (reducedMotion ? 0.8 : 1.0);
          ctx.globalAlpha = Math.max(0, a);
          ctx.fillStyle = '#ffffff';
          const scallop = 6 + 3*Math.sin(clock*0.7 + t*4.0 + (W.seed%100)/20);
          ctx.beginPath();
          ctx.moveTo(left, yy);
          for(let x=0; x<=width; x+=18){
            const y2 = yy + Math.sin((x*0.03) + clock*0.8 + t*2.2)*scallop;
            ctx.lineTo(left + x, y2);
          }
          ctx.lineTo(left + width, yy + 24);
          ctx.lineTo(left, yy + 24);
          ctx.closePath();
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.filter = 'none';
        ctx.restore();
      }

      ctx.restore();
    }
    function drawFoamBand(left, top, width, seed){
      const f1 = 0.045, a1 = 1.4;
      const f2 = 0.090, a2 = 0.8;
      const phase = (hash32(seed ^ 0xBEEF) % 628) / 100;
      const step = 10;

      const haloGrad = ctx.createLinearGradient(0, top, 0, top + 6);
      haloGrad.addColorStop(0, 'rgba(255,255,255,0.10)');
      haloGrad.addColorStop(1, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = haloGrad;
      ctx.fillRect(left, top, width, 6);

      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin(x*f1 + clock*2.0 + phase) * a1 +
          Math.sin(x*f2 - clock*1.6 + phase*1.7) * a2;
        const y = top + 1 + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      for(let x=4; x<width; x+=22){
        const y = top + 2 + Math.sin(x*0.07 + phase)*0.8;
        ctx.fillRect(left + x, y, 1, 1);
      }
    }

    // ===== Background windmills & mountains
    function drawWindmills(){
      if(!backdrop.windmills?.length || !backdrop.mountains?.length) return;

      const L = backdrop.mountains[backdrop.mountains.length - 1];
      const idx = backdrop.mountains.length - 1;
      const parX = L.parallax;
      const parY = 0.06 * idx;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.88)';
      ctx.strokeStyle = 'rgba(0,0,0,0.88)';
      ctx.lineWidth = 1;

      const w = canvas.width / DPR;

      for(const W of backdrop.windmills){
        const sx = W.x - view.x * parX;
        if(sx < -200 || sx > w + 200) continue;

        let baseY = mountainYAt(L, W.x) - view.y * parY;
        baseY += 2;

        const towerTopY = baseY - W.h;
        const cx = sx, cy = towerTopY - 10;

        ctx.beginPath();
        const tw = Math.max(16, W.h * 0.14);
        const bw = tw * 1.25;
        ctx.moveTo(sx - bw/2, baseY);
        ctx.lineTo(sx + bw/2, baseY);
        ctx.lineTo(sx + tw/2, towerTopY);
        ctx.lineTo(sx - tw/2, towerTopY);
        ctx.closePath(); ctx.fill();

        ctx.beginPath();
        ctx.moveTo(sx - bw/2, baseY);
        ctx.lineTo(sx - bw/2 - 10, baseY + 6);
        ctx.moveTo(sx + bw/2, baseY);
        ctx.lineTo(sx + bw/2 + 10, baseY + 6);
        ctx.stroke();

        const railW = Math.max(40, tw*2.2);
        const railH = 10;
        const railY = towerTopY + 4;
        ctx.fillRect(sx - railW/2, railY, railW, 6);
        ctx.save(); ctx.globalAlpha = 0.95;
        ctx.strokeStyle = 'rgba(0,0,0,0.88)';
        ctx.lineWidth = 1;
        ctx.strokeRect(sx - railW/2, railY - railH, railW, railH);
        const vBars = 6;
        for(let i=1;i<vBars;i++){
          const x = sx - railW/2 + (railW/vBars)*i;
          ctx.beginPath(); ctx.moveTo(x, railY - railH); ctx.lineTo(x, railY); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(sx - railW/2, railY - railH/2); ctx.lineTo(sx + railW/2, railY - railH/2); ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(W.tilt);
        ctx.fillRect(-8, -6, 16, 6);
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, TAU); ctx.fill();

        const windFactor = 1 + (windOn ? Math.abs(windLift)*1.2 : 0);
        const theta = W.spin0 + clock * W.speed * windFactor;

        drawBlade(theta,         W.r);
        drawBlade(theta+TAU/4,   W.r);
        drawBlade(theta+TAU/2,   W.r);
        drawBlade(theta+3*TAU/4, W.r);

        ctx.restore();
      }

      ctx.restore();

      function drawBlade(angle, R){
        ctx.save();
        ctx.rotate(angle);

        const bw = Math.max(6, R*0.16);
        const bl = R;
        const root = 4;

        ctx.beginPath();
        ctx.rect(root, -bw/2, bl-root, bw);
        ctx.fill();

        ctx.save();
        ctx.globalAlpha = 0.45;
        const segs = 5;
        for(let i=1;i<segs;i++){
          const x = root + (bl-root)*(i/segs);
          ctx.beginPath(); ctx.moveTo(x, -bw/2); ctx.lineTo(x, bw/2); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(root, 0); ctx.lineTo(bl, 0); ctx.stroke();
        ctx.restore();

        ctx.restore();
      }
    }

    function drawBgStructures(){
      if(!backdrop.bgStructures?.length || !backdrop.mountains?.length) return;
      const L = backdrop.mountains[backdrop.mountains.length - 1];
      const idx = backdrop.mountains.length - 1;
      const parX = L.parallax;
      const parY = 0.06 * idx;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.80)';
      ctx.strokeStyle = 'rgba(0,0,0,0.80)';
      ctx.lineWidth = 1.5;

      for(const B of backdrop.bgStructures){
        const sx = B.x - view.x * parX;
        if(sx < -200 || sx > view.w + 200) continue;
        let baseY = mountainYAt(L, B.x) - view.y * parY + 2;
        const S = B.scale;

        if(B.type === 'silo'){
          // Cylindrical silo with domed top
          const w = 28*S, h = 70*S;
          ctx.beginPath();
          ctx.rect(sx - w/2, baseY - h, w, h);
          ctx.fill();
          // dome
          ctx.beginPath();
          ctx.ellipse(sx, baseY - h, w/2, 12*S, 0, Math.PI, 0);
          ctx.fill();
          // horizontal bands
          ctx.save(); ctx.globalAlpha = 0.35;
          for(let j=1;j<4;j++){
            const y = baseY - h*j/4;
            ctx.beginPath(); ctx.moveTo(sx-w/2, y); ctx.lineTo(sx+w/2, y); ctx.stroke();
          }
          ctx.restore();
        }
        else if(B.type === 'water_tower'){
          // Stilted tank
          const tw = 34*S, th = 22*S, legH = 60*S;
          const topY = baseY - legH - th;
          // legs
          ctx.beginPath();
          ctx.moveTo(sx-tw*0.4, baseY); ctx.lineTo(sx-tw*0.25, topY+th);
          ctx.moveTo(sx+tw*0.4, baseY); ctx.lineTo(sx+tw*0.25, topY+th);
          ctx.moveTo(sx, baseY); ctx.lineTo(sx, topY+th);
          ctx.stroke();
          // cross brace
          ctx.beginPath();
          ctx.moveTo(sx-tw*0.35, baseY-legH*0.5); ctx.lineTo(sx+tw*0.35, baseY-legH*0.5);
          ctx.stroke();
          // tank body
          ctx.beginPath();
          ctx.ellipse(sx, topY + th*0.5, tw/2, th/2, 0, 0, TAU);
          ctx.fill();
          // cap
          ctx.beginPath();
          ctx.ellipse(sx, topY, tw*0.3, 6*S, 0, Math.PI, 0);
          ctx.fill();
        }
        else if(B.type === 'radio_tower'){
          // Tall lattice tower with blinking light
          const h = 100*S;
          const bw = 18*S;
          // main legs (tapered)
          ctx.beginPath();
          ctx.moveTo(sx-bw/2, baseY); ctx.lineTo(sx-3*S, baseY-h);
          ctx.moveTo(sx+bw/2, baseY); ctx.lineTo(sx+3*S, baseY-h);
          ctx.stroke();
          // cross braces
          const braces = 5;
          for(let j=1;j<=braces;j++){
            const t = j/(braces+1);
            const y = baseY - h*t;
            const w = lerp(bw/2, 3*S, t);
            ctx.beginPath(); ctx.moveTo(sx-w, y); ctx.lineTo(sx+w, y); ctx.stroke();
            // X brace
            if(j < braces){
              const y2 = baseY - h*(j+1)/(braces+1);
              const w2 = lerp(bw/2, 3*S, (j+1)/(braces+1));
              ctx.save(); ctx.globalAlpha = 0.4;
              ctx.beginPath(); ctx.moveTo(sx-w, y); ctx.lineTo(sx+w2, y2); ctx.stroke();
              ctx.beginPath(); ctx.moveTo(sx+w, y); ctx.lineTo(sx-w2, y2); ctx.stroke();
              ctx.restore();
            }
          }
          // blinking red light at top
          const blink = (Math.sin(clock*3.5 + B.seed) > 0.3) ? 1 : 0;
          if(blink){
            ctx.save();
            ctx.fillStyle = 'rgba(255,40,40,0.85)';
            ctx.beginPath(); ctx.arc(sx, baseY-h-2*S, 2.5*S, 0, TAU); ctx.fill();
            // glow
            ctx.globalAlpha = 0.25;
            ctx.beginPath(); ctx.arc(sx, baseY-h-2*S, 6*S, 0, TAU); ctx.fill();
            ctx.restore();
          }
        }
        else if(B.type === 'church'){
          // Simple chapel with steeple
          const w = 50*S, h = 36*S;
          ctx.beginPath();
          ctx.rect(sx - w/2, baseY - h, w, h);
          ctx.fill();
          // roof
          ctx.beginPath();
          ctx.moveTo(sx - w*0.55, baseY - h);
          ctx.lineTo(sx, baseY - h - 18*S);
          ctx.lineTo(sx + w*0.55, baseY - h);
          ctx.closePath();
          ctx.fill();
          // steeple
          const sw = 10*S, sh = 34*S;
          ctx.beginPath();
          ctx.rect(sx - sw/2, baseY - h - 18*S - sh, sw, sh);
          ctx.fill();
          // spire
          ctx.beginPath();
          ctx.moveTo(sx - sw*0.6, baseY - h - 18*S - sh);
          ctx.lineTo(sx, baseY - h - 18*S - sh - 16*S);
          ctx.lineTo(sx + sw*0.6, baseY - h - 18*S - sh);
          ctx.closePath();
          ctx.fill();
          // cross
          ctx.lineWidth = 2*S;
          const crossY = baseY - h - 18*S - sh - 16*S;
          ctx.beginPath();
          ctx.moveTo(sx, crossY - 8*S); ctx.lineTo(sx, crossY);
          ctx.moveTo(sx-4*S, crossY - 5*S); ctx.lineTo(sx+4*S, crossY - 5*S);
          ctx.stroke();
          ctx.lineWidth = 1.5;
        }
        else if(B.type === 'grain_elevator'){
          // Tall rectangular + small annex
          const w = 36*S, h = 80*S;
          ctx.beginPath();
          ctx.rect(sx - w/2, baseY - h, w, h);
          ctx.fill();
          // pitched top
          ctx.beginPath();
          ctx.moveTo(sx - w*0.55, baseY - h);
          ctx.lineTo(sx, baseY - h - 14*S);
          ctx.lineTo(sx + w*0.55, baseY - h);
          ctx.closePath();
          ctx.fill();
          // annex
          const aw = 22*S, ah = 40*S;
          ctx.beginPath();
          ctx.rect(sx + w/2, baseY - ah, aw, ah);
          ctx.fill();
          // conveyor arm to annex top
          ctx.beginPath();
          ctx.moveTo(sx, baseY - h + 6*S);
          ctx.lineTo(sx + w/2 + aw*0.5, baseY - ah);
          ctx.stroke();
        }
        else if(B.type === 'power_lines'){
          // Power-line poles with catenary wires
          const h = 55*S, spacing = 120*S;
          for(let p=0;p<2;p++){
            const px = sx + (p-0.5)*spacing;
            // pole
            ctx.beginPath();
            ctx.moveTo(px, baseY); ctx.lineTo(px, baseY-h);
            ctx.stroke();
            // crossarm
            const cw = 18*S;
            ctx.beginPath();
            ctx.moveTo(px-cw, baseY-h+4*S); ctx.lineTo(px+cw, baseY-h+4*S);
            ctx.stroke();
          }
          // catenary wires
          ctx.save(); ctx.globalAlpha = 0.55;
          for(let w=0;w<3;w++){
            const wy = 4*S + w*5*S;
            const x1 = sx - spacing*0.5, x2 = sx + spacing*0.5;
            const y1 = baseY - h + wy, y2 = baseY - h + wy;
            const sag = 12*S + w*3*S;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo((x1+x2)/2, (y1+y2)/2 + sag, x2, y2);
            ctx.stroke();
          }
          ctx.restore();
        }
        else if(B.type === 'barn_bg'){
          // Background barn silhouette (simpler than foreground)
          const w = 70*S, h = 40*S;
          ctx.beginPath();
          ctx.rect(sx - w/2, baseY - h, w, h);
          ctx.fill();
          // gambrel roof
          ctx.beginPath();
          ctx.moveTo(sx - w*0.55, baseY - h);
          ctx.lineTo(sx - w*0.3, baseY - h - 20*S);
          ctx.lineTo(sx + w*0.3, baseY - h - 20*S);
          ctx.lineTo(sx + w*0.55, baseY - h);
          ctx.closePath();
          ctx.fill();
          // cupola
          ctx.beginPath();
          ctx.rect(sx - 5*S, baseY - h - 20*S - 10*S, 10*S, 10*S);
          ctx.fill();
          // small weathervane
          ctx.beginPath();
          ctx.moveTo(sx, baseY - h - 30*S); ctx.lineTo(sx, baseY - h - 36*S);
          ctx.moveTo(sx-4*S, baseY - h - 34*S); ctx.lineTo(sx+4*S, baseY - h - 34*S);
          ctx.stroke();
        }
        else if(B.type === 'lookout_tower'){
          // Fire lookout / ranger tower
          const h = 75*S, cabW = 20*S, cabH = 14*S;
          const legSpread = 22*S;
          // four legs converging
          ctx.beginPath();
          ctx.moveTo(sx-legSpread, baseY); ctx.lineTo(sx-cabW*0.4, baseY-h+cabH);
          ctx.moveTo(sx+legSpread, baseY); ctx.lineTo(sx+cabW*0.4, baseY-h+cabH);
          ctx.stroke();
          // cross braces
          for(let j=1;j<4;j++){
            const t = j/4;
            const y = baseY - (h-cabH)*t;
            const w = lerp(legSpread, cabW*0.4, t);
            ctx.beginPath(); ctx.moveTo(sx-w, y); ctx.lineTo(sx+w, y); ctx.stroke();
          }
          // cabin
          ctx.beginPath();
          ctx.rect(sx - cabW/2, baseY - h, cabW, cabH);
          ctx.fill();
          // railing around cabin
          ctx.save(); ctx.globalAlpha = 0.5;
          const railW = cabW*0.7;
          ctx.beginPath();
          ctx.rect(sx - railW, baseY - h - 2*S, railW*2, 2*S);
          ctx.stroke();
          ctx.restore();
          // roof
          ctx.beginPath();
          ctx.moveTo(sx - cabW*0.6, baseY - h);
          ctx.lineTo(sx, baseY - h - 8*S);
          ctx.lineTo(sx + cabW*0.6, baseY - h);
          ctx.closePath();
          ctx.fill();
        }
      }
      ctx.restore();
    }

    const GRASS_STEP = 26;
    function drawIcePatches(){
  if(!hole||!hole.icePatches) return;
  ctx.save();ctx.fillStyle='rgba(180,220,255,0.18)';
  for(const p of hole.icePatches){
    const x=p.x-view.x; const y=groundYAt(p.x)-view.y;
    ctx.beginPath();ctx.ellipse(x,y-2,p.r,p.r*0.25,0,0,TAU);ctx.fill();
  }
  ctx.restore();
}
function drawGrass(){
      if(!hole){ return; }
      const q = qualityScale();
      const density = Math.max(1, Math.round(3 * q));
      ctx.save(); ctx.strokeStyle='rgba(0,0,0,.9)'; ctx.lineWidth=1;
      const start = Math.floor((view.x-40)/GRASS_STEP)*GRASS_STEP; const end = view.x + view.w + 40;
      for(let wx=start; wx<end; wx+=GRASS_STEP){
        const gx = clamp(wx,0,hole.w); const gy = groundYAt(gx) - view.y; if(gy< -20 || gy > canvas.height/DPR+20) continue;
        for(let k=0;k<density;k++){
          const idx = ((gx|0)*7 + k)|0; const hh = 7 + rand01(backdrop.seed ^ 0xabc123, idx)*10; const lean = (rand01(backdrop.seed ^ 0x55aa55, idx+13)-0.5)*8;
          const baseX = gx - view.x + (k-1)*(2 + rand01(backdrop.seed ^ 0x999,idx+21)*2);
          ctx.beginPath(); ctx.moveTo(baseX, gy);
          const ctrlX = baseX + lean*0.45; const ctrlY = gy - hh*0.55; const tipX = baseX + lean; const tipY = gy - hh;
          ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawDisc(){
      const trailColor = cached.colors.accent;
      if(!disc.atRest && Math.hypot(disc.vx,disc.vy)>320){
        ctx.strokeStyle = trailColor; ctx.globalAlpha=0.24; ctx.lineWidth=3;
        ctx.beginPath(); ctx.moveTo(disc.x - view.x, disc.y - view.y);
        ctx.lineTo(disc.x - disc.vx*0.05 - view.x, disc.y - disc.vy*0.05 - view.y);
        ctx.stroke(); ctx.globalAlpha=1;
      }

      const skin = getDiscSkin(currentDisc.id);

      ctx.save();
      ctx.translate(disc.x - view.x, disc.y - view.y);
      ctx.rotate(disc.orient);
      ctx.fillStyle = skin.fill;
      ctx.strokeStyle = skin.rim;
      const R = disc.r;
      ctx.beginPath(); ctx.ellipse(0,0, R, R*0.45, 0, 0, TAU); ctx.fill(); ctx.stroke();
      ctx.globalAlpha=0.45; ctx.beginPath(); ctx.ellipse(0,0, R*0.85, R*0.35, 0, 0, TAU); ctx.stroke(); ctx.globalAlpha=1;
      ctx.restore();
    }

    function drawAimArrow(){
      const len = 80 + meter*160;
      const x1 = disc.x - view.x;
      const y1 = disc.y - view.y;
      const x2 = x1 + Math.cos(aimAngle)*len;
      const y2 = y1 + Math.sin(aimAngle)*len;

      ctx.save();
      ctx.strokeStyle = cached.colors.accent3; ctx.lineWidth=3; ctx.globalAlpha=0.9;
      ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();

      const a=aimAngle; const ah = 10; const aw = 7;
      ctx.beginPath(); ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - Math.cos(a)*ah + Math.sin(a)*aw, y2 - Math.sin(a)*ah - Math.cos(a)*aw);
      ctx.lineTo(x2 - Math.cos(a)*ah - Math.sin(a)*aw, y2 - Math.sin(a)*ah + Math.cos(a)*aw);
      ctx.closePath(); ctx.fillStyle=cached.colors.accent; ctx.fill();

      ctx.globalAlpha=1;
      ctx.restore();
    }

    function drawLandmark(){
      if(!hole || !hole.landmark) return;
      const lm = hole.landmark;
      const sx = lm.x - view.x;
      const sy = lm.y - view.y;
      const S = lm.s || 1;

      const nightiness = (atmo && typeof atmo.night === 'number') ? atmo.night : 0;
      const a = 0.30 + 0.35 * Math.min(1, nightiness);
      const ink = `rgba(0,0,0,${a})`;

      ctx.save();
      ctx.fillStyle = ink;
      ctx.strokeStyle = ink;
      ctx.lineWidth = Math.max(2, 2 * S);

      if(lm.type === 'barn'){
        const w = 90 * S, h = 48 * S;
        ctx.beginPath();
        ctx.rect(sx - w*0.5, sy - h, w, h);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(sx - w*0.55, sy - h);
        ctx.lineTo(sx, sy - h - 30*S);
        ctx.lineTo(sx + w*0.55, sy - h);
        ctx.closePath();
        ctx.fill();
        // door hint
        ctx.beginPath();
        ctx.rect(sx - 14*S, sy - 28*S, 28*S, 28*S);
        ctx.stroke();
      }else if(lm.type === 'bridge'){
        const w = 120 * S;
        ctx.beginPath();
        ctx.moveTo(sx - w*0.5, sy - 6*S);
        ctx.quadraticCurveTo(sx, sy - 42*S, sx + w*0.5, sy - 6*S);
        ctx.lineTo(sx + w*0.5, sy + 6*S);
        ctx.quadraticCurveTo(sx, sy - 30*S, sx - w*0.5, sy + 6*S);
        ctx.closePath();
        ctx.fill();
        // rail
        ctx.beginPath();
        ctx.moveTo(sx - w*0.5, sy - 16*S);
        ctx.lineTo(sx + w*0.5, sy - 16*S);
        ctx.stroke();
      }else if(lm.type === 'abandoned_bus'){
        const w = 110 * S, h = 36 * S;
        const x0 = sx - w*0.5, y0 = sy - h;
        const r = 10 * S;
        ctx.beginPath();
        ctx.moveTo(x0 + r, y0);
        ctx.lineTo(x0 + w - r, y0);
        ctx.quadraticCurveTo(x0 + w, y0, x0 + w, y0 + r);
        ctx.lineTo(x0 + w, y0 + h - r);
        ctx.quadraticCurveTo(x0 + w, y0 + h, x0 + w - r, y0 + h);
        ctx.lineTo(x0 + r, y0 + h);
        ctx.quadraticCurveTo(x0, y0 + h, x0, y0 + h - r);
        ctx.lineTo(x0, y0 + r);
        ctx.quadraticCurveTo(x0, y0, x0 + r, y0);
        ctx.closePath();
        ctx.fill();
        // windows
        ctx.save();
        ctx.globalAlpha = 0.45;
        for(let i=0;i<4;i++){
          ctx.beginPath();
          ctx.rect(x0 + 18*S + i*22*S, y0 + 8*S, 16*S, 10*S);
          ctx.stroke();
        }
        ctx.restore();
      }else if(lm.type === 'windmill_cluster'){
        const baseY = sy;
        for(let k=0;k<3;k++){
          const ox = sx + (k-1)*46*S;
          const h = (52 + k*6) * S;
          ctx.beginPath();
          ctx.moveTo(ox, baseY);
          ctx.lineTo(ox, baseY - h);
          ctx.stroke();
          const cx = ox, cy = baseY - h;
          const blade = 18*S;
          for(let b=0;b<4;b++){
            const ang = (Math.PI/2)*b + (k*0.4);
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + Math.cos(ang)*blade, cy + Math.sin(ang)*blade);
            ctx.stroke();
          }
        }
      }else if(lm.type === 'ice_cave'){
        const w = 110 * S, h = 55 * S;
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.ellipse(sx, sy - 18*S, w*0.45, h*0.35, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }else if(lm.type === 'cabin'){
        // Small log cabin
        const w = 60*S, h = 34*S;
        ctx.beginPath();
        ctx.rect(sx - w/2, sy - h, w, h);
        ctx.fill();
        // roof
        ctx.beginPath();
        ctx.moveTo(sx - w*0.6, sy - h);
        ctx.lineTo(sx, sy - h - 22*S);
        ctx.lineTo(sx + w*0.6, sy - h);
        ctx.closePath();
        ctx.fill();
        // chimney
        ctx.beginPath();
        ctx.rect(sx + w*0.2, sy - h - 22*S - 4*S, 10*S, 18*S);
        ctx.fill();
        // smoke wisps (animated)
        ctx.save(); ctx.globalAlpha = 0.2;
        const chimX = sx + w*0.2 + 5*S;
        const chimTopY = sy - h - 22*S - 4*S;
        for(let p=0;p<3;p++){
          const drift = Math.sin(clock*0.8 + p*1.5 + (lm.seed||0)%100) * 8*S;
          const py = chimTopY - 12*S - p*10*S;
          ctx.beginPath(); ctx.arc(chimX + drift, py, 4*S + p*2*S, 0, TAU); ctx.fill();
        }
        ctx.restore();
        // door
        ctx.beginPath();
        ctx.rect(sx - 8*S, sy - 22*S, 16*S, 22*S);
        ctx.stroke();
        // window
        ctx.beginPath();
        ctx.rect(sx + w*0.15, sy - h + 8*S, 12*S, 10*S);
        ctx.stroke();
      }else if(lm.type === 'hay_bales'){
        // Cluster of round hay bales
        const count = 3 + Math.floor(((lm.seed||0)%5));
        for(let i=0;i<count;i++){
          const bx = sx + (i - count/2) * 28*S + ((lm.seed||0)%(7+i))*0.5;
          const by = sy;
          const r = 13*S + (i%2)*3*S;
          // cylinder face
          ctx.beginPath(); ctx.ellipse(bx, by - r, r, r*0.7, 0, 0, TAU); ctx.fill();
          // spiral hint
          ctx.save(); ctx.globalAlpha = 0.3;
          ctx.beginPath(); ctx.arc(bx, by - r, r*0.4, 0, TAU); ctx.stroke();
          ctx.restore();
        }
      }else if(lm.type === 'shed'){
        // Small garden shed / equipment hut
        const w = 44*S, h = 30*S;
        ctx.beginPath();
        ctx.rect(sx - w/2, sy - h, w, h);
        ctx.fill();
        // slanted roof
        ctx.beginPath();
        ctx.moveTo(sx - w*0.55, sy - h);
        ctx.lineTo(sx - w*0.45, sy - h - 10*S);
        ctx.lineTo(sx + w*0.55, sy - h - 6*S);
        ctx.lineTo(sx + w*0.55, sy - h);
        ctx.closePath();
        ctx.fill();
        // door
        ctx.beginPath();
        ctx.rect(sx - 7*S, sy - 20*S, 14*S, 20*S);
        ctx.stroke();
      }else if(lm.type === 'fence_gate'){
        // Split-rail fence with gate opening
        const fenceW = 100*S;
        const postH = 26*S;
        const posts = 5;
        for(let i=0;i<posts;i++){
          if(i === 2) continue; // gate gap
          const px = sx - fenceW/2 + (fenceW/(posts-1))*i;
          ctx.beginPath();
          ctx.moveTo(px, sy); ctx.lineTo(px, sy - postH);
          ctx.stroke();
        }
        // rails
        for(let r=0;r<2;r++){
          const ry = sy - 8*S - r*10*S;
          ctx.beginPath();
          ctx.moveTo(sx - fenceW/2, ry);
          ctx.lineTo(sx - fenceW/2 + fenceW*0.35, ry);
          ctx.moveTo(sx - fenceW/2 + fenceW*0.55, ry);
          ctx.lineTo(sx + fenceW/2, ry);
          ctx.stroke();
        }
        // gate posts (thicker)
        ctx.lineWidth = Math.max(3, 3*S);
        const g1 = sx - fenceW/2 + fenceW*0.35;
        const g2 = sx - fenceW/2 + fenceW*0.55;
        ctx.beginPath();
        ctx.moveTo(g1, sy); ctx.lineTo(g1, sy - postH - 4*S);
        ctx.moveTo(g2, sy); ctx.lineTo(g2, sy - postH - 4*S);
        ctx.stroke();
        ctx.lineWidth = Math.max(2, 2*S);
      }else if(lm.type === 'water_well'){
        // Stone well with roof
        const ww = 30*S, wh = 20*S;
        // well wall (trapezoid)
        ctx.beginPath();
        ctx.moveTo(sx - ww/2, sy); ctx.lineTo(sx - ww*0.45, sy - wh);
        ctx.lineTo(sx + ww*0.45, sy - wh); ctx.lineTo(sx + ww/2, sy);
        ctx.closePath();
        ctx.fill();
        // posts
        ctx.beginPath();
        ctx.moveTo(sx - ww*0.35, sy - wh); ctx.lineTo(sx - ww*0.3, sy - wh - 28*S);
        ctx.moveTo(sx + ww*0.35, sy - wh); ctx.lineTo(sx + ww*0.3, sy - wh - 28*S);
        ctx.stroke();
        // little roof
        const roofY = sy - wh - 28*S;
        ctx.beginPath();
        ctx.moveTo(sx - ww*0.55, roofY + 2*S);
        ctx.lineTo(sx, roofY - 8*S);
        ctx.lineTo(sx + ww*0.55, roofY + 2*S);
        ctx.closePath();
        ctx.fill();
        // crossbar with bucket hint
        ctx.beginPath();
        ctx.moveTo(sx - ww*0.3, roofY + 6*S);
        ctx.lineTo(sx + ww*0.3, roofY + 6*S);
        ctx.stroke();
      }else if(lm.type === 'campfire'){
        // Small campfire ring with glow
        const ringR = 14*S;
        // stone ring
        ctx.save(); ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.ellipse(sx, sy - 2*S, ringR, ringR*0.35, 0, 0, TAU);
        ctx.stroke();
        ctx.restore();
        // logs
        ctx.beginPath();
        ctx.moveTo(sx - 8*S, sy - 4*S); ctx.lineTo(sx + 6*S, sy - 8*S);
        ctx.moveTo(sx + 8*S, sy - 3*S); ctx.lineTo(sx - 5*S, sy - 9*S);
        ctx.stroke();
        // flame glow (animated)
        const flicker = 0.6 + 0.4*Math.sin(clock*6 + (lm.seed||0));
        ctx.save();
        ctx.fillStyle = `rgba(255,140,40,${0.25*flicker})`;
        ctx.beginPath(); ctx.ellipse(sx, sy - 10*S, 8*S, 14*S*flicker, 0, 0, TAU); ctx.fill();
        ctx.fillStyle = `rgba(255,200,60,${0.35*flicker})`;
        ctx.beginPath(); ctx.ellipse(sx, sy - 8*S, 4*S, 8*S*flicker, 0, 0, TAU); ctx.fill();
        ctx.restore();
      }else if(lm.type === 'tent_camp'){
        // A-frame tent with small flag
        const tw = 40*S, th = 28*S;
        ctx.beginPath();
        ctx.moveTo(sx - tw/2, sy);
        ctx.lineTo(sx, sy - th);
        ctx.lineTo(sx + tw/2, sy);
        ctx.closePath();
        ctx.fill();
        // tent opening
        ctx.save(); ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.moveTo(sx - tw*0.2, sy);
        ctx.lineTo(sx, sy - th*0.65);
        ctx.lineTo(sx + tw*0.2, sy);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
        // flag pole next to tent
        const poleX = sx + tw*0.45;
        ctx.beginPath();
        ctx.moveTo(poleX, sy); ctx.lineTo(poleX, sy - th - 14*S);
        ctx.stroke();
        // flag (animated flutter)
        const flutter = Math.sin(clock*4 + (lm.seed||0)) * 3*S;
        ctx.beginPath();
        ctx.moveTo(poleX, sy - th - 14*S);
        ctx.lineTo(poleX + 12*S, sy - th - 10*S + flutter);
        ctx.lineTo(poleX, sy - th - 6*S);
        ctx.closePath();
        ctx.fill();
      }else if(lm.type === 'stone_wall'){
        // Low crumbling stone wall
        const ww = 100*S, wh = 14*S;
        ctx.beginPath();
        ctx.rect(sx - ww/2, sy - wh, ww, wh);
        ctx.fill();
        // stone texture (horizontal + vertical lines)
        ctx.save(); ctx.globalAlpha = 0.3;
        const rows = 3;
        for(let r=1;r<rows;r++){
          const y = sy - wh + (wh/rows)*r;
          ctx.beginPath(); ctx.moveTo(sx-ww/2, y); ctx.lineTo(sx+ww/2, y); ctx.stroke();
        }
        // vertical joints (staggered)
        for(let r=0;r<rows;r++){
          const y = sy - wh + (wh/rows)*r;
          const off = (r%2) * 12*S;
          for(let c=0;c<6;c++){
            const cx = sx - ww/2 + off + c*(ww/5);
            if(cx > sx + ww/2) break;
            ctx.beginPath(); ctx.moveTo(cx, y); ctx.lineTo(cx, y + wh/rows); ctx.stroke();
          }
        }
        ctx.restore();
        // crumble at one end
        ctx.save(); ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.rect(sx + ww/2 - 6*S, sy - wh + 4*S, 6*S, wh - 4*S);
        ctx.fillStyle = ink; ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }


    function drawScenery(){
      drawFences();

      // Rocks
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.92)';
      for(const r of scenery.rocks){
        const x = r.x - view.x, y = r.y - view.y;
        if(x<-40 || x>canvas.width/DPR+40) continue;
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(r.skew);

        function rr(seed,i){ return (hash32(seed ^ (i*2654435761))>>>0)/4294967295; }
        const lumps = 2 + Math.floor(rr(r.seed,1)*3);
        for(let i=0;i<lumps;i++){
          const ang = rr(r.seed,10+i)*TAU;
          const dist = r.r * (0.2 + rr(r.seed,20+i)*0.9);
          const rad  = r.r * (0.7 + rr(r.seed,30+i)*0.7);
          const ox = Math.cos(ang)*dist;
          const oy = Math.sin(ang)*dist*0.5 - r.r*0.3;
          const rot = (rr(r.seed,40+i)-0.5)*0.8;
          ctx.save(); ctx.translate(ox, oy); ctx.rotate(rot);
          ctx.beginPath(); ctx.ellipse(0, 0, rad, rad*0.65, 0, 0, TAU); ctx.fill();
          ctx.restore();
        }

        ctx.restore();
      }
      ctx.restore();

            // Snowbanks (snow biome variant) ‚Äî soft layered mounds
      if(scenery.snowbanks && scenery.snowbanks.length){
        ctx.save();
        for(const b of scenery.snowbanks){
          const x = b.x - view.x, y = b.y - view.y;
          if(x < -(b.w+60) || x > canvas.width/DPR + (b.w+60)) continue;
          // Layered sub-mounds for organic shape
          const lumps = 3 + Math.floor((b.x * 7.3) % 3);
          for(let i=0;i<lumps;i++){
            const t = (i + 0.5) / lumps;
            const lx = x + (t - 0.5) * b.w * 0.9;
            const lr = b.w * (0.22 + 0.12 * Math.sin(b.x * 3.1 + i * 2.7));
            const lh = b.h * (0.6 + 0.4 * Math.cos(b.x * 1.9 + i * 1.3));
            const ly = y - lh * 0.15;
            const g = ctx.createRadialGradient(lx, ly, 0, lx, ly + lh * 0.3, Math.max(lr, lh));
            g.addColorStop(0, `rgba(255,255,255,${(0.55 * b.a).toFixed(3)})`);
            g.addColorStop(0.5, `rgba(245,248,255,${(0.3 * b.a).toFixed(3)})`);
            g.addColorStop(1, 'rgba(240,245,255,0.00)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.ellipse(lx, ly, lr, lh * 0.7, 0, 0, TAU);
            ctx.fill();
          }
          // Soft highlight on top
          const hg = ctx.createRadialGradient(x, y - b.h * 0.5, 0, x, y - b.h * 0.3, b.w * 0.35);
          hg.addColorStop(0, `rgba(255,255,255,${(0.25 * b.a).toFixed(3)})`);
          hg.addColorStop(1, 'rgba(255,255,255,0.00)');
          ctx.fillStyle = hg;
          ctx.beginPath();
          ctx.ellipse(x, y - b.h * 0.35, b.w * 0.35, b.h * 0.5, 0, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }

      // Trees
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.94)';
      ctx.strokeStyle = 'rgba(0,0,0,0.94)';
      for(const t of scenery.trees){
        const x = t.x - view.x, y = t.y - view.y;
        if(x<-80 || x>canvas.width/DPR+80) continue;
        const sway = Math.sin(clock*0.3 + t.sway) * 2;

        const type = t.type || 'pine';
        const trunkW = clamp(t.h*0.045, 3, 8);

        if(type==='cactus'){
          const w = clamp(t.w*0.45, 6, 14);
          ctx.fillRect(x - w/2, y - t.h, w, t.h);
          const armH = t.h*0.35;
          const armW = w*0.85;
          const armY = y - t.h*0.55;

          // left arm
          ctx.fillRect(x - w/2 - armW, armY, armW, w*0.9);
          ctx.fillRect(x - w/2 - armW, armY - armH, w*0.9, armH);

          // right arm
          ctx.fillRect(x + w/2, armY + w*0.15, armW, w*0.9);
          ctx.fillRect(x + w/2 + armW - w*0.9, armY + w*0.15 - armH*0.85, w*0.9, armH*0.85);

          ctx.beginPath(); ctx.ellipse(x, y, w*0.65, w*0.35, 0, 0, TAU); ctx.fill();
          continue;
        }

        if(type==='palm'){
          const w = clamp(t.w*0.35, 4, 10);
          const tilt = (Math.sin(t.sway*7.3) * 0.12);
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(tilt);
          ctx.fillRect(-w/2, -t.h, w, t.h);

          const topY = -t.h;
          for(let k=0;k<6;k++){
            const ang = -Math.PI/2 + (k-2.5)*0.35 + Math.sin(clock*0.25 + t.sway + k)*0.08;
            const len = t.h*0.25;
            ctx.beginPath();
            ctx.moveTo(0, topY);
            ctx.lineTo(Math.cos(ang)*len, topY + Math.sin(ang)*len);
            ctx.lineTo(Math.cos(ang+0.18)*len*0.6, topY + Math.sin(ang+0.18)*len*0.6);
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
          continue;
        }

        if(type==='juniper'){
          ctx.fillRect(x - trunkW/2, y - t.h*0.55, trunkW, t.h*0.55);
          const r = t.w*0.55;
          const cy = y - t.h*0.62;
          for(let k=0;k<5;k++){
            const ox = (k-2)*r*0.18 + sway*0.25;
            const oy = Math.sin((t.sway+k)*2.1)*r*0.10;
            ctx.beginPath();
            ctx.ellipse(x+ox, cy+oy, r*(0.85 - k*0.10), r*(0.65 - k*0.07), 0, 0, TAU);
            ctx.fill();
          }
          continue;
        }

        if(type==='dead'){
          ctx.fillRect(x - trunkW/2, y - t.h, trunkW, t.h);
          ctx.beginPath(); ctx.moveTo(x - trunkW*0.8, y); ctx.lineTo(x + trunkW*0.8, y); ctx.lineTo(x, y - trunkW*0.4); ctx.closePath(); ctx.fill();

          ctx.save();
          ctx.lineWidth = 2;
          for(let k=0;k<4;k++){
            const by = y - t.h*(0.35 + k*0.12);
            const dir = (k%2===0 ? -1 : 1);
            ctx.beginPath();
            ctx.moveTo(x + dir*trunkW*0.2, by);
            ctx.lineTo(x + dir*(trunkW*1.6 + k*3), by - (8 + k*3));
            ctx.stroke();
          }
          ctx.restore();
          continue;
        }

        // Default: pine / snowpine
        ctx.fillRect(x - trunkW/2, y - t.h, trunkW, t.h);
        ctx.beginPath(); ctx.moveTo(x - trunkW*0.8, y); ctx.lineTo(x + trunkW*0.8, y); ctx.lineTo(x, y - trunkW*0.4); ctx.closePath(); ctx.fill();

        const tierGap = 10;
        for(let k=0;k<t.levels;k++){
          const level = t.h*(0.16 + k*0.18);
          const width = (t.w + k*(t.w*0.28));
          const topX = x + sway*0.45;
          const topY = y - level - (k*tierGap);
          const baseY = y - level + tierGap;

          ctx.beginPath();
          ctx.moveTo(topX, topY);
          ctx.lineTo(x - width/2 + sway, baseY);
          ctx.lineTo(x + width/2 + sway, baseY);
          ctx.closePath(); ctx.fill();

          if(type==='snowpine' || t.snow){
            ctx.save();
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.beginPath();
            ctx.moveTo(topX, topY);
            ctx.lineTo(topX - width*0.22, topY + (baseY-topY)*0.35);
            ctx.lineTo(topX + width*0.22, topY + (baseY-topY)*0.35);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.fillStyle = 'rgba(0,0,0,0.94)';
          }
        }
      }
      ctx.restore();
    }

    function drawFences(){
      if(!scenery.fences.length) return;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.94)';
      ctx.fillStyle   = 'rgba(0,0,0,0.94)';

      for(const F of scenery.fences){
        // Posts
        for(const P of F.posts){
          const x = P.x;
          const y = groundYAt(x);
          const sx = x - view.x;
          const sy = y - view.y;
          if(sx<-40 || sx>canvas.width/DPR+40) continue;

          const yR  = groundYAt(x+6);
          const ang = Math.atan2(yR - y, 6) + P.tilt;
          const h   = F.height * P.hMul;
          const w   = 3;

          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(ang - Math.PI/2);
          ctx.translate(0.5, 0.5);
          ctx.fillRect(-w/2, 0, w, h);
          ctx.fillRect(-w/2 - 1, 0, w+2, 2);
          ctx.restore();
        }

        // Rails
        const railOffset = (F.rails === 3) ? [6,12,18] : [8,16];
        ctx.lineWidth = 2;
        for(const off of railOffset){
          ctx.beginPath();
          let started=false;
          for(const P of F.posts){
            const sx = P.x - view.x;
            const sy = groundYAt(P.x) - view.y - off;
            if(sx<-60 || sx>canvas.width/DPR+60) continue;
            if(!started){ ctx.moveTo(sx, sy); started=true; }
            else ctx.lineTo(sx, sy);
          }
          if(started) ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ===== Sand bunkers
    function drawBunkerHole(s){
      const cx = s.x - view.x, cy = s.y - view.y;
      const r = s.r;

      const yL = groundYAt(s.x - 6), yR = groundYAt(s.x + 6);
      const ang = Math.atan2(yR - yL, 12);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.scale(1.10, 0.68);

      const ring = ctx.createRadialGradient(0, 0, r*0.72, 0, 0, r);
      ring.addColorStop(0, 'rgba(255,255,255,0)');
      ring.addColorStop(1, 'rgba(255,255,255,0.08)');
      ctx.fillStyle = ring;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      const shade = ctx.createRadialGradient(0, r*0.22, r*0.18, 0, 0, r);
      shade.addColorStop(0, 'rgba(0,0,0,0.30)');
      shade.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shade;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      ctx.save();
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.clip();
      drawSandGrain(s.seed, r);
      ctx.restore();

      ctx.restore();
    }
    function drawSandGrain(seed, r){
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const N = 140;
      for(let i=0;i<N;i++){
        const u = rand01(seed, i*7+1);
        const v = rand01(seed, i*7+2);
        const theta = v * TAU;
        const rad = Math.sqrt(u) * r * 0.85;
        const x = Math.cos(theta) * rad;
        const y = Math.sin(theta) * rad * 0.82;
        const dir = (rand01(seed, i*7+3)-0.5) * TAU;
        const len = 2 + rand01(seed, i*7+4)*4;

        ctx.beginPath();
        ctx.moveTo(x - Math.cos(dir)*len*0.5, y - Math.sin(dir)*len*0.5);
        ctx.lineTo(x + Math.cos(dir)*len*0.5, y + Math.sin(dir)*len*0.5);
        ctx.stroke();
      }
    }

    
    function drawGeyser(){
  if (!hole) return;
  const allGeysers = [];
  if(hole.geyser) allGeysers.push(hole.geyser);
  if(hole.extraGeysers) allGeysers.push(...hole.extraGeysers);
  if(!allGeysers.length) return;
  for(const G of allGeysers){

  const gx = G.x;
  const gy = groundYAt(gx);
  const sx = gx - view.x;
  const sy = gy - view.y;

  // Visual-only "vent": just the wavy vertical air lines (no fan body / pads / puffs).
  const rx = Math.max(10, G.rx * 0.50);        // narrower than the physics radius
  const h  = Math.max(80, G.height * 0.70);    // shorter plume to read as "small vent"

  const sway = Math.sin(clock * (G.drift?.speed || 0.0) + (G.drift?.phase || 0.0)) * (G.drift?.amp || 0.0);

  ctx.save();
  ctx.translate(sx, sy);

  ctx.globalAlpha = 0.80;
  ctx.strokeStyle = "rgba(215,248,255,0.45)";
  ctx.lineCap = "round";

  const lines = 3;
  for (let i = 0; i < lines; i++){
    const t = i / (lines - 1) - 0.5;
    const x0 = t * rx * 0.55 + sway * 0.18;
    const steps = 18;

    ctx.beginPath();
    for (let s = 0; s <= steps; s++){
      const p = s / steps;
      const y = -h * p;
      const wob = Math.sin(p * 9 + clock * 4 + i * 1.3) * (rx * 0.12) * (1 - p);
      const x = x0 + wob;
      if (s === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.lineWidth = (i === 1) ? 2.4 : 1.9;
    ctx.stroke();
  }

  ctx.restore();
  } // end for(allGeysers)
}

function drawBasket(){
      const gx = hole.cupX;
      const gyCup = groundYAt(gx);
      const x = gx - view.x;
      const groundY = gyCup - view.y;
      const poleH = 74, cageTop = groundY - 24, rimY = groundY - 46;
      const rimW = 28, cageW = 24;

      ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x, groundY - poleH); ctx.stroke();

      ctx.fillStyle = 'rgba(0,0,0,0.80)';
      ctx.fillRect(x - cageW/2, cageTop, cageW, 8);
      ctx.fillRect(x - 2, cageTop - 10, 4, 10);

      ctx.beginPath(); ctx.ellipse(x, rimY, rimW/2, 4, 0, 0, TAU); ctx.fill();

      ctx.strokeStyle='rgba(0,0,0,0.75)'; ctx.lineWidth=1;
      for(let i=0;i<6;i++){
        const t = i/6 * TAU;
        const cx = x + Math.cos(t) * (rimW/2 - 2);
        ctx.beginPath();
        ctx.moveTo(cx, rimY);
        ctx.lineTo(cx, cageTop);
        ctx.stroke();
      }

      const poleTopY = groundY - poleH;
      const stub = 16;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, poleTopY); ctx.lineTo(x, poleTopY - stub); ctx.stroke();

      const anchorX = x;
      const anchorY = poleTopY - stub;

      const dir  = (windOn ? (windLift >= 0 ? 1 : -1) : 1);
      const wmag = windOn ? Math.abs(windLift) : 0;

      const len    = 34 + wmag*26;
      const height = 10;
      const amp    = 2 + wmag*6;
      const speed  = 2.2 + wmag*2.0;
      const phase  = clock * speed;
      const N      = 8;

      ctx.save();
      const flagCol = cached.colors.accent;
      ctx.fillStyle = flagCol;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t = i/N;
        const px = anchorX + dir * t * len;
        const wave = Math.sin(phase + t*TAU) * amp * (0.6 + 0.4*Math.cos(t*TAU*0.5));
        const py = anchorY + wave;
        if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      for(let i=N;i>=0;i--){
        const t = i/N;
        const px = anchorX + dir * t * len;
        const wave = Math.sin(phase + t*TAU + 0.6) * amp * (0.6 + 0.4*Math.cos(t*TAU*0.5));
        const py = anchorY + height + wave*0.6;
        ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();

      const tipX = anchorX + dir * len;
      const tipY = anchorY + Math.sin(phase + TAU)*amp*0.6 + height*0.5;
      ctx.beginPath();
      ctx.moveTo(tipX,               tipY - height*0.35);
      ctx.lineTo(tipX + dir*6,       tipY);
      ctx.lineTo(tipX,               tipY + height*0.35);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fill();

      ctx.restore();
    }

    function checkBasketCatch(){
      const gx = hole.cupX;
      const gyCup = groundYAt(gx);
      const rimY = gyCup - 46;
      const cageTop = gyCup - 24;
      const rimHalf = 14 + Math.min(3, PU.rimHalfBonus);
      if(disc.vy > 30 * PU.vyThreshMul && disc.y > rimY-6 && disc.y < cageTop+6 && Math.abs(disc.x - gx) < rimHalf){
        return true;
      }
      return false;
    }

    function drawVignette(){
      const w = view.w, h = view.h;
      const v = Math.max(0, Math.min(1, atmo.vignette ?? 0.35));
      const g = ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.2,w*0.5,h*0.55,Math.max(w,h)*0.7);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,`rgba(0,0,0,${0.35 * v / 0.35})`);
      ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    }

    function drawToasts(){
      if(!toasts.length) return;
      ctx.save();
      const w = view.w;
      const y0 = 48;
      ctx.font = '600 14px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial';
      ctx.textAlign = 'center';
      for(let i=0;i<toasts.length;i++){
        const T = toasts[i];
        const alpha = Math.max(0, 1 - (T.t / T.dur));
        const padX = 14, padY = 8, th = 28;
        const tw = T.width + padX*2;
        const x = w/2, y = y0 + i*(th+8);
        ctx.globalAlpha = 0.65 * alpha;
        roundedRect(ctx, x - tw/2, y - th/2, tw, th, 10);
        ctx.fillStyle = 'rgba(0,0,0,0.65)'; ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.stroke();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#e6edf3';
        ctx.fillText(T.msg, x, y + 4);
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }
    function roundedRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function updateDistanceUI(){
  if(!elDistVal) return;
  if(!hole){
    elDistVal.textContent = '‚Äî';
    return;
  }
  const tx = hole.cupX;
  const ty = groundYAt(tx) - 60;
  const distPx = Math.hypot(tx - disc.x, ty - disc.y);
  const distM = distPx / PX_PER_M;
  elDistVal.textContent = String(Math.max(0, Math.round(distM)));
}



    // ===== Resize
    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
      canvas.width = Math.floor(window.innerWidth * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      view.w = (canvas.width/DPR) / zoomLevel;
      view.h = (canvas.height/DPR) / zoomLevel;
      refreshColorsFromCSS();
      rebuildSkyGradient();
      rebuildMountainsOffscreen();
    }
    window.addEventListener('resize', resize); resize();

    // ===== Main loop (fixed timestep)
    const FIXED_DT = 1/60;
    let last=0; let clock=0; let acc=0;
    function loop(t){
      const now=t/1000;
      let frameDT = Math.min(0.05, last? now-last: 0.016);
      last=now;
      frameEMA = frameEMA*0.9 + frameDT*0.1;
      acc += frameDT;

      const maxSteps = 5;
      let steps = 0;

      // Guard against rare runtime errors that would otherwise halt the animation loop.
      // If something goes wrong, we reset the disc state and keep the hole/score intact.
      try {
        while(acc >= FIXED_DT && steps++ < maxSteps){
          clock += FIXED_DT;
          update(FIXED_DT);
          acc -= FIXED_DT;
        }
        draw();
      } catch (e) {
        console.error(e);
        // Throttle recovery to avoid spam if an error repeats.
        const ms = (t||0);
        if(!loop._lastRecover || (ms - loop._lastRecover) > 2000){
          loop._lastRecover = ms;
          try { addToast('Recovered from an error ‚Äî resetting disc.'); } catch {}
          try {
            // Minimal, safe reset
            if(hole && disc){
              disc.x = hole.tee.x;
              disc.y = hole.tee.y - disc.r - 2;
              disc.vx = 0; disc.vy = 0;
              disc.spin = 0; disc.orient = 0; disc.bank = 0;
              disc.onGround = false;
            }
          } catch {}
          // Ensure we don't leave debris that could trigger repeated errors
          try { particles.length = 0; } catch {}
          try { ravens.length = 0; } catch {}
        }
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== Audio unlock on first interaction
    window.addEventListener('pointerdown', () => {
      try { Sfx.init(); } catch {}
      if (chkAudio && chkAudio.checked) {
        try { Sfx.setEnabled(true); } catch {}
        try { AudioMini.init(); AudioMini.setEnabled(true); } catch {}
      }
    }, { once:true });

    // ===== UI wiring
    btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; Sfx.init(); newRound(); });
    btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; Sfx.init(); newRound(); });
    btnNewRound.addEventListener('click', ()=>{ Sfx.init(); newRound(); });
    btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
    btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });

    // Disc bag modal
    const DISC_DESCRIPTIONS = {
      DRV: 'Max distance off the tee. High speed, strong fade.',
      FAI: 'Controlled distance. Good glide with moderate fade.',
      MID: 'Versatile approach disc. Best glide, gentle fade.',
      PUT: 'Accuracy for short range. Minimal turn and fade.'
    };
    const DISC_ICONS = { DRV:'üíø', FAI:'üí†', MID:'üîµ', PUT:'üü¢' };
    function buildBagContents(){
      updateCoinDisplay();
      bagDiscs.innerHTML = '';
      DISCS.forEach(d => {
        const unlocked = unlockedDiscs.has(d.id);
        const price = DISC_PRICES[d.id];
        const slot = document.createElement('div');
        slot.className = 'bag-slot ' + (unlocked ? 'unlocked' : 'locked');
        let html = '<div class="lock-badge">üîí</div>' +
          '<div class="disc-icon">' + DISC_ICONS[d.id] + '</div>' +
          '<div class="disc-name">' + d.name + '</div>' +
          '<div class="disc-desc">' + DISC_DESCRIPTIONS[d.id] + '</div>';
        if(unlocked){
          // Show skin swatches ‚Äì owned are selectable, unowned are purchasable
          html += '<div class="skin-row">';
          DISC_SKINS[d.id].forEach((skin, si) => {
            const owned = ownsSkin(d.id, si);
            const sel = (selectedSkins[d.id] === si);
            if(owned){
              html += '<button class="skin-btn" aria-pressed="' + sel + '" data-disc="' + d.id + '" data-skin="' + si + '" title="' + skin.name + '"><span class="swatch" style="background:' + skin.fill + '"></span></button>';
            } else {
              html += '<button class="skin-btn locked-skin" aria-pressed="false" data-buy-skin-disc="' + d.id + '" data-buy-skin-idx="' + si + '" title="' + skin.name + ' ‚Äî ' + SKIN_PRICE + ' coins"><span class="swatch" style="background:' + skin.fill + '"></span><span class="price-tip">ü™ô ' + SKIN_PRICE + '</span></button>';
            }
          });
          html += '</div>';
        } else if(price){
          // Locked disc ‚Äì show price hint
          html += '<div class="buy-hint">üîí ' + price + ' coins</div>';
          slot.dataset.buyDisc = d.id;
        }
        slot.innerHTML = html;
        bagDiscs.appendChild(slot);
      });
    }
    function handleBagClick(e){
      // Buy a locked disc
      const slot = e.target.closest('[data-buy-disc]');
      if(slot){
        const discId = slot.dataset.buyDisc;
        const price = DISC_PRICES[discId];
        if(!price) return;
        if(coins < price){ addToast('Need ' + price + ' coins'); return; }
        if(spendCoins(price)){
          unlockDisc(discId);
          buildDiscs();
          buildBagContents();
          addToast('Purchased: ' + DISCS.find(d=>d.id===discId).name);
        }
        return;
      }
      // Buy a locked skin
      const skinBtn = e.target.closest('[data-buy-skin-disc]');
      if(skinBtn){
        const discId = skinBtn.dataset.buySkinDisc;
        const skinIdx = parseInt(skinBtn.dataset.buySkinIdx, 10);
        if(buySkin(discId, skinIdx)){
          buildBagContents();
          addToast('Purchased: ' + DISC_SKINS[discId][skinIdx].name + ' skin');
        } else if(!ownsSkin(discId, skinIdx)){
          addToast('Need ' + SKIN_PRICE + ' coins');
        }
        return;
      }
      // Select an owned skin
      const btn = e.target.closest('.skin-btn');
      if(!btn || btn.classList.contains('locked-skin')) return;
      const discId = btn.dataset.disc;
      const skinIdx = parseInt(btn.dataset.skin, 10);
      if(!ownsSkin(discId, skinIdx)) return;
      selectedSkins[discId] = skinIdx;
      saveSkins();
      btn.closest('.skin-row').querySelectorAll('.skin-btn').forEach(b => b.setAttribute('aria-pressed', b === btn ? 'true' : 'false'));
    }
    btnBag.addEventListener('click', ()=>{ buildBagContents(); screenBag.style.display='grid'; });
    btnCloseBag.addEventListener('click', ()=>{ screenBag.style.display='none'; });
    bagDiscs.addEventListener('click', handleBagClick);

    // ===== Zoom controls
    const btnZoomIn = document.getElementById('btnZoomIn');
    const btnZoomOut = document.getElementById('btnZoomOut');
    function applyZoom(newZoom){
      zoomLevel = clamp(newZoom, ZOOM_MIN, ZOOM_MAX);
      view.w = (canvas.width/DPR) / zoomLevel;
      view.h = (canvas.height/DPR) / zoomLevel;
      centerCameraOnDisc();
      rebuildSkyGradient();
    }
    btnZoomIn.addEventListener('click', (e)=>{ e.stopPropagation(); applyZoom(zoomLevel + ZOOM_STEP); });
    btnZoomOut.addEventListener('click', (e)=>{ e.stopPropagation(); applyZoom(zoomLevel - ZOOM_STEP); });

    // Persisted toggles
    const prefKeys = { reduced:'prefReduced', audio:'prefAudio', wind:'prefWind', boss:'prefBoss' };
    (function restorePrefs(){
      const r = localStorage.getItem(prefKeys.reduced); if(r!==null) chkReduced.checked = (r==='1');
      const a = localStorage.getItem(prefKeys.audio);   if(a!==null) chkAudio.checked   = (a==='1');
      const w = localStorage.getItem(prefKeys.wind);    if(w!==null) chkWind.checked    = (w==='1');
      const b = localStorage.getItem(prefKeys.boss);    if(b!==null) chkBoss.checked    = (b==='1');
      reducedMotion = chkReduced.checked;
      windOn = chkWind.checked;
      bossMode = chkBoss.checked;
      if(bossMode){ HOLES_PER_ROUND = 8; elHolesTotal.textContent = HOLES_PER_ROUND; }
      updateWindUI();
    })();

    chkReduced.addEventListener('change', ()=>{ reducedMotion = chkReduced.checked; localStorage.setItem(prefKeys.reduced, chkReduced.checked?'1':'0'); });
    chkAudio.addEventListener('change', async ()=>{ const on = chkAudio.checked; localStorage.setItem(prefKeys.audio, on?'1':'0'); Sfx.setEnabled(on); await AudioMini.setEnabled(on); });
    chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; localStorage.setItem(prefKeys.wind, windOn?'1':'0'); updateWindUI(); AudioMini.setWind(windOn); });
    chkBoss.addEventListener('change', ()=>{ bossMode = chkBoss.checked; localStorage.setItem(prefKeys.boss, bossMode?'1':'0'); HOLES_PER_ROUND = bossMode ? 8 : 18; elHolesTotal.textContent = HOLES_PER_ROUND; });

    // initialize toggles' effects
    Sfx.setEnabled(chkAudio.checked);
    AudioMini.setEnabled(chkAudio.checked);
    AudioMini.setWind(windOn);

    buildDiscs();
    updateCoinDisplay();

    updateWindUI();

    // Render a living scene behind the intro screen
    (function initIntroBackdrop(){
      const biome = pickWeighted(BIOMES, b => BIOME_WEIGHTS[b.name] ?? 1);
      currentBiome = biome;
      const variants = BIOME_VARIANTS[biome.name];
      currentBiomeVariant = variants ? pickWeighted(variants, v => v.weight ?? 1) : null;
      applyTheme(biome, currentBiomeVariant);
      backdrop.seed = (Math.random()*1e9)|0;
      buildBackdrop();
      // Pick a random time of day (weighted toward dusk/night for drama)
      const introWeights = { clear:0.30, dusk:0.40, night:0.30 };
      const dayKey = weightedPickKey(introWeights);
      applyDaytime(DAYTIMES[dayKey] || DAYTIMES.dusk);
    })();

    // NOTE: Start screen stays until user clicks Start Round
  }
})();
</script>
</body>
</html>
