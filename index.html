<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Dusk Drive ‚Äî Side-View Silhouette Golf (v1.9)</title>
<style>
  :root{
    --bg1:#0a1222;            /* night sky bottom */
    --bg2:#121d3c;            /* night sky mid    */
    --bg3:#1e2b58;            /* night sky top    */
    --fg:#050607;             /* silhouette foreground */
    --text:#e6edf3;           /* text */
    --muted:#a9b1ba;          
    --accent:#ff8a3d;         /* primary accent (UI, ball trail) */
    --accent2:#49d0ff;        /* secondary accent (flag) */
    --accent3:#86efac;        /* tertiary accent (power) */
    --panel:rgba(5,6,7,.65);
    --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1000px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  .aim-arrow{position:absolute;pointer-events:none;inset:0}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}

  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}

  .small{font-size:.9rem;color:var(--muted)}

  /* Orientation helper */
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}

  @media (orientation:portrait){
    #landscapeHint{display:flex}
  }
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Dusk Drive side-view game canvas"></canvas></div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="topbar">
      <div class="row">
        <div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
        <div class="chip"><span class="label">Par</span> <strong id="parLabel">4</strong></div>
        <div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
      </div>
      <div class="row">
        <div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="panel controls">
        <div class="seg" id="clubSeg" role="group" aria-label="Club select"></div>
        <div class="seg" id="spinSeg" role="group" aria-label="Spin select">
          <button class="btn" data-spin="-1" aria-pressed="false" title="Backspin">‚≠≥</button>
          <button class="btn" data-spin="0" aria-pressed="true" title="Neutral">‚Ä¢</button>
          <button class="btn" data-spin="1" aria-pressed="false" title="Topspin">‚≠±</button>
        </div>
        <button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
      </div>
    </div>

    <div class="powermeter" id="powermeter" aria-hidden="true"><div class="fill" id="powerfill"></div></div>
  </div>

  <div id="screenIntro" class="screen" role="dialog" aria-modal="true">
    <div class="card">
      <h1>üèåÔ∏è‚Äç‚ôÇÔ∏è Dusk Drive</h1>
      <div class="sub">2D side-view silhouette golf. Drag to aim, hold to charge, release to shoot.</div>
      <div class="grid">
        <div class="tag">Hold-Release Meter</div>
        <div class="tag">Wind & Spin</div>
        <div class="tag">Procedural Holes</div>
        <div class="tag">3-Hole Burst</div>
      </div>
      <p class="small" style="margin-top:.7rem">Best in landscape ‚Ä¢ Mobile-friendly ‚Ä¢ Haptics on impact</p>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlay">Start Round</button></div>
    </div>
  </div>

  <div id="screenSummary" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Round Complete</h2>
      <p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
      <div class="grid" id="holeBreakdown"></div>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
    </div>
  </div>

  <div id="screenSettings" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Settings</h2>
      <div class="grid">
        <label class="chip" style="justify-content:space-between">
          <span>Reduced motion</span>
          <input type="checkbox" id="chkReduced" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Audio (minimal ambience)</span>
          <input type="checkbox" id="chkAudio" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Wind (toggle)</span>
          <input type="checkbox" id="chkWind" checked />
        </label>
      </div>
      <p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
      <div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
    </div>
  </div>

  <div id="landscapeHint"><div class="card small">For best experience, rotate to landscape.</div></div>

<script>
(function initWhenReady(){
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', main, { once:true });
  } else {
    main();
  }

  function main(){
    const TAU = Math.PI*2;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let globalTime = 0;

    // ===== UI Elements
    const elHole = document.getElementById('holeNum');
    const elHolesTotal = document.getElementById('holesTotal');
    const elPar = document.getElementById('parLabel');
    const elStrokes = document.getElementById('strokes');
    const elWindVal = document.getElementById('windVal');
    const elWindArrow = document.getElementById('windArrow');
    const elPowermeter = document.getElementById('powermeter');
    const elPowerfill = document.getElementById('powerfill');
    const clubSeg = document.getElementById('clubSeg');
    const spinSeg = document.getElementById('spinSeg');

    const screenIntro = document.getElementById('screenIntro');
    const screenSummary = document.getElementById('screenSummary');
    const screenSettings = document.getElementById('screenSettings');
    const btnPlay = document.getElementById('btnPlay');
    const btnPlayAgain = document.getElementById('btnPlayAgain');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnSettings = document.getElementById('btnSettings');
    const btnCloseSettings = document.getElementById('btnCloseSettings');
    const chkReduced = document.getElementById('chkReduced');
    const chkAudio = document.getElementById('chkAudio');
    const chkWind = document.getElementById('chkWind');

    const sumStrokes = document.getElementById('sumStrokes');
    const sumPar = document.getElementById('sumPar');
    const sumScore = document.getElementById('sumScore');
    const holeBreakdown = document.getElementById('holeBreakdown');

    // ===== Game Config & State (side-view)
    const HOLES_PER_ROUND = 3; elHolesTotal.textContent = HOLES_PER_ROUND;
    const WORLD = { w: 3400, h: 950 }; // world size in px
    let view = { x:0, y:0, w:0, h:0 };

    const CLUBS = [
      { id:'DRV', name:'Driver', loft:12, power:1.00, roll:1.00 },
      { id:'3W',  name:'3W',     loft:15, power:0.92, roll:0.95 },
      { id:'5I',  name:'5I',     loft:28, power:0.78, roll:0.85 },
      { id:'7I',  name:'7I',     loft:34, power:0.70, roll:0.78 },
      { id:'9I',  name:'9I',     loft:42, power:0.62, roll:0.70 },
      { id:'WDG', name:'Wedge',  loft:56, power:0.50, roll:0.55 },
      { id:'PUT', name:'Putter', loft:2,  power:0.35, roll:0.20 }
    ];

    // Surface behavior (arcade)
    const SURF = {
      fairway: { fric: 420, rest: 0.35 },
      rough:   { fric: 700, rest: 0.28, powerMul: 0.85 },
      sand:    { fric: 980, rest: 0.18, powerMul: 0.65 },
      green:   { fric: 260, rest: 0.30 },
      rock:    { fric: 260, rest: 0.55 }
    };

    const GRAV = 3000;      // px/s^2 (arcade-y)
    const AIR_DRAG = 0.002; // mild
    let reducedMotion = false;

    // Wind: ax in px/s^2 (can be negative)
    let windOn = true; let windAx = 0; // set per-hole

    // Spin: -1 back, 0 neutral, 1 top
    let spinMode = 0;

    // ---------- Deterministic helpers (to stop jitter) ----------
    const RAND_MAX = 4294967295;
    function hash32(x){ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return x>>>0; }
    function rand01(seed, i){ return hash32((seed ^ (i|0))>>>0) / RAND_MAX; }

    // Audio (minimal)
    const AudioMini = (()=>{
      let ctx=null, windNode=null, masterGain=null; let enabled=false;
      function init(){
        if(enabled) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = ctx.createGain(); masterGain.gain.value=0.18; masterGain.connect(ctx.destination);
        const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
        const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
        const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(masterGain); o1.start(); o2.start();
        const buff = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
        const data = buff.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
        const noise = ctx.createBufferSource(); noise.buffer=buff; noise.loop=true;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=400;
        const wg = ctx.createGain(); wg.gain.value=0.05; noise.connect(lp); lp.connect(wg); wg.connect(masterGain); noise.start();
        windNode = wg; enabled=true; if(!windOn) wg.gain.value=0.0;
      }
      function setEnabled(on){ if(on){init();} else { if(masterGain){masterGain.gain.value=0;} } }
      function thwack(){ if(!enabled) return; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(220, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(60, ctx.currentTime+0.15); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.18); o.connect(g); g.connect(masterGain); o.start(); o.stop(ctx.currentTime+0.2);} 
      function cup(){ if(!enabled) return; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(660, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(990, ctx.currentTime+0.08); g.gain.setValueAtTime(0.2, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.3); o.connect(g); g.connect(masterGain); o.start(); o.stop(ctx.currentTime+0.35);} 
      function setWind(on){ if(!enabled||!windNode) return; windNode.gain.value = on?0.05:0.0; }
      return { setEnabled, thwack, cup, setWind };
    })();

    // Particles
    const particles=[];
    function spawnParticles(type, x, y, count){
      for(let i=0;i<count;i++){
        const a = Math.random()*TAU; const sp = (type==='spark'? 160 + Math.random()*160 : 80+Math.random()*120);
        const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp - (type==='spark'?0:200);
        particles.push({ type, x, y, vx, vy, life: type==='spark'? 0.25: (type==='sand'?0.5:0.6) });
      }
    }

    // World data
    let holeIndex=0, roundData=null; // {holes:[...], totals}
    let hole=null; // current hole data

    // Backdrop + Sky
    const backdrop = { seed:(Math.random()*1e9)|0, rays:[], mountains:[], stars:[], clouds:[], moon:null, landmarks:[] };

    // ===== SKY / BACKDROP BUILD =====
    function buildBackdrop(){
      // Rays (kept for subtle depth; columns fixed in space; only opacity breathes)
      backdrop.rays.length=0; const rc=7;
      for(let i=0;i<rc;i++){
        const u = (i+0.5)/rc + (rand01(backdrop.seed,i)-0.5)*0.12; // normalized x
        const wU = 0.04 + rand01(backdrop.seed,i*3+1)*0.08;       // normalized width
        const phase = rand01(backdrop.seed,i*5+2)*TAU;
        const amp = 0.05 + rand01(backdrop.seed,i*7+3)*0.06;
        backdrop.rays.push({u,wU,phase,amp});
      }
      // Mountain layers (far->near)
      backdrop.mountains = [
        makeLayer(0.18, 0.50, 90, 40, 0.0011, 0.00047, 0.06),
        makeLayer(0.28, 0.60, 120, 52, 0.0015, 0.00063, 0.08),
        makeLayer(0.42, 0.68, 140, 64, 0.0019, 0.00085, 0.10)
      ];
      buildSkyElements();
      buildLandmarks();
    }
    function makeLayer(parallax, baseFrac, a1, a2, f1, f2, shade){
      const s = (backdrop.seed ^ hash32((parallax*1000)|0))>>>0;
      const base = WORLD.h*baseFrac; const ph = rand01(s,1)*TAU;
      return { parallax, base, a1, a2, f1, f2, ph, shade };
    }
    function mountainYAt(L, wx){
      return L.base - Math.sin(wx*L.f1)*L.a1 - Math.sin(wx*L.f2 + L.ph)*L.a2;
    }

    function buildSkyElements(){
      // Stars
      const starSeed = backdrop.seed ^ 0x51A5;
      const count = 200;
      backdrop.stars = [];
      for(let i=0;i<count;i++){
        const u = rand01(starSeed, i*3+1);
        const v = rand01(starSeed, i*3+2);
        const x = Math.floor(u * WORLD.w);
        const y = Math.floor(v * WORLD.h*0.48); // upper half
        const r = 0.6 + rand01(starSeed, i*5+3)*1.1;
        const phase = rand01(starSeed, i*7+4)*TAU;
        const rate = 0.25 + rand01(starSeed, i*11+5)*0.45; // Hz-ish
        const base = 0.10 + rand01(starSeed, i*13+6)*0.10; // faint base alpha
        backdrop.stars.push({x,y,r,phase,rate,base});
      }
      // Moon (seeded position, very slow drift)
      const mSeed = backdrop.seed ^ 0xC0FEE;
      const mu = 0.25 + rand01(mSeed,1)*0.5;  // 0.25..0.75
      const mv = 0.08 + rand01(mSeed,2)*0.16; // 0.08..0.24
      const mr = 22 + rand01(mSeed,3)*12;
      const phase = rand01(mSeed,4)*TAU;
      backdrop.moon = { x: mu*WORLD.w, y: mv*WORLD.h, r: mr, phase };
      // Clouds: 1‚Äì2 slow bands
      const cSeed = backdrop.seed ^ 0xA11D;
      const bands = (rand01(cSeed,1) < 0.6) ? 2 : 1;
      backdrop.clouds = [];
      for(let i=0;i<bands;i++){
        const yFrac = 0.18 + rand01(cSeed, 10+i)*0.26; // height in sky
        const speed = 8 + rand01(cSeed, 20+i)*12; // px/s base
        const par = 0.22 + rand01(cSeed,30+i)*0.18;
        const puffSeed = cSeed ^ hash32(1000+i);
        backdrop.clouds.push({ yFrac, speed, parallax:par, puffSeed });
      }
    }

    function buildLandmarks(){
      // Occasional windmills, lone trees, lighthouse, distant city ‚Äî seeded and stable for the hole
      const L = [];
      const lSeed = backdrop.seed ^ 0x1AND;
      const count = 4 + Math.floor(rand01(lSeed,1)*3); // 4‚Äì6
      for(let i=0;i<count;i++){
        const u = 0.15 + (i+1)/(count+1)*0.7 + (rand01(lSeed,10+i)-0.5)*0.08; // spread across world
        const x = clamp(u*WORLD.w, 120, WORLD.w-120);
        const typeRand = rand01(lSeed, 100+i);
        let type = 'tree';
        if(typeRand < 0.25) type='windmill';
        else if(typeRand < 0.45) type='lighthouse';
        else if(typeRand < 0.62) type='city';
        else type='tree';
        L.push({ x, type, seed: (lSeed ^ hash32(i+3))>>>0 });
      }
      backdrop.landmarks = L;
    }

    // Ball
    const ball = { x:0,y:0,vx:0,vy:0,r:7, atRest:true, onGround:true, lastSafe:{x:0,y:0} };
    let strokes=0;

    // Input/aim
    let aiming=false; let aimAngle=0; let meter=0; let meterDir=1; let meterOn=false; let pointerId=null; let pointerPos={x:0,y:0};
    const METER_SPEED=1.6; // cycles per second (ping-pong)

    // Camera follow (side-view)
    function centerCameraOnBall(){
      if(!hole){ return; }
      view.x = clamp(ball.x - view.w*0.45, 0, WORLD.w - view.w);
      view.y = clamp(groundYAt(ball.x) - view.h*0.65, 0, WORLD.h - view.h);
    }

    // Helpers
    function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // ===== Procedural hole generation (side-view friendly)
    function genHole(){
      const w = WORLD.w, h = WORLD.h; const step=40; const baseY = h*0.72; const points=[]; let x=0; let s = (Math.random()*1e9)|0;
      // keep seed on hole for determinism of sky/landmarks
      const seed = s;
      function nrand(){ s = Math.sin(s)*10000; return s - Math.floor(s); }
      const amp1 = 90 + nrand()*70, freq1 = 1/(620+ nrand()*380);
      const amp2 = 30 + nrand()*30, freq2 = 1/(260 + nrand()*200);

      for(x=0;x<=w;x+=step){ const y = baseY - Math.sin(x*freq1)*amp1 - Math.sin(x*freq2)*amp2; points.push({x,y}); }

      // Cup to right
      const cupX = lerp(w*0.68, w*0.9, Math.random());

      // Green platform: flatten and slightly tilt
      const gWidth = 260; const gx0=cupX-gWidth/2, gx1=cupX+gWidth/2; const slope = (Math.random()*0.6-0.3); let greenY=0;
      for(let i=0;i<points.length;i++){
        if(points[i].x>=gx0 && points[i].x<=gx1){ const t = (points[i].x-gx0)/gWidth; const gy = (baseY-30) + slope*(t-0.5)*40; points[i].y = gy; greenY = gy; }
      }

      // Water hazard mid field
      const waterW = 220 + Math.random()*220; const waterX = lerp(w*0.28, cupX-420, Math.random()); const waterY = baseY - 28 + 10*Math.random();
      const water = {x:waterX, y:waterY, w:waterW, h:h - waterY + 60};

      // Sand near green
      const sand = { x: cupX - 110 + Math.random()*160, y: greenY - 10, r: 60 + Math.random()*28 };

      // Tee slight platform
      const teeX = 120; const teeIdx = Math.floor(teeX/step); const teeY = points[teeIdx].y - 2; points[teeIdx].y = teeY;

      // Ensure some cliffs/ledges (side-view feel): deepen a valley randomly
      const valleyX = lerp(w*0.42, w*0.6, Math.random()); const vIdx = Math.floor(valleyX/step);
      for(let i=-3;i<=3;i++){ const k=vIdx+i; if(points[k]) points[k].y += Math.abs(i)*22; }

      // Par estimate
      const dist = (cupX - teeX); let par = 4; if(dist>1900) par=5; else if(dist<950) par=3;

      return { w, h, points, step, cupX, green:{x0:gx0,x1:gx1,y:greenY}, water, sand, tee:{x:teeX,y:teeY}, par, seed };
    }

    // Ground sampling (linear interp)
    function groundYAt(x){ x = clamp(x, 0, hole.w); const i = clamp(Math.floor(x/hole.step), 0, hole.points.length-2); const p0 = hole.points[i], p1 = hole.points[i+1]; const t = (x - p0.x)/(p1.x - p0.x); return lerp(p0.y, p1.y, t); }

    function surfaceAt(x){
      if(x>=hole.green.x0 && x<=hole.green.x1) return 'green';
      const dxSand = x - hole.sand.x; const y = groundYAt(x); if(Math.hypot(dxSand, y - hole.sand.y) <= hole.sand.r) return 'sand';
      return 'fairway';
    }
    function inWater(x,y){ const w = hole.water; return x>=w.x && x<=w.x+w.w && y>=w.y; }

    // ===== Round setup
    function newRound(){ holeIndex=0; roundData={ holes:[], totalPar:0, totalStrokes:0 }; screenIntro.style.display='none'; screenSummary.style.display='none'; nextHole(); }

    function nextHole(){
      hole = genHole(); roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par; elHole.textContent = (holeIndex+1); elPar.textContent = hole.par;
      // Wind
      if(windOn){ windAx = (Math.random()*2 - 1) * 900; } else { windAx = 0; } updateWindUI();
      // Position ball
      ball.x = hole.tee.x; ball.y = hole.tee.y - ball.r - 1; ball.vx=0; ball.vy=0; ball.atRest=true; ball.onGround=true; ball.lastSafe={x:ball.x,y:ball.y}; strokes=0; elStrokes.textContent=strokes;
      // Seed backdrop/sky from hole seed for stability
      backdrop.seed = (hole.seed ^ 0x5EA)|0;
      buildBackdrop();
      centerCameraOnBall();
    }

    function endHole(){
      roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes; holeIndex++;
      if(holeIndex>=HOLES_PER_ROUND){
        sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar; const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
        holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
        screenSummary.style.display='grid';
      } else { nextHole(); }
    }

    // ===== UI build: clubs & spin
    function buildClubs(){
      clubSeg.innerHTML=''; CLUBS.forEach((c,idx)=>{ const b=document.createElement('button'); b.className='btn'; b.textContent=c.name; b.dataset.club=idx; b.setAttribute('aria-pressed', idx===2? 'true':'false'); b.addEventListener('click',()=>selectClub(idx)); clubSeg.appendChild(b); });
      selectClub(2); // default 7I
    }
    let currentClub = CLUBS[2];
    function selectClub(i){ currentClub = CLUBS[i]; [...clubSeg.querySelectorAll('button')].forEach((b,idx)=> b.setAttribute('aria-pressed', idx===i? 'true':'false')); }
    spinSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; spinMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });

    // ===== Wind UI
    function updateWindUI(){ const dir = windAx>=0? 1:-1; const mag = Math.abs(windAx); elWindVal.textContent = (mag/900).toFixed(1)+'x'; elWindArrow.style.transform = `rotate(${dir>0?0:180}deg)`; }

    // ===== Input (drag aim + hold-release meter)
    function worldToScreen(x,y){ return { x: (x - view.x)*DPR, y: (y - view.y)*DPR }; }
    function screenToWorld(x,y){ return { x: x/DPR + view.x, y: y/DPR + view.y }; }
    function onPointerDown(e){ if(!hole || !ball.atRest) return; const p = getPoint(e); pointerId = p.id; pointerPos={x:p.x,y:p.y}; const w = screenToWorld(p.x, p.y); aimAngle = Math.atan2((w.y - ball.y), (w.x - ball.x)); aiming = true; meterOn = true; meter = 0; meterDir=1; elPowermeter.dataset.on='1'; e.preventDefault(); }
    function onPointerMove(e){ if(!aiming) return; const p = getPoint(e); pointerPos={x:p.x,y:p.y}; const w = screenToWorld(p.x, p.y); aimAngle = Math.atan2((w.y - ball.y), (w.x - ball.x)); }
    function onPointerUp(e){ if(!aiming) return; aiming=false; meterOn=false; elPowermeter.dataset.on='0'; shoot(); pointerId=null; }
    function getPoint(e){ if(e.changedTouches){ const t=e.changedTouches[0]; return { id:t.identifier, x:t.clientX*DPR, y:t.clientY*DPR }; } return { id:'mouse', x:e.clientX*DPR, y:e.clientY*DPR }; }
    canvas.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive:false}); window.addEventListener('touchmove', onPointerMove, {passive:false}); window.addEventListener('touchend', onPointerUp);

    // ===== Shooting
    function shoot(){
      if(!hole || !ball.atRest) return; const club = currentClub;
      if(club.id==='PUT' && !(ball.x>=hole.green.x0 && ball.x<=hole.green.x1)){ selectClub(2); }
      const surface = surfaceAt(ball.x); let powerMul = 1.0; if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
      const base = 1400; const power = (0.25 + 0.75*meter) * club.power * powerMul; const speed = base * power; const loftRad = club.loft * Math.PI/180; const dir = aimAngle;
      ball.vx = Math.cos(dir) * speed * Math.cos(loftRad); ball.vy = Math.sin(dir) * speed * Math.cos(loftRad) - Math.sin(loftRad) * speed;
      if(surface!=='fairway' && surface!=='green'){ const jitter = 0.06; ball.vx *= (1 + (Math.random()*2-1)*jitter); ball.vy *= (1 + (Math.random()*2-1)*jitter); }
      ball.atRest=false; ball.onGround=false; strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; if(navigator.vibrate) navigator.vibrate(20); AudioMini.thwack();
    }

    // ===== Physics update
    function update(dt){
      // time
      globalTime += dt;

      // power meter ping-pong
      if(meterOn){ meter += meterDir * METER_SPEED * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width = (meter*100).toFixed(1)+'%'; }
      if(!hole){ return; }

      // particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.vy += 1200*dt; p.vx*= (1-0.4*dt); p.vy*=(1-0.06*dt); p.x += p.vx*dt; p.y += p.vy*dt; }

      if(!ball.atRest){
        if(!ball.onGround){
          const ax = (windOn? windAx:0) - AIR_DRAG*ball.vx* Math.sign(ball.vx); const ay = GRAV - AIR_DRAG*ball.vy* Math.sign(ball.vy);
          ball.vx += ax*dt; ball.vy += ay*dt; ball.x += ball.vx*dt; ball.y += ball.vy*dt;
          const gy = groundYAt(ball.x);
          if(ball.y + ball.r >= gy){
            const surface = surfaceAt(ball.x); const rest = SURF[surface]?.rest ?? 0.35; ball.y = gy - ball.r - 0.01; ball.onGround=true;
            if(Math.abs(ball.vy) > 120){ if(surface==='sand') spawnParticles('sand', ball.x, ball.y+ball.r, 12); else spawnParticles('dust', ball.x, ball.y+ball.r, 8); }
            ball.vy = -ball.vy * rest; if(spinMode!==0){ const spinBoost = (spinMode>0? 1 : -1) * 120; ball.vx += spinBoost; }
            if(Math.abs(ball.vy) < 120){ ball.vy = 0; }
          }
        } else {
          const gy = groundYAt(ball.x); if(ball.y + ball.r < gy-0.5){ ball.onGround=false; } else {
            ball.y = gy - ball.r; const surface = surfaceAt(ball.x); const fric = SURF[surface]?.fric ?? 420; const speed = Math.abs(ball.vx); const dec = fric * (surface==='green' && currentClub.id==='PUT'?0.7:1); const sgn = Math.sign(ball.vx); let newSpeed = speed - dec*dt; if(newSpeed<0) newSpeed=0; ball.vx = sgn * newSpeed; ball.x += ball.vx*dt; if(Math.abs(ball.vx) < 8){ ball.vx=0; ball.atRest=true; ball.onGround=true; ball.lastSafe={x:ball.x,y:ball.y}; }
          }
        }
        if(inWater(ball.x, ball.y+ball.r*0.6)){ spawnParticles('splash', ball.x, ball.y, 16); if(navigator.vibrate) navigator.vibrate([40,40,30]); strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; ball.x = ball.lastSafe.x - 24; ball.y = groundYAt(ball.x)-ball.r; ball.vx=0; ball.vy=0; ball.atRest=true; ball.onGround=true; }
        if(ball.x<0){ ball.x=0; ball.vx=0; } if(ball.x>hole.w){ ball.x=hole.w; ball.vx=0; }
        const cx = hole.cupX; const dx = Math.abs(ball.x - cx);
        if(dx < 10 && ball.onGround && Math.abs(ball.vx) < 160){ AudioMini.cup(); if(navigator.vibrate) navigator.vibrate([25,25,25]); ball.atRest=true; ball.vx=0; ball.vy=0; setTimeout(()=>{ endHole(); }, 550); }
      }
      centerCameraOnBall();
    }

    // ===== Rendering
    function draw(){
      ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
      drawSkyGradient();
      drawStars();
      drawMoon();
      drawClouds();
      drawMountains();
      if(!hole){ drawVignette(); return; }
      // water
      const w = hole.water; ctx.fillStyle = '#0e2233'; ctx.fillRect((w.x - view.x), (w.y - view.y), w.w, hole.h - w.y + 80);
      // ground silhouette path
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fg'); ctx.beginPath(); ctx.moveTo(hole.points[0].x - view.x, hole.h - view.y + 100);
      for(const p of hole.points){ ctx.lineTo(p.x - view.x, p.y - view.y); }
      ctx.lineTo(hole.points[hole.points.length-1].x - view.x, hole.h - view.y + 100); ctx.closePath(); ctx.fill();
      // ambient landmarks on ground
      drawLandmarks();

      // grass
      drawGrass();
      // sand bunker
      ctx.fillStyle = '#1b160f'; ctx.beginPath(); ctx.arc(hole.sand.x - view.x, hole.sand.y - view.y, hole.sand.r, 0, TAU); ctx.fill();
      // green subtle overlay
      ctx.fillStyle = 'rgba(60,140,85,.25)'; ctx.fillRect(hole.green.x0 - view.x, hole.green.y - 2 - view.y, (hole.green.x1 - hole.green.x0), 10);

      // flag (with wind flutter)
      drawFlag(hole.cupX - view.x, groundYAt(hole.cupX) - 60 - view.y);

      // particles
      for(const p of particles){
        let c = '#ffffff';
        if(p.type==='spark') c = getComputedStyle(document.documentElement).getPropertyValue('--accent');
        else if(p.type==='sand') c = '#b48a5a';
        else if(p.type==='dust') c = '#9aa2aa';
        else if(p.type==='splash') c = '#49d0ff';
        ctx.globalAlpha = Math.max(0, p.life/0.6); ctx.fillStyle=c;
        ctx.beginPath(); ctx.arc(p.x - view.x, p.y - view.y, 2.2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
      }

      // ball + aim
      drawBall(); if(aiming){ drawAimArrow(); }
      drawVignette();
    }

    // --- Sky gradient
    function drawSkyGradient(){
      const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height/DPR); const cs = getComputedStyle(document.documentElement);
      skyGrad.addColorStop(0, cs.getPropertyValue('--bg3').trim()); skyGrad.addColorStop(0.55, cs.getPropertyValue('--bg2').trim()); skyGrad.addColorStop(1, cs.getPropertyValue('--bg1').trim());
      ctx.fillStyle = skyGrad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    }

    // --- Stars (fixed-seed, faint sine twinkle)
    function drawStars(){
      if(!backdrop.stars) return;
      const par = 0.06; // very slow parallax
      for(const s of backdrop.stars){
        const x = s.x - view.x*par;
        const y = s.y - view.y*par*0.3;
        if(x<-5 || x>view.w+5 || y<-5 || y>view.h*0.65+10) continue;
        const tw = s.base + 0.12*Math.sin((globalTime*s.rate*TAU) + s.phase);
        ctx.globalAlpha = Math.max(0, Math.min(0.35, tw));
        ctx.fillStyle = '#e6f2ff';
        ctx.beginPath();
        ctx.arc(x, y, s.r, 0, TAU);
        ctx.fill();
      }
      ctx.globalAlpha=1;
    }

    // --- Moon with subtle halo and very slow drift
    function drawMoon(){
      if(!backdrop.moon) return;
      const m = backdrop.moon;
      const driftX = Math.sin(globalTime*0.02 + m.phase)*12; // very slow
      const driftY = Math.cos(globalTime*0.015 + m.phase*0.7)*4;
      const par = 0.08;
      const mx = (m.x + driftX) - view.x*par;
      const my = (m.y + driftY) - view.y*par*0.3;

      // Halo
      const g = ctx.createRadialGradient(mx,my, m.r*0.4, mx,my, m.r*3.2);
      g.addColorStop(0,'rgba(255,255,255,0.25)');
      g.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mx,my, m.r*3.2, 0, TAU); ctx.fill();

      // Moon disk
      ctx.fillStyle = '#f8fafc';
      ctx.beginPath(); ctx.arc(mx,my, m.r, 0, TAU); ctx.fill();

      // Slight shading crescent
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.beginPath(); ctx.arc(mx+m.r*0.15, my, m.r*0.95, 0, TAU); ctx.fill();
    }

    // --- Clouds (1‚Äì2 parallax bands, backlit & semi-transparent)
    function drawClouds(){
      for(const B of backdrop.clouds){
        const y = WORLD.h*B.yFrac - view.y*B.parallax*0.4;
        const speed = (reducedMotion? 0.3 : 1) * (B.speed + (windOn? (windAx/900)*8 : 0));
        const offset = (globalTime*speed) % (view.w+400);
        const alpha = 0.08;
        const light = 'rgba(255,255,255,'+alpha+')';
        // Draw repeated puffs across width
        for(let x=-400; x<view.w+400; x+=120){
          const px = x - offset - view.x*B.parallax*0.6;
          drawCloudPuff(px, y, 120, 38, light, B.puffSeed, x);
        }
      }
    }
    function drawCloudPuff(cx, cy, w, h, color, seed, idx){
      // a few overlapping ellipses, deterministic offsets
      ctx.fillStyle = color;
      for(let i=0;i<5;i++){
        const u = (rand01(seed, idx*31+i)-0.5)*0.8;
        const v = (rand01(seed, idx*47+i)-0.5)*0.3;
        const rx = w*(0.42 + 0.18*rand01(seed, idx*59+i));
        const ry = h*(0.55 + 0.2*rand01(seed, idx*61+i));
        ctx.beginPath();
        roundedEllipse(cx + u*w*0.5, cy + v*h*0.5, rx, ry);
        ctx.fill();
      }
    }
    function roundedEllipse(x,y,rx,ry){
      ctx.ellipse(x,y,rx,ry,0,0,TAU);
    }

    // --- Mountains (3 parallax layers)
    function drawMountains(){
      const w = canvas.width/DPR, h = canvas.height/DPR; const step=8;
      backdrop.mountains.forEach((L, idx)=>{
        ctx.fillStyle = `rgba(0,0,0,${0.25 + L.shade})`;
        ctx.beginPath(); ctx.moveTo(0,h);
        for(let x=0;x<=w;x+=step){ const wx = view.x*L.parallax + x; const y = mountainYAt(L, wx) - view.y*0.08*idx; ctx.lineTo(x, y); }
        ctx.lineTo(w,h); ctx.closePath(); ctx.fill();
      });
    }

    // --- Grass (curved blades, deterministic; avoids shimmer)
    const GRASS_STEP = 26;      // spacing between clusters
    const GRASS_DENSITY = 3;    // blades per cluster
    function drawGrass(){
      if(!hole){ return; }
      ctx.save(); ctx.strokeStyle='rgba(0,0,0,.9)'; ctx.lineWidth=1;
      const start = Math.floor((view.x-40)/GRASS_STEP)*GRASS_STEP; const end = view.x + view.w + 40;
      for(let wx=start; wx<end; wx+=GRASS_STEP){
        const gx = clamp(wx,0,hole.w); const gy = groundYAt(gx) - view.y; if(gy< -20 || gy > canvas.height/DPR+20) continue;
        for(let k=0;k<GRASS_DENSITY;k++){
          const idx = ((gx|0)*7 + k)|0; const h = 7 + rand01(backdrop.seed ^ 0xabc123, idx)*10; const lean = (rand01(backdrop.seed ^ 0x55aa55, idx+13)-0.5)*8;
          const baseX = gx - view.x + (k-1)*(2 + rand01(backdrop.seed ^ 0x999,idx+21)*2);
          ctx.beginPath(); ctx.moveTo(baseX, gy);
          const ctrlX = baseX + lean*0.45; const ctrlY = gy - h*0.55; const tipX = baseX + lean; const tipY = gy - h;
          ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();
        }
      }
      ctx.restore();
    }

    // --- Landmarks (seeded, stable)
    function drawLandmarks(){
      const fg = getComputedStyle(document.documentElement).getPropertyValue('--fg');
      ctx.fillStyle = fg; ctx.strokeStyle = fg; ctx.lineWidth = 2;
      for(const L of backdrop.landmarks){
        const gx = L.x - view.x;
        if(gx < -120 || gx > view.w+120) continue;
        const gy = groundYAt(L.x) - view.y;
        if(L.type === 'tree'){ drawTree(gx, gy, L.seed); }
        else if(L.type === 'windmill'){ drawWindmill(gx, gy, L.seed); }
        else if(L.type === 'lighthouse'){ drawLighthouse(gx, gy, L.seed); }
        else if(L.type === 'city'){ drawCitySil(gx, gy, L.seed); }
      }
    }
    function drawTree(x, y, s){
      const h = 46 + rand01(s,1)*24;
      // trunk
      ctx.fillRect(x-3, y-h*0.6, 6, h*0.6);
      // canopy
      ctx.beginPath();
      ctx.arc(x, y-h*0.75, h*0.35, 0, TAU); ctx.fill();
      ctx.beginPath();
      ctx.arc(x-12, y-h*0.62, h*0.28, 0, TAU); ctx.fill();
      ctx.beginPath();
      ctx.arc(x+12, y-h*0.62, h*0.28, 0, TAU); ctx.fill();
    }
    function drawWindmill(x, y, s){
      const h = 70 + rand01(s,2)*30;
      // tower
      ctx.beginPath();
      ctx.moveTo(x-8, y); ctx.lineTo(x, y-h); ctx.lineTo(x+8, y); ctx.closePath(); ctx.fill();
      // hub
      const hubY = y - h; const hubR = 3.5;
      ctx.beginPath(); ctx.arc(x, hubY, hubR, 0, TAU); ctx.fill();
      // blades rotate with wind magnitude + base
      const windMag = Math.abs(windAx)/900;
      const omega = (0.4 + 1.2*windMag) * (windAx>=0?1:-1);
      const ang = globalTime*omega;
      drawBlade(x, hubY, ang, 22);
      drawBlade(x, hubY, ang+TAU/3, 22);
      drawBlade(x, hubY, ang+2*TAU/3, 22);
    }
    function drawBlade(x,y,ang,len){
      ctx.save();
      ctx.translate(x,y); ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(0,0); ctx.lineTo(len,2); ctx.lineTo(len, -2); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    function drawLighthouse(x,y,s){
      const h = 86 + rand01(s,3)*24;
      // base
      ctx.fillRect(x-6, y-h*0.55, 12, h*0.55);
      // top cap
      ctx.fillRect(x-8, y-h*0.70, 16, 6);
      // tiny rotating beam (very subtle, backlit feel)
      const beamAng = (globalTime*0.4 + s)%TAU;
      const bx0 = x, by0 = y-h*0.68;
      ctx.save();
      ctx.globalAlpha = 0.07;
      ctx.beginPath();
      ctx.moveTo(bx0,by0);
      ctx.lineTo(bx0 + Math.cos(beamAng)*120, by0 + Math.sin(beamAng)*40);
      ctx.lineTo(bx0 + Math.cos(beamAng)*120, by0 + Math.sin(beamAng)*(-40));
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.restore();
    }
    function drawCitySil(x,y,s){
      // cluster of boxes behind immediate ground line
      const n = 4 + Math.floor(rand01(s,4)*4);
      ctx.save();
      for(let i=0;i<n;i++){
        const w = 12 + rand01(s,50+i)*18;
        const h = 30 + rand01(s,60+i)*38;
        const dx = -40 + i*(w+6) + (rand01(s,70+i)-0.5)*10;
        ctx.fillRect(x+dx, y-h, w, h);
      }
      ctx.restore();
    }

    function drawBall(){ const cs = getComputedStyle(document.documentElement); const trailColor = cs.getPropertyValue('--accent'); if(!ball.atRest && Math.hypot(ball.vx,ball.vy)>320){ ctx.strokeStyle = trailColor; ctx.globalAlpha = 0.25; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(ball.x - view.x, ball.y - view.y); ctx.lineTo(ball.x - ball.vx*0.05 - view.x, ball.y - ball.vy*0.05 - view.y); ctx.stroke(); ctx.globalAlpha=1; } ctx.fillStyle = '#f8fafc'; ctx.beginPath(); ctx.arc(ball.x - view.x, ball.y - view.y, ball.r, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,.4)'; ctx.lineWidth=1; ctx.stroke(); }

    function drawAimArrow(){ const b = worldToScreen(ball.x, ball.y); const len = 80 + meter*160; const x2 = b.x + Math.cos(aimAngle)*len; const y2 = b.y + Math.sin(aimAngle)*len; ctx.save(); ctx.scale(DPR,DPR); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent3'); ctx.lineWidth=3; ctx.globalAlpha=0.9; ctx.beginPath(); ctx.moveTo(b.x/DPR, b.y/DPR); ctx.lineTo(x2/DPR, y2/DPR); ctx.stroke(); const a=aimAngle; const ah = 10; const aw = 7; ctx.beginPath(); ctx.moveTo(x2/DPR, y2/DPR); ctx.lineTo((x2 - Math.cos(a)*ah + Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah - Math.cos(a)*aw)/DPR); ctx.lineTo((x2 - Math.cos(a)*ah - Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah + Math.cos(a)*aw)/DPR); ctx.closePath(); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.fill(); ctx.restore(); }

    function drawFlag(flagX, flagY){
      // pole
      ctx.strokeStyle = 'rgba(255,255,255,.7)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(flagX, flagY); ctx.lineTo(flagX, flagY+60); ctx.stroke();

      // cloth with wind flutter (Bezier chain)
      const dir = (windAx>=0)? 1 : -1;
      const mag = Math.min(1, Math.abs(windAx)/900);
      const len = 26 + mag*10;
      const amp = 2 + mag*6;
      const t = globalTime * (1.8 + mag*1.4);
      const base = { x:flagX, y:flagY+2 };

      const p1 = { x: base.x + dir*(len*0.4), y: base.y + Math.sin(t+0.0)*amp*0.4 };
      const p2 = { x: base.x + dir*(len*0.8), y: base.y + Math.sin(t+0.6)*amp*0.7 };
      const tip= { x: base.x + dir*(len*1.0), y: base.y + Math.sin(t+1.2)*amp };

      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent2');

      ctx.beginPath();
      ctx.moveTo(base.x, base.y);
      ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
      ctx.lineTo(p2.x, p2.y+8);
      ctx.quadraticCurveTo(p1.x, p1.y+8, base.x, base.y+8);
      ctx.closePath();
      ctx.fill();

      // little tip triangle for sharpness
      ctx.beginPath();
      ctx.moveTo(p2.x, p2.y);
      ctx.lineTo(tip.x, tip.y+4);
      ctx.lineTo(p2.x, p2.y+8);
      ctx.closePath();
      ctx.fill();
    }

    function drawVignette(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.2,w*0.5,h*0.55,Math.max(w,h)*0.7); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h); }

    // ===== Resize
    function resize(){ DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); view.w = canvas.width/DPR; view.h = canvas.height/DPR; /* keep seed, just rebuild geometry */ buildBackdrop(); }
    window.addEventListener('resize', resize); resize();

    // ===== Main loop
    let last=0; function loop(t){ const now=t/1000; const dt = Math.min(0.033, last? now-last: 0.016); last=now; update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

    // ===== UI wiring
    btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; newRound(); });
    btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; newRound(); });
    btnNewRound.addEventListener('click', ()=>{ newRound(); });
    btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
    btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });
    chkReduced.addEventListener('change', ()=>{ reducedMotion = chkReduced.checked; });
    chkAudio.addEventListener('change', ()=>{ AudioMini.setEnabled(chkAudio.checked); });
    chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; AudioMini.setWind(windOn); updateWindUI(); });

    // Build initial UI
    buildClubs(); updateWindUI();

    // ====== Self-tests (run manually in console: DuskDriveTests.run())
    window.DuskDriveTests = {
      run(){
        let ok=0, fail=0;
        function test(name, fn){ try{ fn(); console.log('%c‚úî '+name,'color:#10b981'); ok++; } catch(e){ console.error('‚úñ '+name, e); fail++; } }
        test('No hole -> update/draw do not throw', ()=>{ update(0.016); draw(); });
        test('Start round -> update/draw work', ()=>{ newRound(); update(0.016); draw(); });
        test('Backdrop builds and draws with sky', ()=>{ buildBackdrop(); drawSkyGradient(); drawStars(); drawMoon(); drawClouds(); drawMountains(); });
        console.log(`Tests finished: ${ok} passed, ${fail} failed.`);
      }
    };
  }
})();
</script>
</body>
</html>
