<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Dusk Drive ‚Äî Side-View Silhouette Golf (v2.3.2)</title>
<style>
  :root{
    /* defaults; overridden per biome at runtime */
    --bg1:#a54720; --bg2:#f38e41; --bg3:#ffe6ba; --water:#30160f;
    --fg:#050607; --text:#e6edf3; --muted:#a9b1ba;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(5,6,7,.65); --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1000px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}
  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .small{font-size:.9rem;color:var(--muted)}
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}
  @media (orientation:portrait){ #landscapeHint{display:flex} }
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Dusk Drive side-view game canvas"></canvas></div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="topbar">
      <div class="row">
        <div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
        <div class="chip"><span class="label">Par</span> <strong id="parLabel">4</strong></div>
        <div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
      </div>
      <div class="row">
        <div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="panel controls">
        <div class="seg" id="clubSeg" role="group" aria-label="Club select"></div>
        <div class="seg" id="spinSeg" role="group" aria-label="Spin select">
          <button class="btn" data-spin="-1" aria-pressed="false" title="Backspin">‚≠≥</button>
          <button class="btn" data-spin="0" aria-pressed="true" title="Neutral">‚Ä¢</button>
          <button class="btn" data-spin="1" aria-pressed="false" title="Topspin">‚≠±</button>
        </div>
        <button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
      </div>
    </div>

    <div class="powermeter" id="powermeter" aria-hidden="true"><div class="fill" id="powerfill"></div></div>
  </div>

  <!-- Screens -->
  <div id="screenIntro" class="screen" role="dialog" aria-modal="true">
    <div class="card">
      <h1>üèåÔ∏è‚Äç‚ôÇÔ∏è Dusk Drive</h1>
      <div class="sub">2D side-view silhouette golf. Drag to aim, hold to charge, release to shoot.</div>
      <div class="grid">
        <div class="tag">Hold-Release Meter</div>
        <div class="tag">Wind & Spin</div>
        <div class="tag">Procedural Holes</div>
        <div class="tag">Rotating Biomes</div>
      </div>
      <p class="small" style="margin-top:.7rem">Best in landscape ‚Ä¢ Mobile-friendly ‚Ä¢ Haptics on impact</p>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlay">Start Round</button></div>
    </div>
  </div>

  <div id="screenSummary" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Round Complete</h2>
      <p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
      <div class="grid" id="holeBreakdown"></div>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
    </div>
  </div>

  <div id="screenSettings" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Settings</h2>
      <div class="grid">
        <label class="chip" style="justify-content:space-between">
          <span>Reduced motion</span>
          <input type="checkbox" id="chkReduced" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Audio (minimal ambience)</span>
          <input type="checkbox" id="chkAudio" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Wind (toggle)</span>
          <input type="checkbox" id="chkWind" checked />
        </label>
      </div>
      <p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
      <div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
    </div>
  </div>

  <div id="landscapeHint"><div class="card small">For best experience, rotate to landscape.</div></div>

<script>
(function initWhenReady(){
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', main, { once:true });
  } else { main(); }

  function main(){
    const TAU = Math.PI*2;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // ===== UI Elements
    const elHole = document.getElementById('holeNum');
    const elHolesTotal = document.getElementById('holesTotal');
    const elPar = document.getElementById('parLabel');
    const elStrokes = document.getElementById('strokes');
    const elWindVal = document.getElementById('windVal');
    const elWindArrow = document.getElementById('windArrow');
    const elPowermeter = document.getElementById('powermeter');
    const elPowerfill = document.getElementById('powerfill');
    const clubSeg = document.getElementById('clubSeg');
    const spinSeg = document.getElementById('spinSeg');

    const screenIntro = document.getElementById('screenIntro');
    const screenSummary = document.getElementById('screenSummary');
    const screenSettings = document.getElementById('screenSettings');
    const btnPlay = document.getElementById('btnPlay');
    const btnPlayAgain = document.getElementById('btnPlayAgain');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnSettings = document.getElementById('btnSettings');
    const btnCloseSettings = document.getElementById('btnCloseSettings');
    const chkReduced = document.getElementById('chkReduced');
    const chkAudio = document.getElementById('chkAudio');
    const chkWind = document.getElementById('chkWind');

    const sumStrokes = document.getElementById('sumStrokes');
    const sumPar = document.getElementById('sumPar');
    const sumScore = document.getElementById('sumScore');
    const holeBreakdown = document.getElementById('holeBreakdown');

    // ===== Game Config & State
    const HOLES_PER_ROUND = 3; elHolesTotal.textContent = HOLES_PER_ROUND;
    const WORLD = { w: 3400, h: 950 };
    let view = { x:0, y:0, w:0, h:0 };

    const CLUBS = [
      { id:'DRV', name:'Driver', loft:12, power:1.00, roll:1.00 },
      { id:'3W',  name:'3W',     loft:15, power:0.92, roll:0.95 },
      { id:'5I',  name:'5I',     loft:28, power:0.78, roll:0.85 },
      { id:'7I',  name:'7I',     loft:34, power:0.70, roll:0.78 },
      { id:'9I',  name:'9I',     loft:42, power:0.62, roll:0.70 },
      { id:'WDG', name:'Wedge',  loft:56, power:0.50, roll:0.55 },
      { id:'PUT', name:'Putter', loft:2,  power:0.35, roll:0.20 }
    ];

    const SURF = {
      fairway: { fric: 420, rest: 0.35 },
      rough:   { fric: 700, rest: 0.28, powerMul: 0.85 },
      sand:    { fric: 980, rest: 0.18, powerMul: 0.65 },
      green:   { fric: 260, rest: 0.30 },
      rock:    { fric: 260, rest: 0.55 }
    };

    const GRAV = 3000;
    const AIR_DRAG = 0.002;
    let reducedMotion = false;

    // Wind
    let windOn = true; let windAx = 0;

    // Spin: -1 back, 0 neutral, 1 top
    let spinMode = 0;

    // ---------- Deterministic helpers ----------
    const RAND_MAX = 4294967295;
    function hash32(x){ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return x>>>0; }
    function rand01(seed, i){ return hash32((seed ^ (i|0))>>>0) / RAND_MAX; }

    // Audio (minimal)
    const AudioMini = (()=>{
      let ctx=null, windNode=null, masterGain=null; let enabled=false;
      function init(){
        if(enabled) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = ctx.createGain(); masterGain.gain.value=0.18; masterGain.connect(ctx.destination);
        const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
        const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
        const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(masterGain); o1.start(); o2.start();
        const buff = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
        const data = buff.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
        const noise = ctx.createBufferSource(); noise.buffer=buff; noise.loop=true;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=400;
        const wg = ctx.createGain(); wg.gain.value=0.05; noise.connect(lp); lp.connect(wg); wg.connect(masterGain); noise.start();
        windNode = wg; enabled=true; if(!windOn) wg.gain.value=0.0;
      }
      function setEnabled(on){ if(on){init();} else { if(masterGain){masterGain.gain.value=0;} } }
      function thwack(){ if(!enabled) return; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(220, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(60, ctx.currentTime+0.15); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.18); o.connect(g); g.connect(masterGain); o.start(); o.stop(ctx.currentTime+0.2);} 
      function cup(){ if(!enabled) return; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(660, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(990, ctx.currentTime+0.08); g.gain.setValueAtTime(0.2, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.3); o.connect(g); g.connect(masterGain); o.start(); o.stop(ctx.currentTime+0.35);} 
      function setWind(on){ if(!enabled||!windNode) return; windNode.gain.value = on?0.05:0.0; }
      return { setEnabled, thwack, cup, setWind };
    })();

    // Particles
    const particles=[];
    function spawnParticles(type, x, y, count){
      for(let i=0;i<count;i++){
        const a = Math.random()*TAU; const sp = (type==='spark'? 160 + Math.random()*160 : 80+Math.random()*120);
        const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp - (type==='spark'?0:200);
        particles.push({ type, x, y, vx, vy, life: type==='spark'? 0.25: (type==='sand'?0.5:0.6) });
      }
    }

    // === Biomes (colors + mountain profiles) ===
    const BIOMES = [
      { name:'dunes',
        sky:{ bg1:'#9d3e25', bg2:'#f38e41', bg3:'#ffe6ba', water:'#30160f' },
        layers:[
          {par:0.08, base:0.52, a1:30,  a2:16,  f1:0.00050, f2:0.00020, shade:0.02, shape:'sin'},
          {par:0.12, base:0.56, a1:50,  a2:24,  f1:0.00065, f2:0.00026, shade:0.035,shape:'sin'},
          {par:0.18, base:0.61, a1:70,  a2:34,  f1:0.00082, f2:0.00032, shade:0.05, shape:'sin'},
          {par:0.26, base:0.66, a1:104, a2:48,  f1:0.00100, f2:0.00042, shade:0.07, shape:'sin'},
          {par:0.33, base:0.70, a1:116, a2:54,  f1:0.00115, f2:0.00048, shade:0.085,shape:'sin'},
          {par:0.40, base:0.74, a1:126, a2:58,  f1:0.00125, f2:0.00052, shade:0.10, shape:'sin'}
        ]
      },
      { name:'crags',
        sky:{ bg1:'#5b1a2b', bg2:'#d5425a', bg3:'#f8c3da', water:'#2c0f19' },
        layers:[
          {par:0.06, base:0.50, a1:60,  a2:36,  f1:0.00055, f2:0.00022, shade:0.02, shape:'crag'},
          {par:0.10, base:0.58, a1:95,  a2:52,  f1:0.00075, f2:0.00030, shade:0.05, shape:'crag'},
          {par:0.16, base:0.64, a1:140, a2:70,  f1:0.00095, f2:0.00040, shade:0.08, shape:'crag'},
          {par:0.24, base:0.70, a1:170, a2:86,  f1:0.00115, f2:0.00055, shade:0.11,shape:'crag'},
          {par:0.36, base:0.76, a1:190, a2:96,  f1:0.00135, f2:0.00065, shade:0.13,shape:'crag'}
        ]
      },
      { name:'hills',
        sky:{ bg1:'#233d6d', bg2:'#5d79b0', bg3:'#cfe2ff', water:'#0e2233' },
        layers:[
          {par:0.10, base:0.54, a1:36,  a2:18,  f1:0.00044, f2:0.00018, shade:0.02, shape:'round'},
          {par:0.16, base:0.60, a1:60,  a2:28,  f1:0.00062, f2:0.00024, shade:0.04, shape:'round'},
          {par:0.22, base:0.66, a1:90,  a2:42,  f1:0.00080, f2:0.00032, shade:0.06, shape:'round'},
          {par:0.30, base:0.71, a1:115, a2:56,  f1:0.00098, f2:0.00040, shade:0.08, shape:'round'},
          {par:0.38, base:0.75, a1:132, a2:64,  f1:0.00112, f2:0.00048, shade:0.10, shape:'round'}
        ]
      },
      { name:'mesas',
        sky:{ bg1:'#6e3b1b', bg2:'#cf7b35', bg3:'#ffe1b0', water:'#2a1a12' },
        layers:[
          {par:0.08, base:0.54, a1:42,  a2:20,  f1:0.00058, f2:0.00022, shade:0.02, shape:'mesa'},
          {par:0.13, base:0.60, a1:70,  a2:32,  f1:0.00076, f2:0.00030, shade:0.04, shape:'mesa'},
          {par:0.20, base:0.66, a1:96,  a2:46,  f1:0.00096, f2:0.00038, shade:0.06, shape:'mesa'},
          {par:0.28, base:0.72, a1:120, a2:56,  f1:0.00116, f2:0.00046, shade:0.08, shape:'mesa'},
          {par:0.36, base:0.76, a1:140, a2:64,  f1:0.00128, f2:0.00054, shade:0.10, shape:'mesa'}
        ]
      }
    ];
    const LEVELS = BIOMES.map(b=>b.name);

    function applyTheme(biome){
      const root = document.documentElement.style;
      root.setProperty('--bg1', biome.sky.bg1);
      root.setProperty('--bg2', biome.sky.bg2);
      root.setProperty('--bg3', biome.sky.bg3);
      root.setProperty('--water', biome.sky.water);
    }

    // Backdrop (parallax + sun + clouds + far landmarks + flocks)
    let currentBiome = BIOMES[0];
    const backdrop = {
      seed:(Math.random()*1e9)|0,
      mountains:[],
      sun:null,
      clouds:[],
      cloudDir:1,
      landmarksFar:[],
      flocks:[]
    };

    // Shape helpers
    function triangleWave(x){ return (2/Math.PI)*Math.asin(Math.sin(x)); }
    function mesaWave(x){ const k=2.2; return Math.tanh(Math.sin(x)*k)/Math.tanh(k); }
    function roundWave(x){ const s=Math.sin(x); return Math.sign(s)*Math.pow(Math.abs(s),0.85); }
    function cragWave(x){ return 0.7*triangleWave(x) + 0.3*Math.sin(x*3.0); }
    function shapeSample(shape, x){
      switch(shape){
        case 'mesa':   return mesaWave(x);
        case 'round':  return roundWave(x);
        case 'crag':   return cragWave(x);
        case 'sin':
        default:       return Math.sin(x);
      }
    }

    function buildBackdrop(){
      const L = [];
      currentBiome.layers.forEach((spec, i)=>{
        const s = (backdrop.seed ^ hash32((spec.par*1000)|0) ^ i)>>>0;
        const base = WORLD.h*spec.base;
        const ph   = rand01(s,1)*TAU;
        const curv = { a: 10 + rand01(s,3)*16, f: 0.0012 + rand01(s,4)*0.0006, ph: rand01(s,2)*TAU };
        L.push({ parallax:spec.par, base, a1:spec.a1, a2:spec.a2, f1:spec.f1, f2:spec.f2, ph, shade:spec.shade, curv, shape:spec.shape });
      });
      backdrop.mountains = L;

      // Sun
      const u = 0.20 + rand01(backdrop.seed,101)*0.60;
      const v = 0.16 + rand01(backdrop.seed,102)*0.20;
      const phase = rand01(backdrop.seed,103)*TAU;
      const baseR = 20 + Math.floor(rand01(backdrop.seed,104)*12);
      backdrop.sun = { u, v, phase, baseR };

      // Clouds
      backdrop.cloudDir = rand01(backdrop.seed,399) < 0.5 ? -1 : 1;
      buildCloudField();
      if(hole) buildLandmarks();

      // Flocks (seeded per hole)
      buildFlocks();
    }

    function buildCloudField(){
      backdrop.clouds.length = 0;
      const count = 3 + Math.floor(rand01(backdrop.seed,300)*4); // 3‚Äì6
      for(let i=0;i<count;i++){
        const s = hash32(backdrop.seed ^ (0xA11C10 + i*131));
        const u = rand01(s,1);
        const v = 0.12 + (i+1)/(count+1) * 0.42 + (rand01(s,2)-0.5)*0.05;
        const parX = 0.04 + rand01(s,3)*0.05;
        const parY = 0.015 + rand01(s,4)*0.02;
        const speed = backdrop.cloudDir * (4 + rand01(s,6)*6);
        const alpha = 0.05 + rand01(s,7)*0.08;
        const scale = 0.9 + rand01(s,8)*1.6;
        backdrop.clouds.push({ seed:s, u, v, parX, parY, speed, alpha, scale });
      }
    }

    function mountainYAt(L, wx){
      let y = L.base
        - shapeSample(L.shape, wx*L.f1)*L.a1
        - shapeSample(L.shape, wx*L.f2 + L.ph)*L.a2;
      if(L.curv){
        y -= Math.sin(wx*L.curv.f   + L.curv.ph)      * L.curv.a;
        y -= Math.sin(wx*L.curv.f*2 + L.curv.ph*1.3) * (L.curv.a*0.45);
      }
      return y;
    }

    // ---- Ambient Landmarks (far only)
    function buildLandmarks(){
      backdrop.landmarksFar = [];
      if(!hole) return;

      const exRanges = [
        [hole.green.x0-160, hole.green.x1+160],
        [hole.water.x-140, hole.water.x+hole.water.w+140]
      ];
      function allowedX(x){
        for(const r of exRanges){ if(x>=r[0] && x<=r[1]) return false; }
        return x>60 && x < (hole.w-60);
      }
      function pickX(k){
        let tries=0;
        while(tries++<40){
          const t = rand01(backdrop.seed, 800 + k*31 + tries*7);
          const x = 120 + t*(WORLD.w-240);
          if(allowedX(x)) return x;
        }
        return 200 + (k%10)*260;
      }

      const farPar = currentBiome.layers[0].par; // match far ridge parallax

      // FAR windmills (0‚Äì2)
      const wmCount = Math.floor(rand01(backdrop.seed, 921) * 2.2);
      for(let i=0;i<wmCount;i++){
        const x = pickX(20+i);
        const sc = 0.85 + rand01(backdrop.seed, 931+i)*0.45;
        const varSeed = hash32(backdrop.seed ^ (0x91AA + i));
        const spin = 0.25 + rand01(backdrop.seed, 941+i)*0.35;
        backdrop.landmarksFar.push({ type:'windmill', x, scale:sc, seed:varSeed, spin, parX:farPar, parY:0 });
      }

      // FAR lighthouse (0‚Äì1) near water
      if(rand01(backdrop.seed, 951) < 0.35){
        let x = hole.water.x + (rand01(backdrop.seed, 952)<0.5 ? -120 : hole.water.w+120);
        x = Math.min(Math.max(80, x), WORLD.w-80);
        if(allowedX(x)){
          const sc = 0.55 + rand01(backdrop.seed, 953)*0.25;
          const varSeed = hash32(backdrop.seed ^ 0xC0A5);
          backdrop.landmarksFar.push({ type:'lighthouse', x, scale:sc, seed:varSeed, parX:farPar, parY:0 });
        }
      }
    }

    // ===== Flocks (far sky, seeded, wind-driven)
    function buildFlocks(){
      backdrop.flocks.length = 0;
      if(!backdrop.mountains.length) return;
      const farPar = backdrop.mountains[0].parallax;

      const count = 1 + Math.floor(rand01(backdrop.seed,1200)*3); // 1‚Äì3 flocks
      for(let i=0;i<count;i++){
        const s = hash32(backdrop.seed ^ (0xF10C + i*97));
        const x = WORLD.w * rand01(s,1);
        const y = WORLD.h * (0.18 + rand01(s,2)*0.26);
        const dir = rand01(s,3) < 0.5 ? -1 : 1; // fallback heading when no wind
        const birds = [];
        const n = 6 + Math.floor(rand01(s,4)*10); // 6‚Äì15 birds

        // V-formation offsets + flap params
        for(let k=0;k<n;k++){
          const row = (k>>1) + 1;
          const wing = (k%2===0)? -1 : 1;
          const ox = wing * row * (10 + rand01(s,10+k)*4);
          const oy = row * (6 + rand01(s,20+k)*2);
          const sc = 0.65 + rand01(s,30+k)*0.5;
          const ph = rand01(s,60+k)*TAU;              // seeded phase
          const baseHz = 2.2 + rand01(s,70+k)*2.0;    // 2.2‚Äì4.2 Hz
          birds.push({ ox, oy, sc, ph, baseHz });
        }

        backdrop.flocks.push({
          seed:s,
          x, y,
          vx: dir * 18,
          vy: 0,
          dir,
          phase: rand01(s,5)*TAU,
          parX: farPar,
          parY: farPar*0.55,
          birds
        });
      }
    }

    function updateFlocks(dt){
      if(!backdrop.flocks.length) return;
      const windNorm = windOn ? Math.max(-1, Math.min(1, windAx/900)) : 0;
      const speedBase = (reducedMotion? 10: 18);
      const speedWind = (reducedMotion? 18: 32) * Math.abs(windNorm);

      for(const F of backdrop.flocks){
        const targetDir = (Math.abs(windNorm) > 0.05) ? Math.sign(windNorm) : F.dir;
        const targetVx = (speedBase + speedWind) * targetDir;

        // Smooth toward target to avoid pops when wind toggles
        F.vx += (targetVx - F.vx) * (1 - Math.exp(-dt*3));
        F.vy = Math.sin(clock*0.9 + F.phase) * (reducedMotion? 1.2 : 2.2);

        F.x += F.vx * dt;
        F.y += F.vy * dt;

        const margin = 140;
        if(F.x > WORLD.w + margin){ F.x = -margin; }
        if(F.x < -margin){ F.x = WORLD.w + margin; }

        // keep within a sky band
        const yMin = WORLD.h*0.12, yMax = WORLD.h*0.52;
        if(F.y < yMin) F.y = yMin + 4;
        if(F.y > yMax) F.y = yMax - 4;
      }
    }

    function drawFlocks(){
      if(!backdrop.flocks.length) return;

      ctx.save();
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(0,0,0,0.48)';

      const w = canvas.width / DPR, h = canvas.height / DPR;

      for(const F of backdrop.flocks){
        const angle = Math.atan2(F.vy, (F.vx||0.0001)); // flight heading
        const cx = F.x - view.x * F.parX;
        const cy = F.y - view.y * F.parY;

        // cull
        if(cx < -180 || cx > w + 180 || cy < -120 || cy > h + 120) continue;

        const cosA = Math.cos(angle), sinA = Math.sin(angle);

        for(const b of F.birds){
          // rotate formation offsets to follow heading
          const rx = b.ox * cosA - b.oy * sinA;
          const ry = b.ox * sinA + b.oy * cosA;
          const bx = cx + rx * 0.8;
          const by = cy + ry * 0.8;

          // flap (Hz -> rad/s via TAU)
          const hz = b.baseHz * (reducedMotion ? 0.45 : 1.0);
          const flap = Math.sin(clock * hz * TAU + b.ph);

          // wing open angle and length
          const baseOpen = 0.45;                 // ~26¬∞
          const flapAmp  = reducedMotion ? 0.18 : 0.42;
          const open = baseOpen + flap * flapAmp;

          const len = 6.0 * b.sc;                // tiny silhouettes

          // wings trail slightly behind the heading
          const leftDir  = angle + Math.PI - open;
          const rightDir = angle + Math.PI + open;

          const lx = bx + Math.cos(leftDir)  * len;
          const ly = by + Math.sin(leftDir)  * len;
          const rx2 = bx + Math.cos(rightDir) * len;
          const ry2 = by + Math.sin(rightDir) * len;

          ctx.beginPath();
          ctx.moveTo(bx, by); ctx.lineTo(lx, ly);
          ctx.moveTo(bx, by); ctx.lineTo(rx2, ry2);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ===== World / Hole
    const ball = { x:0,y:0,vx:0,vy:0,r:7, atRest:true, onGround:true, lastSafe:{x:0,y:0} };
    let strokes=0;
    let holeIndex=0, roundData=null;
    let hole=null;

    // Aim/meter state
    let aiming=false, aimAngle=0, meter=0, meterDir=1, meterOn=false;

    function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function genHole(){
      const w = WORLD.w, h = WORLD.h; const step=40; const baseY = h*0.72; const points=[]; let x=0; let seed = Math.random()*9999;
      function nrand(){ seed = Math.sin(seed)*10000; return seed - Math.floor(seed); }
      const amp1 = 90 + nrand()*70, freq1 = 1/(620+ nrand()*380);
      const amp2 = 30 + nrand()*30, freq2 = 1/(260 + nrand()*200);

      for(x=0;x<=w;x+=step){ const y = baseY - Math.sin(x*freq1)*amp1 - Math.sin(x*freq2)*amp2; points.push({x,y}); }

      const cupX = lerp(w*0.68, w*0.9, Math.random());

      const gWidth = 260; const gx0=cupX-gWidth/2, gx1=cupX+gWidth/2; const slope = (Math.random()*0.6-0.3); let greenY=0;
      for(let i=0;i<points.length;i++){
        if(points[i].x>=gx0 && points[i].x<=gx1){ const t = (points[i].x-gx0)/gWidth; const gy = (baseY-30) + slope*(t-0.5)*40; points[i].y = gy; greenY = gy; }
      }

      const waterW = 220 + Math.random()*220; const waterX = lerp(w*0.28, cupX-420, Math.random()); const waterY = baseY - 28 + 10*Math.random();
      const water = {x:waterX, y:waterY, w:waterW, h:h - waterY + 60};

      const sand = { x: cupX - 110 + Math.random()*160, y: greenY - 10, r: 60 + Math.random()*28 };

      const teeX = 120; const teeIdx = Math.floor(teeX/step); const teeY = points[teeIdx].y - 2; points[teeIdx].y = teeY;

      const valleyX = lerp(w*0.42, w*0.6, Math.random()); const vIdx = Math.floor(valleyX/step);
      for(let i=-3;i<=3;i++){ const k=vIdx+i; if(points[k]) points[k].y += Math.abs(i)*22; }

      const dist = (cupX - teeX); let par = 4; if(dist>1900) par=5; else if(dist<950) par=3;

      return { w, h, points, step, cupX, green:{x0:gx0,x1:gx1,y:greenY}, water, sand, tee:{x:teeX,y:teeY}, par };
    }

    function groundYAt(x){ x = clamp(x, 0, hole.w); const i = clamp(Math.floor(x/hole.step), 0, hole.points.length-2); const p0 = hole.points[i], p1 = hole.points[i+1]; const t = (x - p0.x)/(p1.x - p0.x); return lerp(p0.y, p1.y, t); }
    function surfaceAt(x){
      if(x>=hole.green.x0 && x<=hole.green.x1) return 'green';
      const dxSand = x - hole.sand.x; const y = groundYAt(x); if(Math.hypot(dxSand, y - hole.sand.y) <= hole.sand.r) return 'sand';
      return 'fairway';
    }
    function inWater(x,y){ const w = hole.water; return x>=w.x && x<=w.x+w.w && y>=w.y; }

    // ===== Round flow
    function newRound(){ holeIndex=0; roundData={ holes:[], totalPar:0, totalStrokes:0 }; screenIntro.style.display='none'; screenSummary.style.display='none'; nextHole(); }

    function nextHole(){
      const biome = BIOMES[holeIndex % BIOMES.length];
      currentBiome = biome;
      applyTheme(biome);

      hole = genHole();
      backdrop.seed = (Math.random()*1e9)|0; // per-hole
      buildBackdrop();

      roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par;
      elHole.textContent = (holeIndex+1); elPar.textContent = hole.par;

      windAx = windOn ? (Math.random()*2 - 1) * 900 : 0; updateWindUI();
      ball.x = hole.tee.x; ball.y = hole.tee.y - ball.r - 1; ball.vx=0; ball.vy=0; ball.atRest=true; ball.onGround=true; ball.lastSafe={x:ball.x,y:ball.y}; strokes=0; elStrokes.textContent=strokes;
      centerCameraOnBall();
    }

    function endHole(){
      roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes; holeIndex++;
      if(holeIndex>=HOLES_PER_ROUND){
        sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar; const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
        holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
        screenSummary.style.display='grid';
      } else { nextHole(); }
    }

    // ===== UI build: clubs & spin
    function buildClubs(){
      clubSeg.innerHTML='';
      CLUBS.forEach((c,idx)=>{
        const b=document.createElement('button'); b.className='btn'; b.textContent=c.name; b.dataset.club=idx;
        b.setAttribute('aria-pressed', idx===2? 'true':'false');
        b.addEventListener('click',()=>selectClub(idx));
        clubSeg.appendChild(b);
      });
      selectClub(2); // default 7I
    }
    let currentClub = CLUBS[2];
    function selectClub(i){ currentClub = CLUBS[i]; [...clubSeg.querySelectorAll('button')].forEach((b,idx)=> b.setAttribute('aria-pressed', idx===i? 'true':'false')); }
    spinSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; spinMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });

    // ===== Wind UI
    function updateWindUI(){ const dir = windAx>=0? 1:-1; const mag = Math.abs(windAx); elWindVal.textContent = (mag/900).toFixed(1)+'x'; elWindArrow.style.transform = `rotate(${dir>0?0:180}deg)`; }

    // ===== Input
    function worldToScreen(x,y){ return { x: (x - view.x)*DPR, y: (y - view.y)*DPR }; }
    function screenToWorld(x,y){ return { x: x/DPR + view.x, y: y/DPR + view.y }; }
    function onPointerDown(e){ if(!hole || !ball.atRest) return; const p = getPoint(e); const w=screenToWorld(p.x,p.y); aimAngle = Math.atan2((w.y - ball.y), (w.x - ball.x)); aiming = true; meterOn = true; meter = 0; meterDir=1; elPowermeter.dataset.on='1'; e.preventDefault(); }
    function onPointerMove(e){ if(!aiming) return; const p = getPoint(e); const w=screenToWorld(p.x,p.y); aimAngle = Math.atan2((w.y - ball.y), (w.x - ball.x)); }
    function onPointerUp(e){ if(!aiming) return; aiming=false; meterOn=false; elPowermeter.dataset.on='0'; shoot(); }
    function getPoint(e){ if(e.changedTouches){ const t=e.changedTouches[0]; return { x:t.clientX*DPR, y:t.clientY*DPR }; } return { x:e.clientX*DPR, y:e.clientY*DPR }; }
    canvas.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive:false}); window.addEventListener('touchmove', onPointerMove, {passive:false}); window.addEventListener('touchend', onPointerUp);

    // ===== Shooting
    function shoot(){
      if(!hole || !ball.atRest) return; const club = currentClub;
      if(club.id==='PUT' && !(ball.x>=hole.green.x0 && ball.x<=hole.green.x1)){ selectClub(2); }
      const surface = surfaceAt(ball.x); let powerMul = 1.0; if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
      const base = 1400; const power = (0.25 + 0.75*meter) * club.power * powerMul; const speed = base * power; const loftRad = club.loft * Math.PI/180; const dir = aimAngle;
      ball.vx = Math.cos(dir) * speed * Math.cos(loftRad); ball.vy = Math.sin(dir) * speed * Math.cos(loftRad) - Math.sin(loftRad) * speed;
      if(surface!=='fairway' && surface!=='green'){ const jitter = 0.06; ball.vx *= (1 + (Math.random()*2-1)*jitter); ball.vy *= (1 + (Math.random()*2-1)*jitter); }
      ball.atRest=false; ball.onGround=false; strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; if(navigator.vibrate) navigator.vibrate(20); AudioMini.thwack();
    }

    // ===== Physics update
    function update(dt){
      if(meterOn){ meter += meterDir * 1.6 * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width = (meter*100).toFixed(1)+'%'; }

      // Update flocks (also visible on intro)
      updateFlocks(dt);

      if(!hole){ return; }

      // particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.vy += 1200*dt; p.vx*= (1-0.4*dt); p.vy*=(1-0.06*dt); p.x += p.vx*dt; p.y += p.vy*dt; }

      if(!ball.atRest){
        if(!ball.onGround){
          const ax = (windOn? windAx:0) - AIR_DRAG*ball.vx* Math.sign(ball.vx); const ay = GRAV - AIR_DRAG*ball.vy* Math.sign(ball.vy);
          ball.vx += ax*dt; ball.vy += ay*dt; ball.x += ball.vx*dt; ball.y += ball.vy*dt;
          const gy = groundYAt(ball.x);
          if(ball.y + ball.r >= gy){
            const surface = surfaceAt(ball.x); const rest = SURF[surface]?.rest ?? 0.35; ball.y = gy - ball.r - 0.01; ball.onGround=true;
            if(Math.abs(ball.vy) > 120){ if(surface==='sand') spawnParticles('sand', ball.x, ball.y+ball.r, 12); else spawnParticles('dust', ball.x, ball.y+ball.r, 8); }
            ball.vy = -ball.vy * rest; if(spinMode!==0){ const spinBoost = (spinMode>0? 1 : -1) * 120; ball.vx += spinBoost; }
            if(Math.abs(ball.vy) < 120){ ball.vy = 0; }
          }
        } else {
          const gy = groundYAt(ball.x); if(ball.y + ball.r < gy-0.5){ ball.onGround=false; } else {
            ball.y = gy - ball.r; const surface = surfaceAt(ball.x); const fric = SURF[surface]?.fric ?? 420; const speed = Math.abs(ball.vx); const dec = fric * (surface==='green' && currentClub.id==='PUT'?0.7:1); const sgn = Math.sign(ball.vx); let newSpeed = speed - dec*dt; if(newSpeed<0) newSpeed=0; ball.vx = sgn * newSpeed; ball.x += ball.vx*dt; if(Math.abs(ball.vx) < 8){ ball.vx=0; ball.atRest=true; ball.onGround=true; ball.lastSafe={x:ball.x,y:ball.y}; }
          }
        }
        if(inWater(ball.x, ball.y+ball.r*0.6)){ spawnParticles('splash', ball.x, ball.y, 16); if(navigator.vibrate) navigator.vibrate([40,40,30]); strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; ball.x = ball.lastSafe.x - 24; ball.y = groundYAt(ball.x)-ball.r; ball.vx=0; ball.vy=0; ball.atRest=true; ball.onGround=true; }
        if(ball.x<0){ ball.x=0; ball.vx=0; } if(ball.x>hole.w){ ball.x=hole.w; ball.vx=0; }
        const cx = hole.cupX; const dx = Math.abs(ball.x - cx);
        if(dx < 10 && ball.onGround && Math.abs(ball.vx) < 160){ AudioMini.cup(); if(navigator.vibrate) navigator.vibrate([25,25,25]); ball.atRest=true; ball.vx=0; ball.vy=0; setTimeout(()=>{ endHole(); }, 550); }
      }
      centerCameraOnBall();
    }

    // Camera follow
    function centerCameraOnBall(){
      if(!hole){ return; }
      view.x = clamp(ball.x - view.w*0.45, 0, WORLD.w - view.w);
      view.y = clamp(groundYAt(ball.x) - view.h*0.65, 0, WORLD.h - view.h);
    }

    // ===== Rendering
    function draw(){
      ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
      drawSkyGradient();
      drawSun();
      drawFarLandmarks();
      drawFlocks();          // birds in far sky, before clouds
      drawClouds();
      drawMountains();

      if(!hole){ drawVignette(); return; }

      // water
      const cs = getComputedStyle(document.documentElement);
      ctx.fillStyle = cs.getPropertyValue('--water').trim() || '#30160f';
      const w = hole.water; ctx.fillRect((w.x - view.x), (w.y - view.y), w.w, hole.h - w.y + 80);

      // ground silhouette path (course)
      ctx.fillStyle = cs.getPropertyValue('--fg');
      ctx.beginPath(); ctx.moveTo(hole.points[0].x - view.x, hole.h - view.y + 100);
      for(const p of hole.points){ ctx.lineTo(p.x - view.x, p.y - view.y); }
      ctx.lineTo(hole.points[hole.points.length-1].x - view.x, hole.h - view.y + 100); ctx.closePath(); ctx.fill();

      drawGrass();

      // sand bunker
      ctx.fillStyle = '#1b160f'; ctx.beginPath(); ctx.arc(hole.sand.x - view.x, hole.sand.y - view.y, hole.sand.r, 0, TAU); ctx.fill();

      // green overlay
      ctx.fillStyle = 'rgba(60,140,85,.25)';
      ctx.fillRect(hole.green.x0 - view.x, hole.green.y - 2 - view.y, (hole.green.x1 - hole.green.x0), 10);

      // flag
      const flagX = hole.cupX - view.x; const flagY = groundYAt(hole.cupX) - 60 - view.y;
      ctx.strokeStyle = 'rgba(255,255,255,.7)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(flagX, flagY); ctx.lineTo(flagX, flagY+60); ctx.stroke();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent2');
      ctx.beginPath(); ctx.moveTo(flagX, flagY); ctx.lineTo(flagX+22, flagY+10); ctx.lineTo(flagX, flagY+18); ctx.closePath(); ctx.fill();

      // particles
      for(const p of particles){
        let c = '#ffffff';
        if(p.type==='spark') c = getComputedStyle(document.documentElement).getPropertyValue('--accent');
        else if(p.type==='sand') c = '#b48a5a';
        else if(p.type==='dust') c = '#9aa2aa';
        else if(p.type==='splash') c = '#49d0ff';
        ctx.globalAlpha = Math.max(0, p.life/0.6);
        ctx.fillStyle=c; ctx.beginPath(); ctx.arc(p.x - view.x, p.y - view.y, 2.2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
      }

      drawBall();
      if(aiming){ drawAimArrow(); }

      drawVignette();
    }

    // --- Sky gradient
    function drawSkyGradient(){
      const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height/DPR); const cs = getComputedStyle(document.documentElement);
      skyGrad.addColorStop(0, cs.getPropertyValue('--bg3').trim());
      skyGrad.addColorStop(0.55, cs.getPropertyValue('--bg2').trim());
      skyGrad.addColorStop(1, cs.getPropertyValue('--bg1').trim());
      ctx.fillStyle = skyGrad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    }

    // --- Sun
    function drawSun(){
      const m = backdrop.sun; if(!m) return;
      const parX = 0.05, parY = 0.02;
      const drift = Math.sin(clock*0.05 + m.phase) * 12;
      const xw = WORLD.w * m.u, yw = WORLD.h * m.v;
      const x = (xw - view.x*parX) + drift;
      const y = (yw - view.y*parY);
      const r = m.baseR;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const halo = ctx.createRadialGradient(x, y, r*0.8, x, y, r*4.0);
      halo.addColorStop(0, 'rgba(255,210,130,0.22)');
      halo.addColorStop(1, 'rgba(255,210,130,0.00)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, r*4.0, 0, TAU); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.fillStyle = '#fff2cf';
      ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.10)'; ctx.lineWidth = 1; ctx.stroke();
      ctx.restore();
    }

    // --- FAR landmarks (behind clouds & mountains), anchored to far ridge
    function drawFarLandmarks(){
      if(!backdrop.landmarksFar.length) return;

      const L0 = backdrop.mountains[0];       // farthest layer
      const EMBED = 1.5;                      // push a touch into ridge to avoid gap

      for(const lm of backdrop.landmarksFar){
        const xScreen = lm.x - view.x * lm.parX;
        const ridgeWorldX = view.x * L0.parallax + xScreen;
        const baselineY = mountainYAt(L0, ridgeWorldX) + EMBED;

        if(lm.type==='windmill') drawWindmillFar(xScreen, baselineY, lm.scale, lm.seed, lm.spin);
        else if(lm.type==='lighthouse') drawLighthouseFar(xScreen, baselineY, lm.scale, lm.seed);
      }

      function drawWindmillFar(x, baselineY, s, seed, spin){
        const colBody = 'rgba(0,0,0,0.36)';
        const colDetail = 'rgba(0,0,0,0.42)';
        const towerH = 110*s, wBot=46*s, wTop=26*s, roofH=22*s, stageY=baselineY - towerH*0.55, legOut=10*s;

        // tower
        ctx.fillStyle = colBody;
        ctx.beginPath();
        ctx.moveTo(x - wBot/2, baselineY);
        ctx.lineTo(x + wBot/2, baselineY);
        ctx.lineTo(x + wTop/2, baselineY - towerH);
        ctx.lineTo(x - wTop/2, baselineY - towerH);
        ctx.closePath(); ctx.fill();

        // A-frame legs
        ctx.beginPath();
        ctx.moveTo(x - wBot/2, baselineY);
        ctx.lineTo(x - wBot/2 - legOut, baselineY + 8*s);
        ctx.lineTo(x - wBot/2 - legOut + 3*s, baselineY + 8*s);
        ctx.lineTo(x - wBot/2 + 2*s, baselineY);
        ctx.closePath(); ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x + wBot/2, baselineY);
        ctx.lineTo(x + wBot/2 + legOut, baselineY + 8*s);
        ctx.lineTo(x + wBot/2 + legOut - 3*s, baselineY + 8*s);
        ctx.lineTo(x + wBot/2 - 2*s, baselineY);
        ctx.closePath(); ctx.fill();

        // gallery deck + rails
        const stageW = wBot * 1.35, deckH=5*s;
        ctx.fillStyle = colDetail;
        ctx.fillRect(x - stageW/2, stageY - deckH/2, stageW, deckH);
        ctx.fillRect(x - stageW/2, stageY - deckH - 2*s, stageW, 1.2*s);
        ctx.fillRect(x - stageW/2, stageY + deckH + 1*s, stageW, 1.2*s);
        const posts = 6;
        for(let i=0;i<=posts;i++){
          const px = x - stageW/2 + (stageW/posts)*i;
          ctx.fillRect(px-0.6*s, stageY - deckH - 2*s, 1.2*s, deckH*2 + 3.2*s);
        }

        // roof/cap
        const roofTopY = baselineY - towerH - roofH;
        ctx.beginPath(); ctx.moveTo(x - wTop*0.75, baselineY - towerH);
        ctx.lineTo(x + wTop*0.75, baselineY - towerH);
        ctx.lineTo(x, roofTopY);
        ctx.closePath(); ctx.fill();

        // hub
        const hubY = baselineY - towerH - roofH*0.25, hubR=3.2*s;
        ctx.beginPath(); ctx.arc(x, hubY, hubR, 0, TAU); ctx.fill();

        // sails
        const dir = windAx>=0? 1 : -1;
        const localSpeed = (reducedMotion? 0.08: spin*0.55) * dir;
        const ang0 = clock * localSpeed + rand01(seed,2)*TAU;

        ctx.save();
        ctx.translate(x, hubY);
        ctx.rotate(ang0);

        const bladeLen = 54*s, bladeW = 8*s, rungGap = 10*s, rungW = 1.2*s;

        for(let k=0;k<4;k++){
          const a = k*(TAU/4);
          ctx.save(); ctx.rotate(a);
          ctx.fillStyle = colDetail;
          ctx.fillRect(hubR*0.9, -bladeW*0.5, bladeLen, bladeW);
          ctx.fillStyle = colBody;
          for(let t=rungGap; t<=bladeLen-2*s; t+=rungGap){
            ctx.fillRect(hubR*0.9 + t, -bladeW*0.5, rungW, bladeW);
          }
          ctx.fillRect(hubR*0.9 + bladeLen, -bladeW*0.5, 2.2*s, bladeW);
          ctx.restore();
        }
        ctx.restore();
      }

      function drawLighthouseFar(x, baselineY, s){
        ctx.save();
        const h = 46*s, baseW=10*s, topW=7*s;
        ctx.fillStyle = 'rgba(0,0,0,0.32)';
        ctx.beginPath();
        ctx.moveTo(x - baseW/2, baselineY);
        ctx.lineTo(x + baseW/2, baselineY);
        ctx.lineTo(x + topW/2, baselineY - h);
        ctx.lineTo(x - topW/2, baselineY - h);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.36)';
        ctx.beginPath();
        ctx.moveTo(x - topW*0.7, baselineY - h);
        ctx.lineTo(x + topW*0.7, baselineY - h);
        ctx.lineTo(x, baselineY - h - 5*s);
        ctx.closePath(); ctx.fill();
        ctx.restore();
      }
    }

    // --- Clouds (in front of landmarks)
    function drawClouds(){
      const w = canvas.width / DPR;
      const span = WORLD.w;
      backdrop.clouds.forEach(C=>{
        const baseX = WORLD.w * C.u - clock * C.speed;
        const y = WORLD.h * C.v - view.y * C.parY;
        for(let k=-1; k<=1; k++){
          const x = baseX + k*span - view.x * C.parX;
          if(x < -260 || x > w + 260) continue;
          drawFluffyCloud(x, y, C.scale, C.seed, C.alpha);
        }
      });

      function drawFluffyCloud(x, y, s, seed, alpha){
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.globalAlpha = alpha;
        const baseR = 18 + rand01(seed,50)*22;
        const puffCount = 4 + Math.floor(rand01(seed,11)*4); // 4‚Äì7
        for(let i=0;i<puffCount;i++){
          const r  = (baseR + rand01(seed,20+i)*22) * s;
          const ox = (i - (puffCount-1)/2) * (r*0.55) + (rand01(seed,30+i)-0.5)*r*0.3;
          const oy = (rand01(seed,40+i)-0.5) * r * 0.25;
          const cx = x + ox, cy = y + oy;
          minX = Math.min(minX, cx - r*1.3); maxX = Math.max(maxX, cx + r*1.3);
          minY = Math.min(minY, cy - r*1.2); maxY = Math.max(maxY, cy + r*1.2);
          const g = ctx.createRadialGradient(cx, cy, r*0.35, cx, cy, r*1.3);
          g.addColorStop(0,'rgba(255,255,255,0.55)');
          g.addColorStop(1,'rgba(255,255,255,0.00)');
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r*1.3, 0, TAU); ctx.fill();
        }
        const cxMid = (minX+maxX)/2, cyMid = (minY+maxY)/2;
        const rMax = (maxX-minX)*0.42;
        const core = ctx.createRadialGradient(cxMid, cyMid, rMax*0.1, cxMid, cyMid, rMax);
        core.addColorStop(0,'rgba(255,255,255,0.18)');
        core.addColorStop(1,'rgba(255,255,255,0.00)');
        ctx.fillStyle = core; ctx.beginPath(); ctx.arc(cxMid, cyMid, rMax, 0, TAU); ctx.fill();
        ctx.restore();

        ctx.save(); const shadowR = (maxX - minX) * 0.65;
        const sx = cxMid + shadowR*0.05; const sy = cyMid + (maxY-minY)*0.18;
        const sh = ctx.createRadialGradient(sx, sy, shadowR*0.15, sx, sy, shadowR*1.2);
        sh.addColorStop(0, 'rgba(0,0,0,0.06)'); sh.addColorStop(1, 'rgba(0,0,0,0.00)');
        ctx.fillStyle = sh; ctx.beginPath(); ctx.arc(sx, sy, shadowR*1.2, 0, TAU); ctx.fill(); ctx.restore();
      }
    }

    // --- Mountains (biome-defined layers)
    function drawMountains(){
      const w = canvas.width/DPR, h = canvas.height/DPR;
      backdrop.mountains.forEach((L, idx)=>{
        ctx.fillStyle = `rgba(0,0,0,${0.18 + L.shade})`;
        const step = Math.max(8, 16 - idx*2);
        ctx.beginPath(); ctx.moveTo(0,h);
        for(let x=0;x<=w;x+=step){
          const wx = view.x*L.parallax + x;
          const y = mountainYAt(L, wx) - view.y*0.06*idx;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(w,h); ctx.closePath(); ctx.fill();
      });
    }

    // --- Grass
    const GRASS_STEP = 26, GRASS_DENSITY = 3;
    function drawGrass(){
      if(!hole){ return; }
      ctx.save(); ctx.strokeStyle='rgba(0,0,0,.9)'; ctx.lineWidth=1;
      const start = Math.floor((view.x-40)/GRASS_STEP)*GRASS_STEP; const end = view.x + view.w + 40;
      for(let wx=start; wx<end; wx+=GRASS_STEP){
        const gx = clamp(wx,0,hole.w); const gy = groundYAt(gx) - view.y; if(gy< -20 || gy > canvas.height/DPR+20) continue;
        for(let k=0;k<GRASS_DENSITY;k++){
          const idx = ((gx|0)*7 + k)|0; const hh = 7 + rand01(backdrop.seed ^ 0xabc123, idx)*10; const lean = (rand01(backdrop.seed ^ 0x55aa55, idx+13)-0.5)*8;
          const baseX = gx - view.x + (k-1)*(2 + rand01(backdrop.seed ^ 0x999,idx+21)*2);
          ctx.beginPath(); ctx.moveTo(baseX, gy);
          const ctrlX = baseX + lean*0.45; const ctrlY = gy - hh*0.55; const tipX = baseX + lean; const tipY = gy - hh;
          ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawBall(){ const cs = getComputedStyle(document.documentElement); const trailColor = cs.getPropertyValue('--accent'); if(!ball.atRest && Math.hypot(ball.vx,ball.vy)>320){ ctx.strokeStyle = trailColor; ctx.globalAlpha=0.25; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(ball.x - view.x, ball.y - view.y); ctx.lineTo(ball.x - ball.vx*0.05 - view.x, ball.y - ball.vy*0.05 - view.y); ctx.stroke(); ctx.globalAlpha=1; } ctx.fillStyle = '#f8fafc'; ctx.beginPath(); ctx.arc(ball.x - view.x, ball.y - view.y, ball.r, 0, TAU); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,.4)'; ctx.lineWidth=1; ctx.stroke(); }

    function drawAimArrow(){ const b = worldToScreen(ball.x, ball.y); const len = 80 + meter*160; const x2 = b.x + Math.cos(aimAngle)*len; const y2 = b.y + Math.sin(aimAngle)*len; ctx.save(); ctx.scale(DPR,DPR); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent3'); ctx.lineWidth=3; ctx.globalAlpha=0.9; ctx.beginPath(); ctx.moveTo(b.x/DPR, b.y/DPR); ctx.lineTo(x2/DPR, y2/DPR); ctx.stroke(); const a=aimAngle; const ah = 10; const aw = 7; ctx.beginPath(); ctx.moveTo(x2/DPR, y2/DPR); ctx.lineTo((x2 - Math.cos(a)*ah + Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah - Math.cos(a)*aw)/DPR); ctx.lineTo((x2 - Math.cos(a)*ah - Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah + Math.cos(a)*aw)/DPR); ctx.closePath(); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.fill(); ctx.restore(); }

    function drawVignette(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.2,w*0.5,h*0.55,Math.max(w,h)*0.7); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h); }

    // ===== Resize
    function resize(){ DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); view.w = canvas.width/DPR; view.h = canvas.height/DPR; buildBackdrop(); }
    window.addEventListener('resize', resize); resize();

    // ===== Main loop
    let last=0; let clock=0;
    function loop(t){ const now=t/1000; const dt = Math.min(0.033, last? now-last: 0.016); last=now; clock += dt; update(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // ===== UI wiring
    btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; newRound(); });
    btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; newRound(); });
    btnNewRound.addEventListener('click', ()=>{ newRound(); });
    btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
    btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });
    chkReduced.addEventListener('change', ()=>{ reducedMotion = chkReduced.checked; });
    chkAudio.addEventListener('change', ()=>{ AudioMini.setEnabled(chkAudio.checked); });
    chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; AudioMini.setWind(windOn); updateWindUI(); });

    // Build initial UI
    buildClubs(); updateWindUI();

    // ====== Self-tests (console: DuskDriveTests.run())
    window.DuskDriveTests = {
      run(){
        let ok=0, fail=0;
        function test(name, fn){ try{ fn(); console.log('%c‚úî '+name,'color:#10b981'); ok++; } catch(e){ console.error('‚úñ '+name, e); fail++; } }
        test('No hole -> update/draw do not throw', ()=>{ update(0.016); draw(); });
        test('Start round -> update/draw work', ()=>{ newRound(); update(0.016); draw(); });
        test('Backdrop builds and draws', ()=>{ buildBackdrop(); });
        console.log(`Tests finished: ${ok} passed, ${fail} failed.`);
      }
    };
  }
})();
</script>
</body>
</html>
