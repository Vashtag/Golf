<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Dusk Drive ‚Äî Disc Golf (valley-driven water & sand)</title>
<style>
  :root{
    /* defaults; overridden per biome at runtime */
    --bg1:#a54720; --bg2:#f38e41; --bg3:#ffe6ba; --water:#30160f;
    --fg:#050607; --text:#e6edf3; --muted:#a9b1ba;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(5,6,7,.65); --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .hud .btn{pointer-events:auto}

  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1100px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}
  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .small{font-size:.9rem;color:var(--muted)}
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}
  @media (orientation:portrait){ #landscapeHint{display:flex} }
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Dusk Drive side-view game canvas"></canvas></div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="topbar">
      <div class="row">
        <div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
        <div class="chip"><span class="label">Par</span> <strong id="parLabel">3</strong></div>
        <div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
        <div class="chip" id="bossChip" style="display:none">üåÄ BOSS: Canyon Thermal</div>
      </div>
      <div class="row">
        <div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="panel controls">
        <div class="seg" id="clubSeg" role="group" aria-label="Disc select"></div>
        <div class="seg" id="spinSeg" role="group" aria-label="Release angle">
          <button class="btn" data-spin="-1" aria-pressed="false" title="Hyzer (‚àí15¬∞)">Hyzer</button>
          <button class="btn" data-spin="0"  aria-pressed="true"  title="Flat (0¬∞)">Flat</button>
          <button class="btn" data-spin="1"  aria-pressed="false" title="Anhyzer (+15¬∞)">Anhy</button>
        </div>
        <div class="seg" id="handSeg" role="group" aria-label="Throw style">
          <button class="btn" data-hand="RHBH" aria-pressed="true" title="Right-hand backhand">RHBH</button>
          <button class="btn" data-hand="LHBH" aria-pressed="false" title="Left-hand backhand">LHBH</button>
        </div>
        <button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
      </div>
    </div>

    <div class="powermeter" id="powermeter" aria-hidden="true"><div class="fill" id="powerfill"></div></div>
  </div>

  <!-- Screens -->
  <div id="screenIntro" class="screen" role="dialog" aria-modal="true">
    <div class="card">
      <h1>ü•è Dusk Drive ‚Äî Disc Golf</h1>
      <div class="sub">Drag to aim, hold to charge, release to throw. Hyzer/flat/anhyzer, vertical wind & glide, varied terrain.</div>
      <div class="grid">
        <div class="tag">Drivers ‚Ä¢ Fairways ‚Ä¢ Mids ‚Ä¢ Putters</div>
        <div class="tag">Vertical Wind & Lift</div>
        <div class="tag">Turn/Fade Curve</div>
        <div class="tag">Procedural Holes (+variants)</div>
      </div>
      <p class="small" style="margin-top:.7rem">Best in landscape ‚Ä¢ Mobile-friendly ‚Ä¢ Haptics on chains</p>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlay">Start Round</button></div>
    </div>
  </div>

  <div id="screenSummary" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Round Complete</h2>
      <p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
      <div class="grid" id="holeBreakdown"></div>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
    </div>
  </div>

  <div id="screenSettings" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Settings</h2>
      <div class="grid">
        <label class="chip" style="justify-content:space-between">
          <span>Reduced motion</span>
          <input type="checkbox" id="chkReduced" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Audio (ambience & SFX)</span>
          <input type="checkbox" id="chkAudio" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Wind (toggle)</span>
          <input type="checkbox" id="chkWind" checked />
        </label>
      </div>
      <p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
      <div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
    </div>
  </div>

  <div id="landscapeHint"><div class="card small">For best experience, rotate to landscape.</div></div>

<script>
(function initWhenReady(){
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', main, { once:true });
  } else { main(); }

  function main(){
    const TAU = Math.PI*2;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // ===== UI Elements
    const elHole = document.getElementById('holeNum');
    const elHolesTotal = document.getElementById('holesTotal');
    const elPar = document.getElementById('parLabel');
    const elStrokes = document.getElementById('strokes');
    const elWindVal = document.getElementById('windVal');
    const elWindArrow = document.getElementById('windArrow');
    const elPowermeter = document.getElementById('powermeter');
    const elPowerfill = document.getElementById('powerfill');
    const clubSeg = document.getElementById('clubSeg');
    const spinSeg = document.getElementById('spinSeg');
    const handSeg = document.getElementById('handSeg');

    const screenIntro = document.getElementById('screenIntro');
    const screenSummary = document.getElementById('screenSummary');
    const screenSettings = document.getElementById('screenSettings');
    const btnPlay = document.getElementById('btnPlay');
    const btnPlayAgain = document.getElementById('btnPlayAgain');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnSettings = document.getElementById('btnSettings');
    const btnCloseSettings = document.getElementById('btnCloseSettings');
    const chkReduced = document.getElementById('chkReduced');
    const chkAudio = document.getElementById('chkAudio');
    const chkWind = document.getElementById('chkWind');

    const sumStrokes = document.getElementById('sumStrokes');
    const sumPar = document.getElementById('sumPar');
    const sumScore = document.getElementById('sumScore');
    const holeBreakdown = document.getElementById('holeBreakdown');

    const bossChip = document.getElementById('bossChip');

    // ===== Game Config & State
    const HOLES_PER_ROUND = 3; elHolesTotal.textContent = HOLES_PER_ROUND;
    const WORLD = { w: 3400, h: 950 };
    let view = { x:0, y:0, w:0, h:0 };

    // Discs
    const DISCS = [
      { id:'DRV', name:'Driver',  speed:1.20, glide:1.00, turn:-2.0, fade:2.5 },
      { id:'FAI', name:'Fairway', speed:0.92, glide:1.05, turn:-1.5, fade:2.0 },
      { id:'MID', name:'Mid',     speed:0.80, glide:1.10, turn:-1.0, fade:1.4 },
      { id:'PUT', name:'Putter',  speed:0.62, glide:1.00, turn:-0.3, fade:0.9 }
    ];

    // Surfaces
    const SURF = {
      fairway: { fric: 740,  rest: 0.14 },
      rough:   { fric: 1000, rest: 0.10, powerMul: 0.88 },
      sand:    { fric: 1400, rest: 0.05, powerMul: 0.70 },
      green:   { fric: 520,  rest: 0.10 },
      rock:    { fric: 620,  rest: 0.18 }
    };

    // ==== DISC PHYSICS ====
    const AIR_DRAG = 0.00050;
    const LIFT_K   = 0.00450;
    const NOSE_FAST_DEG = -6;
    const NOSE_SLOW_DEG =  7;

    let reducedMotion = false;

    // ===== Vertical wind (lift only)
    let windOn = true;
    let windLift = 0;             // -1 .. +1 (down .. up)

    // Release angle / throw style
    let releaseMode = 0;
    function releaseDeg(){ return releaseMode * 15; }
    let hand = 'RHBH';

    // ---------- Helpers ----------
    const RAND_MAX = 4294967295;
    function hash32(x){ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return x>>>0; }
    function rand01(seed, i){ return hash32((seed ^ (i|0))>>>0) / RAND_MAX; }
    function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    const ease = (t)=>t*t*(3-2*t);

    // ===== Ambient Audio (minimal hum + wind)
    const AudioMini = (()=>{ let ctx=null, windNode=null, masterGain=null; let enabled=false;
      function init(){ if(enabled) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = ctx.createGain(); masterGain.gain.value=0.18; masterGain.connect(ctx.destination);
        const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
        const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
        const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(masterGain); o1.start(); o2.start();
        const buff = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
        const data = buff.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
        const noise = ctx.createBufferSource(); noise.buffer=buff; noise.loop=true;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=400;
        const wg = ctx.createGain(); wg.gain.value=0.05; noise.connect(lp); lp.connect(wg); wg.connect(masterGain); noise.start();
        windNode = wg; enabled=true; if(!windOn) wg.gain.value=0.0;
      }
      function setEnabled(on){ if(on){init();} else { if(masterGain){masterGain.gain.value=0;} } }
      function setWind(on){ if(!enabled||!windNode) return; windNode.gain.value = on?0.05:0.0; }
      return { setEnabled, setWind };
    })();

    // ===== SFX: randomized throw & chain samples from /audio =====
    const Sfx = (()=>{
      let enabled = false;
      let unlocked = false;
      const throws = [];
      const chains = [];
      function make(path, vol=1.0){ const a = new Audio(path); a.preload = 'auto'; a.volume = vol; return a; }
      function preload(){
        if(throws.length || chains.length) return;
        for(let i=1;i<=7;i++) throws.push(make(`./audio/throw${i}.mp3`, 0.9));
        for(let i=1;i<=4;i++) chains.push(make(`./audio/chain${i}.mp3`, 1.0));
      }
      function init(){ preload(); unlocked = true; }
      function setEnabled(on){
        enabled = !!on;
        if(!enabled){ [...throws, ...chains].forEach(a=>{ try{ a.pause(); a.currentTime = 0; }catch{} }); }
      }
      function playFrom(arr, vol=1.0, rateMin=0.98, rateMax=1.02){
        if(!enabled || !unlocked || !arr.length) return;
        const i = (Math.random()*arr.length)|0;
        const src = arr[i].src || arr[i].currentSrc;
        const a = new Audio(src); a.preload='auto'; a.volume=vol; a.playbackRate = rateMin + Math.random()*(rateMax-rateMin);
        a.play().catch(()=>{});
      }
      return { init, setEnabled, playThrow(){playFrom(throws,0.9,0.97,1.06)}, playChain(){playFrom(chains,1.0,0.96,1.04)} };
    })();

    // Particles
    const particles=[];
    function spawnParticles(type, x, y, count){
      for(let i=0;i<count;i++){
        const a = Math.random()*TAU; const sp = (type==='spark'? 160 + Math.random()*160 : 80+Math.random()*120);
        const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp - (type==='spark'?0:200);
        particles.push({ type, x, y, vx, vy, life: type==='spark'? 0.25: (type==='sand'?0.5:0.6) });
      }
    }

    // === Biomes (colors + mountain profiles) ===
    const BIOMES = [
      { name:'dunes',
        sky:{ bg1:'#9d3e25', bg2:'#f38e41', bg3:'#ffe6ba', water:'#30160f' },
        layers:[
          {par:0.08, base:0.52, a1:30,  a2:16,  f1:0.00050, f2:0.00020, shade:0.02, shape:'sin'},
          {par:0.12, base:0.56, a1:50,  a2:24,  f1:0.00065, f2:0.00026, shade:0.035,shape:'sin'},
          {par:0.18, base:0.61, a1:70,  a2:34,  f1:0.00082, f2:0.00032, shade:0.05, shape:'sin'},
          {par:0.26, base:0.66, a1:104, a2:48,  f1:0.00100, f2:0.00042, shade:0.07,shape:'sin'},
          {par:0.33, base:0.70, a1:116, a2:54,  f1:0.00115, f2:0.00048, shade:0.085,shape:'sin'},
          {par:0.40, base:0.74, a1:126, a2:58,  f1:0.00125, f2:0.00052, shade:0.10, shape:'sin'}
        ]
      },
      { name:'crags',
        sky:{ bg1:'#5b1a2b', bg2:'#d5425a', bg3:'#f8c3da', water:'#2c0f19' },
        layers:[
          {par:0.06, base:0.50, a1:60,  a2:36,  f1:0.00055, f2:0.00022, shade:0.02, shape:'crag'},
          {par:0.10, base:0.58, a1:95,  a2:52,  f1:0.00075, f2:0.00030, shade:0.05, shape:'crag'},
          {par:0.16, base:0.64, a1:140, a2:70,  f1:0.00095, f2:0.00040, shade:0.08, shape:'crag'},
          {par:0.24, base:0.70, a1:170, a2:86,  f1:0.00115, f2:0.00055, shade:0.11,shape:'crag'},
          {par:0.36, base:0.76, a1:190, a2:96,  f1:0.00135, f2:0.00065, shade:0.13,shape:'crag'}
        ]
      },
      { name:'hills',
        sky:{ bg1:'#233d6d', bg2:'#5d79b0', bg3:'#cfe2ff', water:'#0e2233' },
        layers:[
          {par:0.10, base:0.54, a1:36,  a2:18,  f1:0.00044, f2:0.00018, shade:0.02, shape:'round'},
          {par:0.16, base:0.60, a1:60,  a2:28,  f1:0.00062, f2:0.00024, shade:0.04, shape:'round'},
          {par:0.22, base:0.66, a1:90,  a2:42,  f1:0.00080, f2:0.00032, shade:0.06, shape:'round'},
          {par:0.30, base:0.71, a1:115, a2:56,  f1:0.00098, f2:0.00040, shade:0.08, shape:'round'},
          {par:0.38, base:0.75, a1:132, a2:64,  f1:0.00112, f2:0.00048, shade:0.10, shape:'round'}
        ]
      },
      { name:'mesas',
        sky:{ bg1:'#6e3b1b', bg2:'#cf7b35', bg3:'#ffe1b0', water:'#2a1a12' },
        layers:[
          {par:0.08, base:0.54, a1:42,  a2:20,  f1:0.00058, f2:0.00022, shade:0.02, shape:'mesa'},
          {par:0.13, base:0.60, a1:70,  a2:32,  f1:0.00076, f2:0.00030, shade:0.04, shape:'mesa'},
          {par:0.20, base:0.66, a1:96,  a2:46,  f1:0.00096, f2:0.00038, shade:0.06, shape:'mesa'},
          {par:0.28, base:0.72, a1:120, a2:56,  f1:0.00116, f2:0.00046, shade:0.08, shape:'mesa'},
          {par:0.36, base:0.76, a1:140, a2:64,  f1:0.00128, f2:0.00054, shade:0.10, shape:'mesa'}
        ]
      }
    ];

    function applyTheme(biome){
      const root = document.documentElement.style;
      root.setProperty('--bg1', biome.sky.bg1);
      root.setProperty('--bg2', biome.sky.bg2);
      root.setProperty('--bg3', biome.sky.bg3);
      root.setProperty('--water', biome.sky.water);
    }

    // Backdrop (sun + clouds + mountains)
    let currentBiome = BIOMES[0];
    const backdrop = {
      seed:(Math.random()*1e9)|0,
      mountains:[],
      sun:null,
      clouds:[],
      cloudDir:1,
      windmills:[]
    };

    function triangleWave(x){ return (2/Math.PI)*Math.asin(Math.sin(x)); }
    function mesaWave(x){ const k=2.2; return Math.tanh(Math.sin(x)*k)/Math.tanh(k); }
    function roundWave(x){ const s=Math.sin(x); return Math.sign(s)*Math.pow(Math.abs(s),0.85); }
    function cragWave(x){ return 0.7*triangleWave(x) + 0.3*Math.sin(x*3.0); }
    function shapeSample(shape, x){
      switch(shape){
        case 'mesa':   return mesaWave(x);
        case 'round':  return roundWave(x);
        case 'crag':   return cragWave(x);
        case 'sin':
        default:       return Math.sin(x);
      }
    }

    function buildBackdrop(){
      const L = [];
      currentBiome.layers.forEach((spec, i)=>{
        const s = (backdrop.seed ^ hash32((spec.par*1000)|0) ^ i)>>>0;
        const base = WORLD.h*spec.base;
        const ph   = rand01(s,1)*TAU;
        const curv = { a: 10 + rand01(s,3)*16, f: 0.0012 + rand01(s,4)*0.0006, ph: rand01(s,2)*TAU };
        L.push({ parallax:spec.par, base, a1:spec.a1, a2:spec.a2, f1:spec.f1, f2:spec.f2, ph, shade:spec.shade, curv, shape:spec.shape });
      });
      backdrop.mountains = L;

      // Sun
      const u = 0.20 + rand01(backdrop.seed,101)*0.60;
      const v = 0.16 + rand01(backdrop.seed,102)*0.20;
      const phase = rand01(backdrop.seed,103)*TAU;
      const baseR = 20 + Math.floor(rand01(backdrop.seed,104)*12);
      backdrop.sun = { u, v, phase, baseR };

      // Clouds
      backdrop.cloudDir = rand01(backdrop.seed,399) < 0.5 ? -1 : 1;
      buildCloudField();

      // Windmills
      buildWindmills();
    }

    function buildCloudField(){
      backdrop.clouds.length = 0;
      const count = 3 + Math.floor(rand01(backdrop.seed,300)*4);
      for(let i=0;i<count;i++){
        const s = hash32(backdrop.seed ^ (0xA11C10 + i*131));
        const u = rand01(s,1);
        const v = 0.12 + (i+1)/(count+1) * 0.42 + (rand01(s,2)-0.5)*0.05;
        const parX = 0.04 + rand01(s,3)*0.05;
        const parY = 0.015 + rand01(s,4)*0.02;
        const speed = backdrop.cloudDir * (4 + rand01(s,6)*6);
        const alpha = 0.05 + rand01(s,7)*0.08;
        const scale = 0.9 + rand01(s,8)*1.6;
        backdrop.clouds.push({ seed:s, u, v, parX, parY, speed, alpha, scale });
      }
    }

    function buildWindmills(){
      backdrop.windmills.length = 0;
      const count = 1 + Math.floor(rand01(backdrop.seed,810)*4);
      const used = [];
      for(let i=0, tries=count*8; i<tries && backdrop.windmills.length<count; i++){
        const s = hash32(backdrop.seed ^ (0xC0FFEE + i*997));
        const u = 0.12 + rand01(s,1)*0.76;
        const x = WORLD.w * u;
        if(!used.every(px => Math.abs(px - x) > 420)) continue;
        used.push(x);

        const h = 90 + rand01(s,2)*48;
        const r = 26 + rand01(s,3)*10;
        const speed = 0.8 + rand01(s,4)*1.0;
        const spin0 = rand01(s,5)*TAU;
        const tilt = (rand01(s,6)-0.5) * (14*Math.PI/180);

        backdrop.windmills.push({ x, h, r, speed, spin0, tilt });
      }
    }

    function mountainYAt(L, wx){
      let y = L.base
        - shapeSample(L.shape, wx*L.f1)*L.a1
        - shapeSample(L.shape, wx*L.f2 + L.ph)*L.a2;
      if(L.curv){
        y -= Math.sin(wx*L.curv.f   + L.curv.ph)      * L.curv.a;
        y -= Math.sin(wx*L.curv.f*2 + L.curv.ph*1.3) * (L.curv.a*0.45);
      }
      return y;
    }

    // ===== World / Hole
    const disc = { x:0,y:0,vx:0,vy:0,r:7.5, atRest:true, onGround:true, lastSafe:{x:0,y:0}, orient:0,
                   spin:0, spin0:1, bank:0 };
    let strokes=0;
    let holeIndex=0, roundData=null;
    let hole=null;

    // Aim/meter state
    let aiming=false, aimAngle=0, meter=0, meterDir=1, meterOn=false;

    // Scenery
    let scenery = { trees:[], rocks:[], fences:[] };

    // ===== Boss helpers (Canyon Thermal) =====
    function genCanyonThermalBoss(){
      const w = WORLD.w, h = WORLD.h, step=40;
      const baseY = h*0.72;

      // Canyon parameters
      const canyonW = 420 + Math.random()*100; // 420‚Äì520
      const cx = w*0.52;
      const leftEdge = cx - canyonW/2;
      const rightEdge = cx + canyonW/2;
      const depth = 180 + Math.random()*60;    // 180‚Äì240
      const canyonBottom = baseY + depth;

      // Water: flood the bottom of the canyon
      const waterY = canyonBottom - 10;

      // Green beyond
      const cupX = rightEdge + 520;
      const gWidth = 220;
      const gx0 = cupX - gWidth/2, gx1 = cupX + gWidth/2;
      const greenY = baseY - 16;

      // Terrain points: tee/lay-up ‚Üí canyon ‚Üí approach/green
      const points=[];
      for(let x=0;x<=w;x+=step){
        let y = baseY;

        // generous landing before gap
        if(x < leftEdge - 200){
          y = baseY - Math.sin(x*0.0012)*24;
        }
        // Ramp down into canyon wall
        else if(x >= leftEdge - 160 && x < leftEdge + 60){
          const t = (x - (leftEdge - 160)) / 220;
          y = lerp(baseY - 8, canyonBottom, t*t);
        }
        // Canyon floor span
        else if(x >= leftEdge + 60 && x <= rightEdge - 60){
          y = canyonBottom;
        }
        // Ramp up out of canyon
        else if(x > rightEdge - 60 && x < rightEdge + 200){
          const t = (x - (rightEdge - 60)) / 260;
          y = lerp(canyonBottom, baseY - 6, t);
        }
        // Beyond canyon toward green
        else if(x >= rightEdge + 200){
          y = baseY - 6 - Math.sin((x-rightEdge)*0.001)*10;
        }

        if(x>=gx0 && x<=gx1) y = greenY;
        points.push({x,y});
      }

      // Water body filling the canyon
      const waters = [{ x:leftEdge+6, w:(rightEdge-leftEdge-12), y:waterY, h:h-waterY+80, seed:(Math.random()*1e9)|0 }];

      // Bunkers to shape decisions
      const sands = [
        { x:leftEdge-200, y: sampleY(points, leftEdge-200) - 8, r: 58, seed:(Math.random()*1e9)|0 },
        { x:rightEdge+260, y: sampleY(points, rightEdge+260) - 8, r: 50, seed:(Math.random()*1e9)|0 }
      ];

      const roughs = [
        { x:leftEdge-120, y: sampleY(points, leftEdge-120)-6, r:46 },
        { x:rightEdge+160, y: sampleY(points, rightEdge+160)-6, r:42 }
      ];

      const teeX = 160;
      const teeY = sampleY(points, teeX) - 2;

      // Thermal column: slight offset toward aggressive line (to the right)
      const off = (0.08 + Math.random()*0.06) * canyonW; // ~8‚Äì14% of width
      const thX = cx + off;
      const thY = baseY + 20;
      const rx = 120 + Math.random()*40;   // 120‚Äì160
      const ry = 200 + Math.random()*60;   // 200‚Äì260

      const thermals = [{
        x: thX, y: thY,
        rx, ry,
        boostMin: 0.45,     // +45% local lift at core (min)
        boostMax: 0.70,     // up to +70%
        core: Math.random(),// picks a value between min/max for this thermal
        wiggleAmp: 0.05,    // ~3¬∞ bank wiggle
        wiggleAoA: 0.03,    // ~1.7¬∞ AoA wiggle
        wiggleFreq: 11 + Math.random()*4, // fast oscillation
        seed: Math.random()*TAU
      }];

      return {
        boss:true, bossName:'Canyon Thermal',
        w, h, points, step, cupX,
        green:{x0:gx0,x1:gx1,y:greenY},
        waters,
        sands,
        roughs,
        thermals,
        tee:{x:teeX,y:teeY},
        par: 4
      };
    }

    // ===== Procedural hole (regular) =====
    function genHole(){
      const w = WORLD.w, h = WORLD.h;
      const step=40;

      const tilt = (Math.random()*2-1) * 0.16;
      const tiltAmp = 160;

      let seed = Math.random()*9999;
      function nrand(){ seed = Math.sin(seed)*10000; return seed - Math.floor(seed); }
      const amp1 = 70 + nrand()*110, freq1 = 1/(520+ nrand()*420);
      const amp2 = 22 + nrand()*42,  freq2 = 1/(220 + nrand()*250);

      const baseY0 = h*0.72;
      const points=[];

      for(let x=0;x<=w;x+=step){
        const t = x/w;
        const tiltOffset = (t-0.5) * tiltAmp * tilt;
        const y = baseY0 + tiltOffset
                - Math.sin(x*freq1)*amp1
                - Math.sin(x*freq2)*amp2;
        points.push({x,y});
      }

      const featureCount = Math.floor(Math.random()*3);
      for(let f=0; f<featureCount; f++){
        const cx = lerp(w*0.18, w*0.82, Math.random());
        const sigma = 120 + Math.random()*220;
        const amp = (Math.random()<0.5? -1:1) * (50 + Math.random()*90);
        for(let i=0;i<points.length;i++){
          const dx = points[i].x - cx;
          const k = Math.exp(-(dx*dx)/(2*sigma*sigma));
          points[i].y += amp * k;
        }
      }

      if(Math.random() < 0.33){
        const cx = lerp(w*0.30, w*0.70, Math.random());
        const up = Math.random() < 0.5 ? -1 : 1;
        const drop = up * (120 + Math.random()*120);
        const sharp = 60 + Math.random()*80;
        for(let i=0;i<points.length;i++){
          const dx = (points[i].x - cx) / sharp;
          const s = 1/(1+Math.exp(-dx));
          points[i].y += drop * s;
        }
      }

      const cupX = lerp(w*0.68, w*0.90, Math.random());

      const gWidth = 200 + Math.random()*160;
      const gx0=cupX-gWidth/2, gx1=cupX+gWidth/2;
      const greenSlope = (Math.random()*0.6-0.3);
      let greenY = 0;

      for(let i=0;i<points.length;i++){
        if(points[i].x>=gx0 && points[i].x<=gx1){
          const t = (points[i].x-gx0)/gWidth;
          const gy = (baseY0-30) + (Math.sin(points[i].x*freq2)*6) + greenSlope*(t-0.5)*40;
          points[i].y = gy;
          greenY = gy;
        }
      }

      function scanBasins(){
        const n = points.length, out=[];
        const bankMin = 32, bankMax = 64;
        for(let i=2;i<n-2;i++){
          const yL = points[i-1].y, yC = points[i].y, yR = points[i+1].y;
          if(!(yC < yL && yC < yR)) continue;

          const bottom = yC;
          let surface = bottom + (bankMin + Math.random()*(bankMax - bankMin));

          let L=i, R=i;
          while(L>0 && points[L].y <= surface) L--;
          while(R<n-1 && points[R].y <= surface) R++;
          const leftShoulder  = Math.min(points[Math.max(L-1,0)].y,   points[Math.max(L-2,0)].y);
          const rightShoulder = Math.min(points[Math.min(R+1,n-1)].y, points[Math.min(R+2,n-1)].y);
          const spillY = Math.min(leftShoulder, rightShoulder) - 8;
          if(surface > spillY) surface = spillY;

          L=i; R=i;
          while(L>0 && points[L].y <= surface) L--;
          while(R<n-1 && points[R].y <= surface) R++;

          const x0 = points[L].x, x1 = points[R].x;
          const width = x1 - x0;
          const cx = (x0 + x1) * 0.5;
          out.push({ i, x0, x1, width, cx, surfaceY:surface, bottomY:bottom });
        }
        return out;
      }

      const basinsAll = scanBasins();

      const waters=[];
      (function buildWaters(){
        const minWidth = 160;
        const waterCandidates = basinsAll
          .filter(b => b.width >= minWidth)
          .sort((a,b)=>{
            const dw = b.width - a.width;
            if(Math.abs(dw) > 1) return dw;
            const ma = Math.abs(a.cx - w*0.5);
            const mb = Math.abs(b.cx - w*0.5);
            return ma - mb;
          });

        function clipAwayFromGreen(x0,x1){
          if(x0 < gx1 && x1 > gx0){
            const leftOverlap  = Math.max(0, gx1 - x0);
            const rightOverlap = Math.max(0, x1 - gx0);
            if(leftOverlap < rightOverlap) x0 = gx1; else x1 = gx0;
          }
          return [x0,x1];
        }

        for(const b of waterCandidates){
          if(waters.length >= 2) break;
          let x0 = clamp(b.x0 + 1, 60, w-60);
          let x1 = clamp(b.x1 - 1, 60, w-60);
          [x0,x1] = clipAwayFromGreen(x0,x1);
          if(x1 - x0 < minWidth) continue;
          const overlaps = waters.some(p => Math.min(p.x+p.w, x1) - Math.max(p.x, x0) > 40);
          if(overlaps) continue;
          waters.push({ x:x0, w:(x1-x0), y:b.surfaceY, h:h-b.surfaceY+60, seed:(Math.random()*1e9)|0 });
        }

        if(!waters.length){
          const near = basinsAll.sort((a,b)=>Math.abs(a.cx-cupX)-Math.abs(b.cx-cupX))[0];
          if(near){
            let x0 = clamp(near.x0 + 1,60,w-60), x1 = clamp(near.x1 - 1,60,w-60);
            [x0,x1] = clipAwayFromGreen(x0,x1);
            if(x1-x0 >= minWidth){
              waters.push({ x:x0, w:(x1-x0), y:near.surfaceY, h:h-near.surfaceY+60, seed:(Math.random()*1e9)|0 });
            }
          }
        }
      })();

      const sands=[];
      function basinBlockedByWater(b){
        return waters.some(W => !(b.x1 < W.x || b.x0 > (W.x + W.w)));
      }
      function placeBunkerFromBasin(b, sizeScale=0.35){
        let cx = clamp(b.cx, 80, w-80);
        for(const ww of waters){
          if(cx >= ww.x && cx <= ww.x+ww.w){
            cx = (cx < ww.x + ww.w*0.5)? (ww.x - 20) : (ww.x + ww.w + 20);
          }
        }
        const cy = sampleY(points, cx) - 8;
        const r = clamp(b.width*sizeScale, 36, 90);
        sands.push({ x:cx, y:cy, r, seed:(Math.random()*1e9)|0 });
        return true;
      }

      const roughs=[];
      const roughN = Math.floor(Math.random()*4);
      for(let i=0;i<roughN;i++){
        const rx = lerp(w*0.20, cupX-140, Math.random());
        const ry = sampleY(points, rx) - 6;
        roughs.push({ x:rx, y:ry, r: 42 + Math.random()*30 });
      }

      const teeX = 120;
      const teeIdx = Math.floor(teeX/step);
      const teeY = points[teeIdx].y - 2;
      points[teeIdx].y = teeY;

      if(Math.random()<0.6){
        const vX = lerp(w*0.40, w*0.62, Math.random());
        const vIdx = Math.floor(vX/step);
        for(let i=-3;i<=3;i++){
          const k=vIdx+i; if(points[k]) points[k].y += Math.abs(i)* (16 + Math.random()*12);
        }
      }

      const dist = (cupX - teeX);
      let par = 3; if(dist>1900) par=5; else if(dist>1200) par=4;

      return {
        w, h, points, step, cupX,
        green:{x0:gx0,x1:gx1,y:greenY},
        waters,
        sands,
        roughs,
        thermals:[],
        tee:{x:teeX,y:teeY},
        par
      };
    }

    function sampleY(points, x){
      const step = points[1].x - points[0].x;
      const i = Math.min(Math.max(Math.floor(x/step),0), points.length-2);
      const p0 = points[i], p1 = points[i+1];
      const t = (x - p0.x)/(p1.x - p0.x);
      return lerp(p0.y, p1.y, t);
    }

    function groundYAt(x){ x = clamp(x, 0, hole.w); const i = Math.min(Math.floor(x/hole.step), hole.points.length-2); const p0 = hole.points[i], p1 = hole.points[i+1]; const t = (x - p0.x)/(p1.x - p0.x); return lerp(p0.y, p1.y, t); }

    function surfaceAt(x){
      if(x>=hole.green.x0 && x<=hole.green.x1) return 'green';
      const y = groundYAt(x);
      for(const s of hole.sands){ if(Math.hypot(x - s.x, y - s.y) <= s.r) return 'sand'; }
      for(const r of hole.roughs){ if(Math.hypot(x - r.x, y - r.y) <= r.r) return 'rough'; }
      return 'fairway';
    }

    function inWater(x,y){
      for(const w of hole.waters){
        if(x>=w.x && x<=w.x+w.w && y>=w.y) return true;
      }
      return false;
    }

    // ===== Round flow
    function newRound(){ holeIndex=0; roundData={ holes:[], totalPar:0, totalStrokes:0 }; screenIntro.style.display='none'; screenSummary.style.display='none'; nextHole(); }

    function nextHole(){
      const biome = BIOMES[holeIndex % BIOMES.length];
      currentBiome = biome;
      applyTheme(biome);

      const isBoss = ((holeIndex+1) % 3 === 0);
      hole = isBoss ? genCanyonThermalBoss() : genHole();

      buildScenery();

      backdrop.seed = (Math.random()*1e9)|0;
      buildBackdrop();

      roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par;
      elHole.textContent = (holeIndex+1); elPar.textContent = hole.par;

      bossChip.style.display = isBoss ? 'inline-flex' : 'none';

      windLift = windOn ? (Math.random()*2 - 1) : 0;
      updateWindUI();

      disc.x = hole.tee.x; disc.y = hole.tee.y - disc.r - 1; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; disc.orient=0; disc.spin=0; disc.bank=0; strokes=0; elStrokes.textContent=strokes;
      centerCameraOnDisc();
    }

    function endHole(){
      roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes; holeIndex++;
      if(holeIndex>=HOLES_PER_ROUND){
        sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar; const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
        holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
        screenSummary.style.display='grid';
      } else { nextHole(); }
    }

    // ===== UI build: discs, release, hand
    function buildDiscs(){
      clubSeg.innerHTML='';
      DISCS.forEach((d,idx)=>{
        const b=document.createElement('button'); b.className='btn'; b.textContent=d.name; b.dataset.disc=idx;
        b.setAttribute('aria-pressed', idx===1? 'true':'false');
        b.addEventListener('click',()=>selectDisc(idx));
        clubSeg.appendChild(b);
      });
      selectDisc(1);
    }
    let currentDisc = DISCS[1];
    function selectDisc(i){ currentDisc = DISCS[i]; [...clubSeg.querySelectorAll('button')].forEach((b,idx)=> b.setAttribute('aria-pressed', idx===i? 'true':'false')); }
    spinSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; releaseMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });
    handSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; hand = btn.dataset.hand; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });

    // ===== Wind UI
    function updateWindUI(){
      const mag = Math.abs(windOn ? windLift : 0);
      elWindVal.textContent = mag.toFixed(1)+'x';
      const rot = (windLift >= 0 ? 180 : 0);
      elWindArrow.style.transform = `rotate(${rot}deg)`;
    }

    // ===== Input
    function worldToScreen(x,y){ return { x: (x - view.x)*DPR, y: (y - view.y)*DPR }; }
    function screenToWorld(x,y){ return { x: x/DPR + view.x, y: y/DPR + view.y }; }
    function onPointerDown(e){ if(!hole || !disc.atRest) return; const p = getPoint(e); const w=screenToWorld(p.x,p.y); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x)); aiming = true; meterOn = true; meter = 0; meterDir=1; elPowermeter.dataset.on='1'; e.preventDefault(); }
    function onPointerMove(e){ if(!aiming) return; const p = getPoint(e); const w=screenToWorld(p.x,p.y); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x)); }
    function onPointerUp(e){ if(!aiming) return; aiming=false; meterOn=false; elPowermeter.dataset.on='0'; throwDisc(); }
    function getPoint(e){ if(e.changedTouches){ const t=e.changedTouches[0]; return { x:t.clientX*DPR, y:t.clientY*DPR }; } return { x:e.clientX*DPR, y:e.clientY*DPR }; }
    canvas.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive:false}); window.addEventListener('touchmove', onPointerMove, {passive:false}); window.addEventListener('touchend', onPointerUp);

    // ===== Throw
    function throwDisc(){
      if(!hole || !disc.atRest) return;
      const d = currentDisc;
      const surface = surfaceAt(disc.x); let powerMul = 1.0; if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
      const base = 1650;
      const power = (0.25 + 0.75*meter) * d.speed * powerMul;
      const speed = base * power;
      const dir = aimAngle;

      disc.vx = Math.cos(dir) * speed;
      disc.vy = Math.sin(dir) * speed;

      disc.orient = dir + (NOSE_FAST_DEG * Math.PI/180);
      disc.spin0  = 14 + 20*power;
      disc.spin   = disc.spin0;
      disc.bank   = (releaseMode * 16) * Math.PI/180;

      disc.atRest=false; disc.onGround=false; strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes;
      if(navigator.vibrate) navigator.vibrate(16);
      Sfx.playThrow();
    }

    // ===== Physics update
    function normalizeAngle(a){
      while(a > Math.PI) a -= TAU;
      while(a < -Math.PI) a += TAU;
      return a;
    }

    function update(dt){
      if(meterOn){ meter += meterDir * 1.6 * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width = (meter*100).toFixed(1)+'%'; }

      if(!hole){ return; }

      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.vy += 1200*dt; p.vx*= (1-0.4*dt); p.vy*=(1-0.06*dt); p.x += p.vx*dt; p.y += p.vy*dt; }

      if(!disc.atRest){
        if(!disc.onGround){
          const v = Math.hypot(disc.vx, disc.vy) || 0.0001;
          const vx = disc.vx, vy = disc.vy;
          const vAngle = Math.atan2(vy, vx);

          const tPow = clamp(v / 1600, 0, 1);
          const spinNorm = clamp(disc.spin / (disc.spin0 || 1), 0, 1);

          // AoA baseline
          const aoaRaw = normalizeAngle(disc.orient - vAngle);

          // Thermal effects (multiplier + turbulence)
          let thermalMul = 1.0;
          let wiggleBank = 0.0;
          let wiggleAoA  = 0.0;
          if(hole?.thermals?.length){
            for(const th of hole.thermals){
              const dx = disc.x - th.x, dy = disc.y - th.y;
              // elliptical Gaussian falloff (0..1)
              const g = Math.exp(-0.5*((dx*dx)/(th.rx*th.rx) + (dy*dy)/(th.ry*th.ry)));
              if(g > 0.001){
                const boostCore = th.boostMin + (th.boostMax - th.boostMin) * th.core; // +0.45..+0.70
                const local = 1 + boostCore * g;
                if(local > thermalMul) thermalMul = local; // take strongest if multiple
                const phase = th.seed + (performance.now()/1000)*th.wiggleFreq;
                const ampScale = g;
                wiggleBank += th.wiggleAmp * ampScale * Math.sin(phase);           // ~¬±0.05 rad
                wiggleAoA  += th.wiggleAoA  * ampScale * Math.sin(phase*1.15+0.6); // ~¬±0.03 rad
              }
            }
          }

          // Effective AoA with wiggle; clamp to reasonable range
          const aoa = clamp(aoaRaw + 0.06 + wiggleAoA, -0.6, 0.6);

          const dragMag = AIR_DRAG * v * (1 + 0.7*Math.abs(aoa));
          const dragX = -dragMag * vx;
          const dragY = -dragMag * vy;

          // Global wind + local thermal lift multiplier
          const windMul = (windOn ? (1 + clamp(windLift, -1, 1) * 0.50) : 1);
          const lift = LIFT_K * currentDisc.glide * v*v * aoa * windMul * thermalMul;

          // Curvature (turn/fade/bank)
          const turnPhase = tPow*tPow;
          const fadePhase = (1 - tPow);
          const hyz = releaseMode;
          let turnAmt = currentDisc.turn * turnPhase * (0.7 + 0.6*spinNorm) * (1 + 0.35*hyz);
          let fadeAmt = currentDisc.fade * fadePhase * (0.9 + 0.5*(1 - spinNorm)) * (1 - 0.25*hyz);
          // include turbulence wobble in bank effect (non-persistent)
          const bankBias = 0.12 * Math.sin(disc.bank + wiggleBank);
          const curve = (turnAmt - fadeAmt + bankBias);
          const curveAx = 54 * curve * (hand==='RHBH'?1:-1);

          const ax = dragX + curveAx;
          const ay = 1500 + dragY - lift;

          disc.vx += ax*dt; disc.vy += ay*dt;
          disc.x  += disc.vx*dt; disc.y  += disc.vy*dt;

          disc.spin *= Math.exp(-0.35*dt);
          const bankRelax = 0.2 + 0.9*(1 - spinNorm);
          disc.bank += (-disc.bank) * (1 - Math.exp(-dt*bankRelax));

          const noseBias = (lerp(NOSE_FAST_DEG, NOSE_SLOW_DEG, 1 - tPow)) * Math.PI/180;
          const targetOrient = vAngle + noseBias;
          disc.orient += (targetOrient - disc.orient) * (1 - Math.exp(-dt*3.4));

          // Ground collision
          const gy = groundYAt(disc.x);
          if(disc.y + disc.r >= gy){
            disc.y = gy - disc.r - 0.01;

            if(Math.abs(disc.vy) > 120){
              const surf = surfaceAt(disc.x);
              if(surf==='sand') spawnParticles('sand',  disc.x, disc.y+disc.r, 12);
              else              spawnParticles('dust',  disc.x, disc.y+disc.r,  8);
            }

            const speed = Math.hypot(disc.vx, disc.vy);
            const entryAngle = Math.atan2(Math.abs(disc.vy), Math.abs(disc.vx));
            const shallow = entryAngle < (12 * Math.PI/180);
            const fast    = speed > 900;

            const surf = surfaceAt(disc.x);
            if(surf!=='sand' && surf!=='green' && shallow && fast){
              disc.vy = -Math.max(180, Math.abs(disc.vy)*0.55);
              disc.vx *= 0.88;
              disc.onGround = false;
            } else {
              const rest = SURF[surf]?.rest ?? 0.14;
              disc.vy = -disc.vy * rest;
              disc.vx *= 0.84;
              if(Math.abs(disc.vy) < 120) disc.vy = 0;
              disc.onGround = true;
            }
          }

          if(checkBasketCatch()){
            Sfx.playChain();
            const cupX = hole.cupX;
            const gY = groundYAt(cupX);
            spawnParticles('spark', cupX, gY - 35, 18);
            if(navigator.vibrate) navigator.vibrate([30,40,30]);
            disc.atRest=true; disc.vx=disc.vy=0;
            setTimeout(()=>{ endHole(); }, 520);
          }
        } else {
          // Rolling
          const gy = groundYAt(disc.x); 
          if(disc.y + disc.r < gy-0.5){ 
            disc.onGround=false; 
          } else {
            disc.y = gy - disc.r; 
            const surf = surfaceAt(disc.x); 
            const fric = SURF[surf]?.fric ?? 740; 
            const speed = Math.abs(disc.vx); 
            let dec = fric * 2.1;
            if(surf === 'sand')  dec = fric * 2.6;
            if(surf === 'green') dec = fric * 2.3;

            const s = Math.sign(disc.vx) || 0; 
            let newSpeed = speed - dec*dt; 
            if(newSpeed<0) newSpeed=0; 
            disc.vx = s * newSpeed; 
            disc.x += disc.vx*dt; 
            if(Math.abs(disc.vx) < 8){ disc.vx=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; }
          }
        }
        if(inWater(disc.x, disc.y+disc.r*0.6)){
          spawnParticles('splash', disc.x, disc.y, 16);
          if(navigator.vibrate) navigator.vibrate([40,40,30]);
          strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes;
          disc.x = disc.lastSafe.x - 24; disc.y = groundYAt(disc.x)-disc.r; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true;
        }
        if(disc.x<0){ disc.x=0; disc.vx=0; } if(disc.x>hole.w){ disc.x=hole.w; disc.vx=0; }
      }
      centerCameraOnDisc();
    }

    function centerCameraOnDisc(){
      if(!hole){ return; }
      view.x = clamp(disc.x - view.w*0.45, 0, WORLD.w - view.w);
      view.y = clamp(groundYAt(disc.x) - view.h*0.65, 0, WORLD.h - view.h);
    }

    // ===== Scenery (trees, rocks, fences) =====
    function buildScenery(){
      scenery.trees = [];
      scenery.rocks = [];
      scenery.fences = [];
      const rng = (i)=>rand01(backdrop.seed, 2000+i);
      const countTrees = 24 + Math.floor(rng(1)*18);
      const avoid = [
        [hole.green.x0-80, hole.green.x1+80],
      ];
      for(const w of hole.waters){ avoid.push([w.x-60, w.x+w.w+60]); }
      function allowedX(x){
        for(const r of avoid){ if(x>=r[0] && x<=r[1]) return false; }
        return x>40 && x < hole.w-40;
      }
      // Trees
      for(let i=0;i<countTrees;i++){
        let x = 80 + rng(10+i)*(WORLD.w-160);
        let tries=0; while(!allowedX(x) && tries++<10){ x = 80 + rng(100+i*7)*(WORLD.w-160); }
        const y = groundYAt(x);
        const h = 56 + rng(200+i)*96;
        const baseW = 14 + rng(300+i)*18;
        const levels = 4 + Math.floor(rng(500+i)*2);
        scenery.trees.push({ x, y, h, w: baseW, levels, sway:rng(400+i)*TAU });
      }
      // Rocks
      const rockN = 6 + Math.floor(Math.random()*6);
      for(let i=0;i<rockN;i++){
        const x = 80 + Math.random()*(WORLD.w-160);
        const y = groundYAt(x);
        const r = 3 + Math.random()*5;
        const seed = (Math.random()*1e9)|0;
        scenery.rocks.push({ x, y, r, seed, skew: (Math.random()*0.6-0.3) });
      }

      // Fences (kept for world texture)
      function addFence(x0, x1){
        if(x1 < x0){ const t=x0; x0=x1; x1=t; }
        x0 = clamp(x0, 40, hole.w-40);
        x1 = clamp(x1, 40, hole.w-40);
        if(x0 < hole.green.x1 && x1 > hole.green.x0){
          if(Math.abs(x0 - hole.green.x0) < Math.abs(x1 - hole.green.x1)) x0 = hole.green.x1 + 16;
          else x1 = hole.green.x0 - 16;
        }
        if(x1 - x0 < 80) return;

        const F = {
          x0, x1,
          step: 28 + Math.random()*10,
          height: 16 + Math.random()*8,
          rails: (Math.random()<0.35?3:2),
          seed: (Math.random()*1e9)|0,
          posts: []
        };

        let idx = 0;
        for(let x = x0; x <= x1; x += F.step){
          const tilt  = (rand01(F.seed, idx*2+1) - 0.5) * 0.12;
          const hMul  = 0.88 + rand01(F.seed, idx*2+2) * 0.25;
          F.posts.push({ x, tilt, hMul });
          idx++;
        }

        scenery.fences.push(F);
      }

      const baseX = hole.tee.x + 140;
      if(baseX < hole.cupX - 120) addFence(baseX, baseX + 260 + Math.random()*200);
      if(Math.random() < 0.65){
        const mid = lerp(hole.tee.x+320, hole.cupX-200, Math.random());
        addFence(mid - (120+Math.random()*120), mid + (120+Math.random()*120));
      }
      if(Math.random() < 0.45){
        addFence(hole.cupX - (260+Math.random()*120), hole.cupX - 80);
      }
    }

    function drawScenery(){
      drawFences();

      // Rocks
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.92)';
      for(const r of scenery.rocks){
        const x = r.x - view.x, y = r.y - view.y;
        if(x<-40 || x>canvas.width/DPR+40) continue;
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(r.skew);

        function rr(seed,i){ return (hash32(seed ^ (i*2654435761))>>>0)/4294967295; }
        const lumps = 2 + Math.floor(rr(r.seed,1)*3);
        for(let i=0;i<lumps;i++){
          const ang = rr(r.seed,10+i)*TAU;
          const dist = r.r * (0.2 + rr(r.seed,20+i)*0.9);
          const rad  = r.r * (0.7 + rr(r.seed,30+i)*0.7);
          const ox = Math.cos(ang)*dist;
          const oy = Math.sin(ang)*dist*0.5 - r.r*0.3;
          const rot = (rr(r.seed,40+i)-0.5)*0.8;
          ctx.save(); ctx.translate(ox, oy); ctx.rotate(rot);
          ctx.beginPath(); ctx.ellipse(0, 0, rad, rad*0.65, 0, 0, TAU); ctx.fill();
          ctx.restore();
        }

        ctx.restore();
      }
      ctx.restore();

      // Trees
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.94)';
      for(const t of scenery.trees){
        const x = t.x - view.x, y = t.y - view.y;
        if(x<-60 || x>canvas.width/DPR+60) continue;
        const sway = Math.sin(clock*0.3 + t.sway) * 2;

        const trunkW = clamp(t.h*0.045, 3, 7);
        ctx.fillRect(x - trunkW/2, y - t.h, trunkW, t.h);
        ctx.beginPath(); ctx.moveTo(x - trunkW*0.8, y); ctx.lineTo(x + trunkW*0.8, y); ctx.lineTo(x, y - trunkW*0.4); ctx.closePath(); ctx.fill();

        const tierGap = 10;
        for(let k=0;k<t.levels;k++){
          const level = t.h*(0.16 + k*0.18);
          const width = (t.w + k*(t.w*0.28));
          ctx.beginPath();
          ctx.moveTo(x + sway*0.45, y - level - (k*tierGap));
          ctx.lineTo(x - width/2 + sway, y - level + tierGap);
          ctx.lineTo(x + width/2 + sway, y - level + tierGap);
          ctx.closePath(); ctx.fill();
        }
      }
      ctx.restore();
    }

    // ===== Stable fences
    function drawFences(){
      if(!scenery.fences.length) return;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.94)';
      ctx.fillStyle   = 'rgba(0,0,0,0.94)';

      for(const F of scenery.fences){
        for(const P of F.posts){
          const x = P.x;
          const y = groundYAt(x);
          const sx = x - view.x;
          const sy = y - view.y;
          if(sx<-40 || sx>canvas.width/DPR+40) continue;

          const yR  = groundYAt(x+6);
          const ang = Math.atan2(yR - y, 6) + P.tilt;
          const h   = F.height * P.hMul;
          const w   = 3;

          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(ang - Math.PI/2);
          ctx.translate(0.5, 0.5);
          ctx.fillRect(-w/2, 0, w, h);
          ctx.fillRect(-w/2 - 1, 0, w+2, 2);
          ctx.restore();
        }

        const railOffset = (F.rails === 3) ? [6,12,18] : [8,16];
        ctx.lineWidth = 2;
        for(const off of railOffset){
          ctx.beginPath();
          let started=false;
          for(const P of F.posts){
            const sx = P.x - view.x;
            const sy = groundYAt(P.x) - view.y - off;
            if(sx<-60 || sx>canvas.width/DPR+60) continue;
            if(!started){ ctx.moveTo(sx, sy); started=true; }
            else ctx.lineTo(sx, sy);
          }
          if(started) ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ===== Sand bunkers =====
    function drawBunkerHole(s){
      const cx = s.x - view.x, cy = s.y - view.y;
      const r = s.r;

      const yL = groundYAt(s.x - 6), yR = groundYAt(s.x + 6);
      const ang = Math.atan2(yR - yL, 12);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.scale(1.10, 0.68);

      const ring = ctx.createRadialGradient(0, 0, r*0.72, 0, 0, r);
      ring.addColorStop(0, 'rgba(255,255,255,0)');
      ring.addColorStop(1, 'rgba(255,255,255,0.08)');
      ctx.fillStyle = ring;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      const shade = ctx.createRadialGradient(0, r*0.22, r*0.18, 0, 0, r);
      shade.addColorStop(0, 'rgba(0,0,0,0.30)');
      shade.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shade;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      ctx.save();
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.clip();
      drawSandGrain(s.seed, r);
      ctx.restore();

      ctx.restore();
    }
    function drawSandGrain(seed, r){
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const N = 140;
      for(let i=0;i<N;i++){
        const u = rand01(seed, i*7+1);
        const v = rand01(seed, i*7+2);
        const theta = v * TAU;
        const rad = Math.sqrt(u) * r * 0.85;
        const x = Math.cos(theta) * rad;
        const y = Math.sin(theta) * rad * 0.82;
        const dir = (rand01(seed, i*7+3)-0.5) * TAU;
        const len = 2 + rand01(seed, i*7+4)*4;

        ctx.beginPath();
        ctx.moveTo(x - Math.cos(dir)*len*0.5, y - Math.sin(dir)*len*0.5);
        ctx.lineTo(x + Math.cos(dir)*len*0.5, y + Math.sin(dir)*len*0.5);
        ctx.stroke();
      }
    }

    // ===== Water rendering =====
    function drawWaterBodies(){
      if(!hole || !hole.waters?.length) return;
      for(const W of hole.waters){ drawWater(W); }
    }
    function drawWater(W){
      const cs = getComputedStyle(document.documentElement);
      const baseCol = cs.getPropertyValue('--water').trim() || '#30160f';

      const left = W.x - view.x;
      const top  = W.y - view.y;
      const width = W.w;
      const height = hole.h - W.y + 80;

      ctx.save();
      ctx.beginPath();
      ctx.rect(left, top, width, height);
      ctx.clip();

      ctx.fillStyle = baseCol;
      ctx.fillRect(left, top, width, height);

      const g = ctx.createLinearGradient(0, top, 0, top + height);
      g.addColorStop(0.00, 'rgba(0,0,0,0.10)');
      g.addColorStop(0.65, 'rgba(0,0,0,0.18)');
      g.addColorStop(1.00, 'rgba(0,0,0,0.28)');
      ctx.fillStyle = g;
      ctx.fillRect(left, top, width, height);

      const rippleA = { freq: 0.035, amp: 1.3, speed: 1.6 };
      const rippleB = { freq: 0.070, amp: 0.9,  speed: -1.2 };
      const step = 14;
      ctx.lineWidth = 1;

      ctx.strokeStyle = 'rgba(255,255,255,0.09)';
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin((x * rippleA.freq) + clock * rippleA.speed * 2.0) * rippleA.amp +
          Math.sin((x * rippleB.freq) + clock * rippleB.speed * 2.0) * rippleB.amp;
        const y = top + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.10)';
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin((x * rippleA.freq) + clock * rippleA.speed * 2.0 + 1.2) * (rippleA.amp*0.9) +
          Math.sin((x * rippleB.freq) + clock * rippleB.speed * 2.0 + 0.7) * (rippleB.amp*0.9);
        const y = top + 2 + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      const rr = (i)=> (hash32((W.seed ^ (i*2654435761))>>>0) >>> 0) / 4294967295;
      const streaks = 4 + Math.floor(rr(1) * 4);
      for(let i=0;i<streaks;i++){
        const yRand = rr(10+i);
        const y = top + 6 + yRand * Math.min(38, height - 10);
        const drift = ((clock * 18) + rr(100+i)*2000) % (width + 160);
        const x0 = left + drift - 160;
        const x1 = Math.min(left + width, x0 + (60 + rr(200+i)*120));

        ctx.globalAlpha = 0.07 + rr(300+i)*0.05;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x0, y, x1 - x0, 1);
        ctx.globalAlpha = 1;
      }

      drawFoamBand(left, top, width, W.seed);

      ctx.restore();
    }
    function drawFoamBand(left, top, width, seed){
      const f1 = 0.045, a1 = 1.4;
      const f2 = 0.090, a2 = 0.8;
      const phase = (hash32(seed ^ 0xBEEF) % 628) / 100;
      const step = 10;

      const haloGrad = ctx.createLinearGradient(0, top, 0, top + 6);
      haloGrad.addColorStop(0, 'rgba(255,255,255,0.10)');
      haloGrad.addColorStop(1, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = haloGrad;
      ctx.fillRect(left, top, width, 6);

      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin(x*f1 + clock*2.0 + phase) * a1 +
          Math.sin(x*f2 - clock*1.6 + phase*1.7) * a2;
        const y = top + 1 + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      for(let x=4; x<width; x+=22){
        const y = top + 2 + Math.sin(x*0.07 + phase)*0.8;
        ctx.fillRect(left + x, y, 1, 1);
      }
    }

    // ===== Background: sky/sun/clouds/mountains
    function drawSkyGradient(){
      const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height/DPR); const cs = getComputedStyle(document.documentElement);
      skyGrad.addColorStop(0, cs.getPropertyValue('--bg3').trim());
      skyGrad.addColorStop(0.55, cs.getPropertyValue('--bg2').trim());
      skyGrad.addColorStop(1, cs.getPropertyValue('--bg1').trim());
      ctx.fillStyle = skyGrad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    }
    function drawSun(){
      const m = backdrop.sun; if(!m) return;
      const parX = 0.05, parY = 0.02;
      const drift = Math.sin(clock*0.05 + m.phase) * 12;
      const xw = WORLD.w * m.u, yw = WORLD.h * m.v;
      const x = (xw - view.x*parX) + drift;
      const y = (yw - view.y*parY);
      const r = m.baseR;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const halo = ctx.createRadialGradient(x, y, r*0.8, x, y, r*4.0);
      halo.addColorStop(0, 'rgba(255,210,130,0.22)');
      halo.addColorStop(1, 'rgba(255,210,130,0.00)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, r*4.0, 0, TAU); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.fillStyle = '#fff2cf';
      ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.10)'; ctx.lineWidth = 1; ctx.stroke();
      ctx.restore();
    }
    function drawClouds(){
      const w = canvas.width / DPR;
      const span = WORLD.w;
      backdrop.clouds.forEach(C=>{
        const baseX = WORLD.w * C.u - clock * C.speed;
        const y = WORLD.h * C.v - view.y * C.parY;
        for(let k=-1; k<=1; k++){
          const x = baseX + k*span - view.x * C.parX;
          if(x < -260 || x > w + 260) continue;
          drawFluffyCloud(x, y, C.scale, C.seed, C.alpha);
        }
      });

      function drawFluffyCloud(x, y, s, seed, alpha){
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.globalAlpha = alpha;
        const baseR = 18 + rand01(seed,50)*22;
        const puffCount = 4 + Math.floor(rand01(seed,11)*4);
        for(let i=0;i<puffCount;i++){
          const r  = (baseR + rand01(seed,20+i)*22) * s;
          const ox = (i - (puffCount-1)/2) * (r*0.55) + (rand01(seed,30+i)-0.5)*r*0.3;
          const oy = (rand01(seed,40+i)-0.5) * r * 0.25;
          const cx = x + ox, cy = y + oy;
          minX = Math.min(minX, cx - r*1.3); maxX = Math.max(maxX, cx + r*1.3);
          minY = Math.min(minY, cy - r*1.2); maxY = Math.max(maxY, cy + r*1.2);
          const g = ctx.createRadialGradient(cx, cy, r*0.35, cx, cy, r*1.3);
          g.addColorStop(0,'rgba(255,255,255,0.55)');
          g.addColorStop(1,'rgba(255,255,255,0.00)');
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r*1.3, 0, TAU); ctx.fill();
        }
        const cxMid = (minX+maxX)/2, cyMid = (minY+maxY)/2;
        const rMax = (maxX-minX)*0.42;
        const core = ctx.createRadialGradient(cxMid, cyMid, rMax*0.1, cxMid, cyMid, rMax);
        core.addColorStop(0,'rgba(255,255,255,0.18)');
        core.addColorStop(1,'rgba(255,255,255,0.00)');
        ctx.fillStyle = core; ctx.beginPath(); ctx.arc(cxMid, cyMid, rMax, 0, TAU); ctx.fill();
        ctx.restore();

        ctx.save(); const shadowR = (maxX - minX) * 0.65;
        const sx = cxMid + shadowR*0.05; const sy = cyMid + (maxY-minY)*0.18;
        const sh = ctx.createRadialGradient(sx, sy, shadowR*0.15, sx, sy, shadowR*1.2);
        sh.addColorStop(0, 'rgba(0,0,0,0.06)'); sh.addColorStop(1, 'rgba(0,0,0,0.00)');
        ctx.fillStyle = sh; ctx.beginPath(); ctx.arc(sx, sy, shadowR*1.2, 0, TAU); ctx.fill(); ctx.restore();
      }
    }
    function drawMountains(){
      const w = canvas.width/DPR, h = canvas.height/DPR;
      backdrop.mountains.forEach((L, idx)=>{
        ctx.fillStyle = `rgba(0,0,0,${0.18 + L.shade})`;
        const step = Math.max(8, 16 - idx*2);
        ctx.beginPath(); ctx.moveTo(0,h);
        for(let x=0;x<=w;x+=step){
          const wx = view.x*L.parallax + x;
          const y = mountainYAt(L, wx) - view.y*0.06*idx;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(w,h); ctx.closePath(); ctx.fill();
      });
    }

    const GRASS_STEP = 26, GRASS_DENSITY = 3;
    function drawGrass(){
      if(!hole){ return; }
      ctx.save(); ctx.strokeStyle='rgba(0,0,0,.9)'; ctx.lineWidth=1;
      const start = Math.floor((view.x-40)/GRASS_STEP)*GRASS_STEP; const end = view.x + view.w + 40;
      for(let wx=start; wx<end; wx+=GRASS_STEP){
        const gx = clamp(wx,0,hole.w); const gy = groundYAt(gx) - view.y; if(gy< -20 || gy > canvas.height/DPR+20) continue;
        for(let k=0;k<GRASS_DENSITY;k++){
          const idx = ((gx|0)*7 + k)|0; const hh = 7 + rand01(backdrop.seed ^ 0xabc123, idx)*10; const lean = (rand01(backdrop.seed ^ 0x55aa55, idx+13)-0.5)*8;
          const baseX = gx - view.x + (k-1)*(2 + rand01(backdrop.seed ^ 0x999,idx+21)*2);
          ctx.beginPath(); ctx.moveTo(baseX, gy);
          const ctrlX = baseX + lean*0.45; const ctrlY = gy - hh*0.55; const tipX = baseX + lean; const tipY = gy - hh;
          ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawDisc(){ 
      const cs = getComputedStyle(document.documentElement); 
      const trailColor = cs.getPropertyValue('--accent'); 
      if(!disc.atRest && Math.hypot(disc.vx,disc.vy)>320){ 
        ctx.strokeStyle = trailColor; ctx.globalAlpha=0.24; ctx.lineWidth=3; 
        ctx.beginPath(); ctx.moveTo(disc.x - view.x, disc.y - view.y); 
        ctx.lineTo(disc.x - disc.vx*0.05 - view.x, disc.y - disc.vy*0.05 - view.y); 
        ctx.stroke(); ctx.globalAlpha=1; 
      } 

      let fillCol = '#f8fafc';
      if(currentDisc.id==='DRV') fillCol = '#49d0ff';
      else if(currentDisc.id==='PUT') fillCol = '#ff8a3d';
      else if(currentDisc.id==='MID') fillCol = '#f8fafc';

      ctx.save();
      ctx.translate(disc.x - view.x, disc.y - view.y);
      ctx.rotate(disc.orient);
      ctx.fillStyle = fillCol;
      ctx.strokeStyle = 'rgba(0,0,0,.45)';
      const R = disc.r;
      ctx.beginPath(); ctx.ellipse(0,0, R, R*0.45, 0, 0, TAU); ctx.fill(); ctx.stroke();
      ctx.globalAlpha=0.45; ctx.beginPath(); ctx.ellipse(0,0, R*0.85, R*0.35, 0, 0, TAU); ctx.stroke(); ctx.globalAlpha=1;
      ctx.restore();
    }

    function drawAimArrow(){ 
      const b = worldToScreen(disc.x, disc.y); 
      const len = 80 + meter*160; 
      const x2 = b.x + Math.cos(aimAngle)*len; 
      const y2 = b.y + Math.sin(aimAngle)*len; 
      ctx.save(); ctx.scale(DPR,DPR); 
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent3'); ctx.lineWidth=3; ctx.globalAlpha=0.9; 
      ctx.beginPath(); ctx.moveTo(b.x/DPR, b.y/DPR); ctx.lineTo(x2/DPR, y2/DPR); ctx.stroke(); 
      const a=aimAngle; const ah = 10; const aw = 7; 
      ctx.beginPath(); ctx.moveTo(x2/DPR, y2/DPR); 
      ctx.lineTo((x2 - Math.cos(a)*ah + Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah - Math.cos(a)*aw)/DPR); 
      ctx.lineTo((x2 - Math.cos(a)*ah - Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah + Math.cos(a)*aw)/DPR); 
      ctx.closePath(); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.fill(); 
      ctx.restore(); 
    }

    function drawBasket(){
      const x = hole.cupX - view.x;
      const groundY = groundYAt(hole.cupX) - view.y;
      const poleH = 74, cageTop = groundY - 24, rimY = groundY - 46;
      const rimW = 28, cageW = 24;

      ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x, groundY - poleH); ctx.stroke();

      ctx.fillStyle = 'rgba(0,0,0,0.80)';
      ctx.fillRect(x - cageW/2, cageTop, cageW, 8);
      ctx.fillRect(x - 2, cageTop - 10, 4, 10);

      ctx.beginPath(); ctx.ellipse(x, rimY, rimW/2, 4, 0, 0, TAU); ctx.fill();

      ctx.strokeStyle='rgba(0,0,0,0.75)'; ctx.lineWidth=1;
      for(let i=0;i<6;i++){
        const t = i/6 * TAU;
        const cx = x + Math.cos(t) * (rimW/2 - 2);
        ctx.beginPath();
        ctx.moveTo(cx, rimY);
        ctx.lineTo(cx, cageTop);
        ctx.stroke();
      }

      const poleTopY = groundY - poleH;
      const stub = 16;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, poleTopY); ctx.lineTo(x, poleTopY - stub); ctx.stroke();

      // Flag
      const anchorX = x;
      const anchorY = poleTopY - stub;

      const dir  = (windOn ? (windLift >= 0 ? 1 : -1) : 1);
      const wmag = windOn ? Math.abs(windLift) : 0;

      const len    = 34 + wmag*26;
      const height = 10;
      const amp    = 2 + wmag*6;
      const speed  = 2.2 + wmag*2.0;
      const phase  = clock * speed;
      const N      = 8;

      ctx.save();
      const cs = getComputedStyle(document.documentElement);
      const flagCol = cs.getPropertyValue('--accent').trim() || '#ff8a3d';
      ctx.fillStyle = flagCol;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t = i/N;
        const px = anchorX + dir * t * len;
        const wave = Math.sin(phase + t*TAU) * amp * (0.6 + 0.4*Math.cos(t*TAU*0.5));
        const py = anchorY + wave;
        if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      for(let i=N;i>=0;i--){
        const t = i/N;
        const px = anchorX + dir * t * len;
        const wave = Math.sin(phase + t*TAU + 0.6) * amp * (0.6 + 0.4*Math.cos(t*TAU*0.5));
        const py = anchorY + height + wave*0.6;
        ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();

      const tipX = anchorX + dir * len;
      const tipY = anchorY + Math.sin(phase + TAU)*amp*0.6 + height*0.5;
      ctx.beginPath();
      ctx.moveTo(tipX,               tipY - height*0.35);
      ctx.lineTo(tipX + dir*6,       tipY);
      ctx.lineTo(tipX,               tipY + height*0.35);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fill();

      ctx.restore();
    }

    function checkBasketCatch(){
      const x = disc.x, y = disc.y, vy = disc.vy;
      const rimY = groundYAt(hole.cupX) - 46;
      const cageTop = groundYAt(hole.cupX) - 24;
      const rimHalf = 14;
      if(vy > 30 && y > rimY-6 && y < cageTop+6 && Math.abs(x - hole.cupX) < rimHalf){
        return true;
      }
      return false;
    }

    function drawVignette(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.2,w*0.5,h*0.55,Math.max(w,h)*0.7); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h); }

    function draw(){
      ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
      drawSkyGradient();
      drawSun();
      drawClouds();
      drawMountains();

      if(!hole){ drawVignette(); return; }

      drawWaterBodies();

      const cs = getComputedStyle(document.documentElement);
      ctx.fillStyle = cs.getPropertyValue('--fg');
      ctx.beginPath(); ctx.moveTo(hole.points[0].x - view.x, hole.h - view.y + 100);
      for(const p of hole.points){ ctx.lineTo(p.x - view.x, p.y - view.y); }
      ctx.lineTo(hole.points[hole.points.length-1].x - view.x, hole.h - view.y + 100); ctx.closePath(); ctx.fill();

      drawGrass();

      for(const s of hole.sands){ drawBunkerHole(s); }

      drawScenery();
      drawBasket();

      for(const p of particles){
        let c = '#ffffff';
        if(p.type==='spark') c = getComputedStyle(document.documentElement).getPropertyValue('--accent');
        else if(p.type==='sand') c = '#b48a5a';
        else if(p.type==='dust') c = '#9aa2aa';
        else if(p.type==='splash') c = '#49d0ff';
        ctx.globalAlpha = Math.max(0, p.life/0.6);
        ctx.fillStyle=c; ctx.beginPath(); ctx.arc(p.x - view.x, p.y - view.y, 2.2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
      }

      drawDisc();
      if(aiming){ drawAimArrow(); }

      drawVignette();
    }

    // ===== Resize
    function resize(){ DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); view.w = canvas.width/DPR; view.h = canvas.height/DPR; buildBackdrop(); }
    window.addEventListener('resize', resize); resize();

    // ===== Main loop
    let last=0; let clock=0;
    function loop(t){ const now=t/1000; const dt = Math.min(0.033, last? now-last: 0.016); last=now; clock += dt; update(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // ===== Audio unlock on first interaction
    window.addEventListener('pointerdown', () => {
      try { Sfx.init(); } catch {}
      if (chkAudio && chkAudio.checked) {
        try { Sfx.setEnabled(true); } catch {}
        try { AudioMini.setEnabled(true); } catch {}
      }
    }, { once:true });

    // ===== UI wiring
    btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; Sfx.init(); newRound(); });
    btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; Sfx.init(); newRound(); });
    btnNewRound.addEventListener('click', ()=>{ Sfx.init(); newRound(); });
    btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
    btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });
    chkReduced.addEventListener('change', ()=>{ reducedMotion = chkReduced.checked; });
    chkAudio.addEventListener('change', ()=>{ const on = chkAudio.checked; Sfx.setEnabled(on); AudioMini.setEnabled(on); });
    chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; updateWindUI(); AudioMini.setWind(windOn); });

    // initialize toggles' effects
    Sfx.setEnabled(chkAudio.checked);
    AudioMini.setEnabled(chkAudio.checked);
    AudioMini.setWind(windOn);

    buildDiscs(); updateWindUI();
  }
})();
</script>
</body>
</html>
