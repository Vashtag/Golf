
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Dusk Drive ‚Äî Disc Golf (valley-driven water & sand)</title>
<style>
  :root{
    /* defaults; overridden per biome at runtime */
    --bg1:#a54720; --bg2:#f38e41; --bg3:#ffe6ba; --water:#30160f;
    --fg:#050607; --text:#e6edf3; --muted:#a9b1ba;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(5,6,7,.65); --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .hud .btn{pointer-events:auto}

  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1100px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}
  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .small{font-size:.9rem;color:var(--muted)}
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}
  @media (orientation:portrait){ #landscapeHint{display:flex} }
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Dusk Drive side-view game canvas"></canvas></div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="topbar">
      <div class="row">
        <div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
        <div class="chip"><span class="label">Par</span> <strong id="parLabel">3</strong></div>
        <div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
      </div>
      <div class="row">
        <div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="panel controls">
        <div class="seg" id="clubSeg" role="group" aria-label="Disc select"></div>
        <div class="seg" id="spinSeg" role="group" aria-label="Release angle">
          <button class="btn" data-spin="-1" aria-pressed="false" title="Hyzer (‚àí15¬∞)">Hyzer</button>
          <button class="btn" data-spin="0"  aria-pressed="true"  title="Flat (0¬∞)">Flat</button>
          <button class="btn" data-spin="1"  aria-pressed="false" title="Anhyzer (+15¬∞)">Anhy</button>
        </div>
        <div class="seg" id="handSeg" role="group" aria-label="Throw style">
          <button class="btn" data-hand="RHBH" aria-pressed="true" title="Right-hand backhand">RHBH</button>
          <button class="btn" data-hand="LHBH" aria-pressed="false" title="Left-hand backhand">LHBH</button>
        </div>
        <button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
      </div>
    </div>

    <div class="powermeter" id="powermeter" aria-hidden="true"><div class="fill" id="powerfill"></div></div>
  </div>

  <!-- Screens -->
  <div id="screenIntro" class="screen" role="dialog" aria-modal="true">
    <div class="card">
      <h1>ü•è Dusk Drive ‚Äî Disc Golf</h1>
      <div class="sub">Drag to aim, hold to charge, release to throw. Hyzer/flat/anhyzer, vertical wind &amp; glide, varied terrain.</div>
      <div class="grid">
        <div class="tag">Drivers ‚Ä¢ Fairways ‚Ä¢ Mids ‚Ä¢ Putters</div>
        <div class="tag">Vertical Wind &amp; Lift</div>
        <div class="tag">Turn/Fade Curve</div>
        <div class="tag">Procedural Holes (+variants)</div>
      </div>
      <p class="small" style="margin-top:.7rem">Best in landscape ‚Ä¢ Mobile-friendly ‚Ä¢ Haptics on chains</p>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlay">Start Round</button></div>
    </div>
  </div>

  <div id="screenSummary" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Round Complete</h2>
      <p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
      <div class="grid" id="holeBreakdown"></div>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
    </div>
  </div>

  <div id="screenSettings" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Settings</h2>
      <div class="grid">
        <label class="chip" style="justify-content:space-between">
          <span>Reduced motion</span>
          <input type="checkbox" id="chkReduced" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Audio (ambience &amp; SFX)</span>
          <input type="checkbox" id="chkAudio" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Wind (toggle)</span>
          <input type="checkbox" id="chkWind" checked />
        </label>
      </div>
      <p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
      <div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
    </div>
  </div>

  <div id="landscapeHint"><div class="card small">For best experience, rotate to landscape.</div></div>

<script>
(function initWhenReady(){
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', main, { once:true });
  } else { main(); }

  function main(){
    const TAU = Math.PI*2;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // ===== UI Elements
    const elHole = document.getElementById('holeNum');
    const elHolesTotal = document.getElementById('holesTotal');
    const elPar = document.getElementById('parLabel');
    const elStrokes = document.getElementById('strokes');
    const elWindVal = document.getElementById('windVal');
    const elWindArrow = document.getElementById('windArrow');
    const elPowermeter = document.getElementById('powermeter');
    const elPowerfill = document.getElementById('powerfill');
    const clubSeg = document.getElementById('clubSeg');
    const spinSeg = document.getElementById('spinSeg');
    const handSeg = document.getElementById('handSeg');

    const screenIntro = document.getElementById('screenIntro');
    const screenSummary = document.getElementById('screenSummary');
    const screenSettings = document.getElementById('screenSettings');
    const btnPlay = document.getElementById('btnPlay');
    const btnPlayAgain = document.getElementById('btnPlayAgain');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnSettings = document.getElementById('btnSettings');
    const btnCloseSettings = document.getElementById('btnCloseSettings');
    const chkReduced = document.getElementById('chkReduced');
    const chkAudio = document.getElementById('chkAudio');
    const chkWind = document.getElementById('chkWind');

    const sumStrokes = document.getElementById('sumStrokes');
    const sumPar = document.getElementById('sumPar');
    const sumScore = document.getElementById('sumScore');
    const holeBreakdown = document.getElementById('holeBreakdown');

    // ===== Game Config & State
    const HOLES_PER_ROUND = 3; elHolesTotal.textContent = HOLES_PER_ROUND;
    const WORLD = { w: 3400, h: 950 };
    let view = { x:0, y:0, w:0, h:0 };

    // OPTIM: cached styles/gradients
    const cached = {
      skyGradient: null,
      colors: { accent:'#ff8a3d', accent2:'#49d0ff', accent3:'#86efac', water:'#30160f', fg:'#050607' }
    };
    function refreshColorsFromCSS(){
      const root = getComputedStyle(document.documentElement);
      cached.colors.accent  = root.getPropertyValue('--accent').trim()  || '#ff8a3d';
      cached.colors.accent2 = root.getPropertyValue('--accent2').trim() || '#49d0ff';
      cached.colors.accent3 = root.getPropertyValue('--accent3').trim() || '#86efac';
      cached.colors.water   = root.getPropertyValue('--water').trim()   || '#30160f';
      cached.colors.fg      = root.getPropertyValue('--fg').trim()      || '#050607';
    }
    function rebuildSkyGradient(){
      const h = canvas.height / DPR;
      const cs = getComputedStyle(document.documentElement);
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,    cs.getPropertyValue('--bg3').trim());
      g.addColorStop(0.55, cs.getPropertyValue('--bg2').trim());
      g.addColorStop(1,    cs.getPropertyValue('--bg1').trim());
      cached.skyGradient = g;
    }

    // Quality scaling (Reduced Motion + simple frame EMA)
    let reducedMotion = false;
    let frameEMA = 1/60; // seconds
    function qualityScale(){
      let q = reducedMotion ? 0.6 : 1.0;
      if(frameEMA > 0.028) q = Math.min(q, 0.6);
      else if(frameEMA > 0.022) q = Math.min(q, 0.75);
      return q;
    }

    // Discs
    const DISCS = [
      { id:'DRV', name:'Driver',  speed:1.20, glide:1.00, turn:-2.0, fade:2.5 },
      { id:'FAI', name:'Fairway', speed:0.92, glide:1.05, turn:-1.5, fade:2.0 },
      { id:'MID', name:'Mid',     speed:0.80, glide:1.10, turn:-1.0, fade:1.4 },
      { id:'PUT', name:'Putter',  speed:0.62, glide:1.00, turn:-0.3, fade:0.9 }
    ];

    // Surfaces
    const SURF = {
      fairway: { fric: 740,  rest: 0.14 },
      rough:   { fric: 1000, rest: 0.10, powerMul: 0.88 },
      sand:    { fric: 1400, rest: 0.05, powerMul: 0.70 },
      green:   { fric: 520,  rest: 0.10 },
      rock:    { fric: 620,  rest: 0.18 }
    };

    // ==== DISC PHYSICS ====
    const GRAV = 1500;
    const NOSE_FAST_DEG = -6;
    const NOSE_SLOW_DEG =  7;

    // ===== Vertical wind (lift only)
    let windOn = true;
    let windLift = 0;             // -1 .. +1 (down .. up)
    const WIND_LIFT_SCALE = 0.50; // ¬±50% lift modulation at max

    // ===== Persistent Powerups (round-long)
    const Owned = new Set();
    const PU = {
      dragMul:1, curveMul:1, spinDecayMul:1, windScaleMul:1, sandFricMul:1, sandPowerMin:0.70, rimHalfBonus:0, vyThreshMul:1
    };
    function resetPowerups(){
      Owned.clear();
      PU.dragMul=1; PU.curveMul=1; PU.spinDecayMul=1; PU.windScaleMul=1;
      PU.sandFricMul=1; PU.sandPowerMin=0.70; PU.rimHalfBonus=0; PU.vyThreshMul=1;
    }
    function grantRandomPowerup(){
      const pool = ['airfoil','gyro','wind','sand','chain'].filter(id=>!Owned.has(id));
      if(!pool.length){ addToast('All powerups acquired'); return; }
      const id = pool[(Math.random()*pool.length)|0];
      Owned.add(id);
      if(id==='airfoil'){ PU.dragMul *= 0.93; addToast('Powerup: Airfoil Polish'); }
      else if(id==='gyro'){ PU.spinDecayMul *= 0.88; PU.curveMul *= 0.97; addToast('Powerup: Gyro Stabilizer'); }
      else if(id==='wind'){ PU.windScaleMul *= 0.80; addToast('Powerup: Wind Tamer'); }
      else if(id==='sand'){ PU.sandFricMul *= 0.90; PU.sandPowerMin = Math.max(PU.sandPowerMin, 0.80); addToast('Powerup: Sand Wedges'); }
      else if(id==='chain'){ PU.rimHalfBonus = Math.min(3, PU.rimHalfBonus + 2); PU.vyThreshMul *= 0.90; addToast('Powerup: Chain Magnet'); }
    }

    // Release angle / throw style
    let releaseMode = 0;
    function releaseDeg(){ return releaseMode * 15; }
    let hand = 'RHBH';

    // ---------- Helpers ----------
    const RAND_MAX = 4294967295;
    function hash32(x){ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return x>>>0; }
    function rand01(seed, i){ return hash32((seed ^ (i|0))>>>0) / RAND_MAX; }
    function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    const ease = (t)=>t*t*(3-2*t);
    function normalizeAngle(a){ while(a > Math.PI) a -= TAU; while(a < -Math.PI) a += TAU; return a; }

    // ===== Ambient Audio (hum + wind) with context suspend/resume
    const AudioMini = (()=>{ let ctx=null, windNode=null, masterGain=null; let inited=false;
      function init(){ if(inited) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = ctx.createGain(); masterGain.gain.value=0.18; masterGain.connect(ctx.destination);
        const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
        const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
        const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(masterGain); o1.start(); o2.start();
        const buff = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
        const data = buff.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
        const noise = ctx.createBufferSource(); noise.buffer=buff; noise.loop=true;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=400;
        const wg = ctx.createGain(); wg.gain.value=0.05; noise.connect(lp); lp.connect(wg); wg.connect(masterGain); noise.start();
        windNode = wg; inited=true; if(!windOn) wg.gain.value=0.0;
      }
      async function setEnabled(on){
        if(on){
          init();
          try{ if(ctx.state==='suspended') await ctx.resume(); }catch{}
          if(masterGain) masterGain.gain.value = 0.18;
        } else {
          if(masterGain) masterGain.gain.value = 0.0;
          try{ if(ctx && ctx.state==='running') await ctx.suspend(); }catch{}
        }
      }
      function setWind(on){ if(!inited||!windNode) return; windNode.gain.value = on?0.05:0.0; }
      return { setEnabled, setWind, init };
    })();

    // ===== SFX: randomized throw & chain samples from /audio (kept as <audio>)
    const Sfx = (()=>{
      let enabled = false;
      let unlocked = false; // user-gesture gate (iOS/Chrome mobile)
      const throws = [];
      const chains = [];

      function make(path, vol=1.0){
        const a = new Audio(path); a.preload = 'auto'; a.volume = vol; return a;
      }
      function preload(){
        if(throws.length || chains.length) return;
        for(let i=1;i<=7;i++) throws.push(make(`./audio/throw${i}.mp3`, 0.9));
        for(let i=1;i<=4;i++) chains.push(make(`./audio/chain${i}.mp3`, 1.0));
      }
      function init(){ preload(); unlocked = true; }
      function setEnabled(on){
        enabled = !!on;
        if(!enabled){
          [...throws, ...chains].forEach(a=>{ try{ a.pause(); a.currentTime = 0; }catch{} });
        }
      }
      function playFrom(arr, vol=1.0, rateMin=0.98, rateMax=1.02){
        if(!enabled || !unlocked || !arr.length) return;
        const i = (Math.random()*arr.length)|0;
        const srcUrl = arr[i].src || arr[i].currentSrc;
        const a = new Audio(srcUrl);
        a.preload = 'auto';
        a.volume = vol;
        a.playbackRate = rateMin + Math.random()*(rateMax-rateMin);
        a.play().catch(()=>{});
      }
      return {
        init,
        setEnabled,
        playThrow(){ playFrom(throws, 0.9, 0.97, 1.06); },
        playChain(){ playFrom(chains, 1.0, 0.96, 1.04); }
      };
    })();

    // Particles
    const particles=[];
    function spawnParticles(type, x, y, count){
      const q = qualityScale();
      const N = Math.max(1, Math.floor(count * (0.7 + 0.3*q)));
      for(let i=0;i<N;i++){
        const a = Math.random()*TAU; const sp = (type==='spark'? 160 + Math.random()*160 : 80+Math.random()*120);
        const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp - (type==='spark'?0:200);
        particles.push({ type, x, y, vx, vy, life: type==='spark'? 0.25: (type==='sand'?0.5:0.6) });
      }
    }

    // Canvas toasts (minimal) with cached width
    const toasts=[];
    function addToast(msg){
      ctx.save(); ctx.font = '600 14px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial';
      const width = Math.ceil(ctx.measureText(msg).width);
      ctx.restore();
      toasts.push({ msg, t:0, dur:2.2, width });
    }

    // === Biomes (colors + mountain profiles) ===
    const BIOMES = [
      { name:'dunes',
        sky:{ bg1:'#9d3e25', bg2:'#f38e41', bg3:'#ffe6ba', water:'#30160f' },
        layers:[
          {par:0.08, base:0.52, a1:30,  a2:16,  f1:0.00050, f2:0.00020, shade:0.02, shape:'sin'},
          {par:0.12, base:0.56, a1:50,  a2:24,  f1:0.00065, f2:0.00026, shade:0.035,shape:'sin'},
          {par:0.18, base:0.61, a1:70,  a2:34,  f1:0.00082, f2:0.00032, shade:0.05, shape:'sin'},
          {par:0.26, base:0.66, a1:104, a2:48,  f1:0.00100, f2:0.00042, shade:0.07,shape:'sin'},
          {par:0.33, base:0.70, a1:116, a2:54,  f1:0.00115, f2:0.00048, shade:0.085,shape:'sin'},
          {par:0.40, base:0.74, a1:126, a2:58,  f1:0.00125, f2:0.00052, shade:0.10, shape:'sin'}
        ]
      },
      { name:'crags',
        sky:{ bg1:'#5b1a2b', bg2:'#d5425a', bg3:'#f8c3da', water:'#2c0f19' },
        layers:[
          {par:0.06, base:0.50, a1:60,  a2:36,  f1:0.00055, f2:0.00022, shade:0.02, shape:'crag'},
          {par:0.10, base:0.58, a1:95,  a2:52,  f1:0.00075, f2:0.00030, shade:0.05, shape:'crag'},
          {par:0.16, base:0.64, a1:140, a2:70,  f1:0.00095, f2:0.00040, shade:0.08, shape:'crag'},
          {par:0.24, base:0.70, a1:170, a2:86,  f1:0.00115, f2:0.00055, shade:0.11,shape:'crag'},
          {par:0.36, base:0.76, a1:190, a2:96,  f1:0.00135, f2:0.00065, shade:0.13,shape:'crag'}
        ]
      },
      { name:'hills',
        sky:{ bg1:'#233d6d', bg2:'#5d79b0', bg3:'#cfe2ff', water:'#0e2233' },
        layers:[
          {par:0.10, base:0.54, a1:36,  a2:18,  f1:0.00044, f2:0.00018, shade:0.02, shape:'round'},
          {par:0.16, base:0.60, a1:60,  a2:28,  f1:0.00062, f2:0.00024, shade:0.04, shape:'round'},
          {par:0.22, base:0.66, a1:90,  a2:42,  f1:0.00080, f2:0.00032, shade:0.06, shape:'round'},
          {par:0.30, base:0.71, a1:115, a2:56,  f1:0.00098, f2:0.00040, shade:0.08, shape:'round'},
          {par:0.38, base:0.75, a1:132, a2:64,  f1:0.00112, f2:0.00048, shade:0.10, shape:'round'}
        ]
      },
      { name:'mesas',
        sky:{ bg1:'#6e3b1b', bg2:'#cf7b35', bg3:'#ffe1b0', water:'#2a1a12' },
        layers:[
          {par:0.08, base:0.54, a1:42,  a2:20,  f1:0.00058, f2:0.00022, shade:0.02, shape:'mesa'},
          {par:0.13, base:0.60, a1:70,  a2:32,  f1:0.00076, f2:0.00030, shade:0.04, shape:'mesa'},
          {par:0.20, base:0.66, a1:96,  a2:46,  f1:0.00096, f2:0.00038, shade:0.06, shape:'mesa'},
          {par:0.28, base:0.72, a1:120, a2:56,  f1:0.00116, f2:0.00046, shade:0.08, shape:'mesa'},
          {par:0.36, base:0.76, a1:140, a2:64,  f1:0.00128, f2:0.00054, shade:0.10, shape:'mesa'}
        ]
      }
    ];

    function applyTheme(biome){
      const root = document.documentElement.style;
      root.setProperty('--bg1', biome.sky.bg1);
      root.setProperty('--bg2', biome.sky.bg2);
      root.setProperty('--bg3', biome.sky.bg3);
      root.setProperty('--water', biome.sky.water);
      refreshColorsFromCSS();
      rebuildSkyGradient();
    }

    // Backdrop (sun + clouds + mountains) with pre-rendered layers/sprites
    let currentBiome = BIOMES[0];
    const backdrop = {
      seed:(Math.random()*1e9)|0,
      mountains:[],
      mountainsImg:[], // offscreen canvases per layer
      sun:null,
      clouds:[],
      cloudDir:1,
      windmills:[]
    };

    function triangleWave(x){ return (2/Math.PI)*Math.asin(Math.sin(x)); }
    function mesaWave(x){ const k=2.2; return Math.tanh(Math.sin(x)*k)/Math.tanh(k); }
    function roundWave(x){ const s=Math.sin(x); return Math.sign(s)*Math.pow(Math.abs(s),0.85); }
    function cragWave(x){ return 0.7*triangleWave(x) + 0.3*Math.sin(x*3.0); }
    function shapeSample(shape, x){
      switch(shape){
        case 'mesa':   return mesaWave(x);
        case 'round':  return roundWave(x);
        case 'crag':   return cragWave(x);
        case 'sin':
        default:       return Math.sin(x);
      }
    }

    function buildBackdrop(){
      const L = [];
      currentBiome.layers.forEach((spec, i)=>{
        const s = (backdrop.seed ^ hash32((spec.par*1000)|0) ^ i)>>>0;
        const base = WORLD.h*spec.base;
        const ph   = rand01(s,1)*TAU;
        const curv = { a: 10 + rand01(s,3)*16, f: 0.0012 + rand01(s,4)*0.0006, ph: rand01(s,2)*TAU };
        L.push({ parallax:spec.par, base, a1:spec.a1, a2:spec.a2, f1:spec.f1, f2:spec.f2, ph, shade:spec.shade, curv, shape:spec.shape });
      });
      backdrop.mountains = L;

      // Sun
      const u = 0.20 + rand01(backdrop.seed,101)*0.60;
      const v = 0.16 + rand01(backdrop.seed,102)*0.20;
      const phase = rand01(backdrop.seed,103)*TAU;
      const baseR = 20 + Math.floor(rand01(backdrop.seed,104)*12);
      backdrop.sun = { u, v, phase, baseR };

      // Clouds
      backdrop.cloudDir = rand01(backdrop.seed,399) < 0.5 ? -1 : 1;
      buildCloudField();

      // Windmills
      buildWindmills();

      // pre-render mountain layers
      rebuildMountainsOffscreen();
    }

    function buildCloudField(){
      backdrop.clouds.length = 0;
      const count = 3 + Math.floor(rand01(backdrop.seed,300)*4);
      for(let i=0;i<count;i++){
        const s = hash32(backdrop.seed ^ (0xA11C10 + i*131));
        const u = rand01(s,1);
        const v = 0.12 + (i+1)/(count+1) * 0.42 + (rand01(s,2)-0.5)*0.05;
        const parX = 0.04 + rand01(s,3)*0.05;
        const parY = 0.015 + rand01(s,4)*0.02;
        const speed = backdrop.cloudDir * (4 + rand01(s,6)*6);
        const alpha = 0.05 + rand01(s,7)*0.08;
        const scale = 0.9 + rand01(s,8)*1.6;
        const cloud = { seed:s, u, v, parX, parY, speed, alpha, scale, sprite:null, spriteW:0, spriteH:0 };
        cloud.sprite = makeCloudSprite(cloud);
        backdrop.clouds.push(cloud);
      }
    }

    // prerender a fluffy cloud sprite per cloud (seed+scale)
    function makeCloudSprite(C){
      const cvs = document.createElement('canvas');
      const cctx = cvs.getContext('2d');
      const width  = Math.ceil(240 * C.scale);
      const height = Math.ceil(120 * C.scale);
      cvs.width = width; cvs.height = height;
      const cx = width/2, cy = height/2;

      cctx.globalCompositeOperation = 'lighter';
      cctx.globalAlpha = C.alpha;

      const baseR = 28 * C.scale;
      const puffCount = 4 + Math.floor(rand01(C.seed,11)*4);
      for(let i=0;i<puffCount;i++){
        const r  = (baseR + rand01(C.seed,20+i)*22*C.scale);
        const ox = (i - (puffCount-1)/2) * (r*0.9) + (rand01(C.seed,30+i)-0.5)*r*0.3;
        const oy = (rand01(C.seed,40+i)-0.5) * r * 0.35;
        const px = cx + ox, py = cy + oy;
        const g = cctx.createRadialGradient(px, py, r*0.35, px, py, r*1.3);
        g.addColorStop(0,'rgba(255,255,255,0.55)');
        g.addColorStop(1,'rgba(255,255,255,0.00)');
        cctx.fillStyle = g; cctx.beginPath(); cctx.arc(px, py, r*1.3, 0, TAU); cctx.fill();
      }

      // Subtle core + shadow
      cctx.globalAlpha = C.alpha;
      const coreR = Math.min(width, height) * 0.28;
      const core = cctx.createRadialGradient(cx, cy, coreR*0.1, cx, cy, coreR);
      core.addColorStop(0,'rgba(255,255,255,0.18)');
      core.addColorStop(1,'rgba(255,255,255,0.00)');
      cctx.fillStyle = core; cctx.beginPath(); cctx.arc(cx, cy, coreR, 0, TAU); cctx.fill();

      const sh = cctx.createRadialGradient(cx + coreR*0.1, cy + coreR*0.4, coreR*0.15, cx + coreR*0.1, cy + coreR*0.4, coreR*1.1);
      sh.addColorStop(0, 'rgba(0,0,0,0.06)'); sh.addColorStop(1, 'rgba(0,0,0,0.00)');
      cctx.fillStyle = sh; cctx.beginPath(); cctx.arc(cx + coreR*0.1, cy + coreR*0.4, coreR*1.1, 0, TAU); cctx.fill();

      C.spriteW = width; C.spriteH = height;
      return cvs;
    }

    function buildWindmills(){
      backdrop.windmills.length = 0;
      const count = 1 + Math.floor(rand01(backdrop.seed,810)*4);
      const used = [];
      for(let i=0, tries=count*8; i<tries && backdrop.windmills.length<count; i++){
        const s = hash32(backdrop.seed ^ (0xC0FFEE + i*997));
        const u = 0.12 + rand01(s,1)*0.76;
        const x = WORLD.w * u;
        if(!used.every(px => Math.abs(px - x) > 420)) continue;
        used.push(x);

        const h = 90 + rand01(s,2)*48;
        const r = 26 + rand01(s,3)*10;
        const speed = 0.8 + rand01(s,4)*1.0;
        const spin0 = rand01(s,5)*TAU;
        const tilt = (rand01(s,6)-0.5) * (14*Math.PI/180);

        backdrop.windmills.push({ x, h, r, speed, spin0, tilt });
      }
    }

    function mountainYAt(L, wx){
      let y = L.base
        - shapeSample(L.shape, wx*L.f1)*L.a1
        - shapeSample(L.shape, wx*L.f2 + L.ph)*L.a2;
      if(L.curv){
        y -= Math.sin(wx*L.curv.f   + L.curv.ph)      * L.curv.a;
        y -= Math.sin(wx*L.curv.f*2 + L.curv.ph*1.3) * (L.curv.a*0.45);
      }
      return y;
    }

    function rebuildMountainsOffscreen(){
      backdrop.mountainsImg = [];
      const w = WORLD.w, h = WORLD.h;
      for(let idx=0; idx<backdrop.mountains.length; idx++){
        const L = backdrop.mountains[idx];
        const off = document.createElement('canvas');
        off.width = w; off.height = h;
        const ox = off.getContext('2d');
        ox.fillStyle = `rgba(0,0,0,${0.18 + L.shade})`;
        const step = Math.max(8, 16 - idx*2);
        ox.beginPath(); ox.moveTo(0,h);
        for(let x=0;x<=w;x+=step){
          const y = mountainYAt(L, x);
          ox.lineTo(x, y);
        }
        ox.lineTo(w,h); ox.closePath(); ox.fill();
        backdrop.mountainsImg.push(off);
      }
    }

    // ===== World / Hole
    const disc = { x:0,y:0,vx:0,vy:0,r:7.5, atRest:true, onGround:true, lastSafe:{x:0,y:0}, orient:0,
                   spin:0, spin0:1, bank:0 };
    let strokes=0;
    let holeIndex=0, roundData=null;
    let hole=null;

    // Aim/meter state
    let aiming=false, aimAngle=0, meter=0, meterDir=1, meterOn=false;

    // Scenery
    let scenery = { trees:[], rocks:[], fences:[] };

    // ===== Procedural hole (unchanged core)
    function genHole(){
      const w = WORLD.w, h = WORLD.h;
      const step=40;

      const tilt = (Math.random()*2-1) * 0.16;
      const tiltAmp = 160;

      let seed = Math.random()*9999;
      function nrand(){ seed = Math.sin(seed)*10000; return seed - Math.floor(seed); }
      const amp1 = 70 + nrand()*110, freq1 = 1/(520+ nrand()*420);
      const amp2 = 22 + nrand()*42,  freq2 = 1/(220 + nrand()*250);

      const baseY0 = h*0.72;
      const points=[];

      for(let x=0;x<=w;x+=step){
        const t = x/w;
        const tiltOffset = (t-0.5) * tiltAmp * tilt;
        const y = baseY0 + tiltOffset
                - Math.sin(x*freq1)*amp1
                - Math.sin(x*freq2)*amp2;
        points.push({x,y});
      }

      const featureCount = Math.floor(Math.random()*3);
      for(let f=0; f<featureCount; f++){
        const cx = lerp(w*0.18, w*0.82, Math.random());
        const sigma = 120 + Math.random()*220;
        const amp = (Math.random()<0.5? -1:1) * (50 + Math.random()*90);
        for(let i=0;i<points.length;i++){
          const dx = points[i].x - cx;
          const k = Math.exp(-(dx*dx)/(2*sigma*sigma));
          points[i].y += amp * k;
        }
      }

      if(Math.random() < 0.33){
        const cx = lerp(w*0.30, w*0.70, Math.random());
        const up = Math.random() < 0.5 ? -1 : 1;
        const drop = up * (120 + Math.random()*120);
        const sharp = 60 + Math.random()*80;
        for(let i=0;i<points.length;i++){
          const dx = (points[i].x - cx) / sharp;
          const s = 1/(1+Math.exp(-dx));
          points[i].y += drop * s;
        }
      }

      const cupX = lerp(w*0.68, w*0.90, Math.random());

      const gWidth = 200 + Math.random()*160;
      const gx0=cupX-gWidth/2, gx1=cupX+gWidth/2;
      const greenSlope = (Math.random()*0.6-0.3);
      let greenY = 0;

      for(let i=0;i<points.length;i++){
        if(points[i].x>=gx0 && points[i].x<=gx1){
          const t = (points[i].x-gx0)/gWidth;
          const gy = (baseY0-30) + (Math.sin(points[i].x*freq2)*6) + greenSlope*(t-0.5)*40;
          points[i].y = gy;
          greenY = gy;
        }
      }

      function scanBasins(){
        const n = points.length, out=[];
        const bankMin = 32, bankMax = 64;
        for(let i=2;i<n-2;i++){
          const yL = points[i-1].y, yC = points[i].y, yR = points[i+1].y;
          if(!(yC < yL && yC < yR)) continue;

          const bottom = yC;
          let surface = bottom + (bankMin + Math.random()*(bankMax - bankMin));

          let L=i, R=i;
          while(L>0 && points[L].y <= surface) L--;
          while(R<n-1 && points[R].y <= surface) R++;
          const leftShoulder  = Math.min(points[Math.max(L-1,0)].y,   points[Math.max(L-2,0)].y);
          const rightShoulder = Math.min(points[Math.min(R+1,n-1)].y, points[Math.min(R+2,n-1)].y);
          const spillY = Math.min(leftShoulder, rightShoulder) - 8;
          if(surface > spillY) surface = spillY;

          L=i; R=i;
          while(L>0 && points[L].y <= surface) L--;
          while(R<n-1 && points[R].y <= surface) R++;

          const x0 = points[L].x, x1 = points[R].x;
          const width = x1 - x0;
          const cx = (x0 + x1) * 0.5;
          out.push({ i, x0, x1, width, cx, surfaceY:surface, bottomY:bottom });
        }
        return out;
      }

      const basinsAll = scanBasins();

      const waters=[];
      (function buildWaters(){
        const minWidth = 160;
        const waterCandidates = basinsAll
          .filter(b => b.width >= minWidth)
          .sort((a,b)=>{
            const dw = b.width - a.width;
            if(Math.abs(dw) > 1) return dw;
            const ma = Math.abs(a.cx - w*0.5);
            const mb = Math.abs(b.cx - w*0.5);
            return ma - mb;
          });

        function clipAwayFromGreen(x0,x1){
          if(x0 < gx1 && x1 > gx0){
            const leftOverlap  = Math.max(0, gx1 - x0);
            const rightOverlap = Math.max(0, x1 - gx0);
            if(leftOverlap < rightOverlap) x0 = gx1; else x1 = gx0;
          }
          return [x0,x1];
        }

        for(const b of waterCandidates){
          if(waters.length >= 2) break;
          let x0 = clamp(b.x0 + 1, 60, w-60);
          let x1 = clamp(b.x1 - 1, 60, w-60);
          [x0,x1] = clipAwayFromGreen(x0,x1);
          if(x1 - x0 < minWidth) continue;
          const overlaps = waters.some(p => Math.min(p.x+p.w, x1) - Math.max(p.x, x0) > 40);
          if(overlaps) continue;
          waters.push({ x:x0, w:(x1-x0), y:b.surfaceY, h: h - b.surfaceY + 60, seed:(Math.random()*1e9)|0 });
        }

        if(!waters.length){
          const near = basinsAll.sort((a,b)=>Math.abs(a.cx-cupX)-Math.abs(b.cx-cupX))[0];
          if(near){
            let x0 = clamp(near.x0 + 1,60,w-60), x1 = clamp(near.x1 - 1,60,w-60);
            [x0,x1] = clipAwayFromGreen(x0,x1);
            if(x1-x0 >= minWidth){
              waters.push({ x:x0, w:(x1-x0), y:near.surfaceY, h:h-near.surfaceY+60, seed:(Math.random()*1e9)|0 });
            }
          }
        }
      })();

      const sands=[];
      function placeBunkerFromBasin(b, sizeScale=0.35){
        let cx = clamp(b.cx, 80, w-80);
        for(const ww of waters){
          if(cx >= ww.x && cx <= ww.x+ww.w){
            cx = (cx < ww.x + ww.w*0.5)? (ww.x - 20) : (ww.x + ww.w + 20);
          }
        }
        if(cx > gx0-18 && cx < gx1+18) return false;
        const cy = sampleY(points, cx) - 8;
        const r = clamp(b.width*sizeScale, 36, 90);
        sands.push({ x:cx, y:cy, r, seed:(Math.random()*1e9)|0 });
        return true;
      }

      const roughs=[];
      const roughN = Math.floor(Math.random()*4);
      for(let i=0;i<roughN;i++){
        const rx = lerp(w*0.20, cupX-140, Math.random());
        const ry = sampleY(points, rx) - 6;
        roughs.push({ x:rx, y:ry, r: 42 + Math.random()*30 });
      }

      const teeX = 120;
      const teeIdx = Math.floor(teeX/step);
      const teeY = points[teeIdx].y - 2;
      points[teeIdx].y = teeY;

      if(Math.random()<0.6){
        const vX = lerp(w*0.40, w*0.62, Math.random());
        const vIdx = Math.floor(vX/step);
        for(let i=-3;i<=3;i++){
          const k=vIdx+i; if(points[k]) points[k].y += Math.abs(i)* (16 + Math.random()*12);
        }
      }

      const dist = (cupX - teeX);
      let par = 3; if(dist>1900) par=5; else if(dist>1200) par=4;

      const result = {
        w, h, points, step, cupX,
        green:{x0:gx0,x1:gx1,y:0},
        waters,
        sands,
        roughs,
        tee:{x:teeX,y:teeY},
        par
      };

      // Wind Geyser
      (function addGeyser(H){
        const leftBound  = H.tee.x + 360;
        const rightBound = H.cupX - 320;
        let span = rightBound - leftBound;
        if (span < 220){
          span = Math.max(200, (H.cupX - H.tee.x) - 480);
        }
        const gx = clamp(leftBound + Math.random()*span, 140, H.w - 140);

        H.geyser = {
          x: gx,
          rx: 90 + Math.random()*50,
          height: 340 + Math.random()*220,
          strength: 0.60,
          drift: { amp: 24 + Math.random()*26, speed: 0.5 + Math.random()*0.7, phase: Math.random()*TAU },
          seed: (Math.random()*1e9)|0
        };
      })(result);

      return result;
    }

    function sampleY(points, x){
      const step = points[1].x - points[0].x;
      const i = Math.min(Math.max(Math.floor(x/step),0), points.length-2);
      const p0 = points[i], p1 = points[i+1];
      const t = (x - p0.x)/(p1.x - p0.x);
      return lerp(p0.y, p1.y, t);
    }

    function groundYAt(x){ x = clamp(x, 0, hole.w); const i = Math.min(Math.floor(x/hole.step), hole.points.length-2); const p0 = hole.points[i], p1 = hole.points[i+1]; const t = (x - p0.x)/(p1.x - p0.x); return lerp(p0.y, p1.y, t); }

    function surfaceAt(x){
      if(x>=hole.green.x0 && x<=hole.green.x1) return 'green';
      const y = groundYAt(x);
      for(const s of hole.sands){ if(Math.hypot(x - s.x, y - s.y) <= s.r) return 'sand'; }
      for(const r of hole.roughs){ if(Math.hypot(x - r.x, y - r.y) <= r.r) return 'rough'; }
      return 'fairway';
    }

    function inWater(x,y){
      for(const w of hole.waters){
        if(x>=w.x && x<=w.x+w.w && y>=w.y) return true;
      }
      return false;
    }

    // ===== Balloons
    function buildBalloons(){
      hole.balloons = [];
      if(Math.random() < 0.55){
        const count = 1 + (Math.random()<0.5?0:1);
        for(let i=0;i<count;i++){
          const fromLeft = Math.random()<0.5;
          const x = fromLeft ? -120 - Math.random()*220 : hole.w + 120 + Math.random()*220;
          const dir = fromLeft ? 1 : -1;
          hole.balloons.push({
            x, dir,
            speed: 32 + Math.random()*38,
            baseH: 160 + Math.random()*240,
            r: 18 + Math.random()*6,
            hue: (Math.random()*360)|0,
            seed:(Math.random()*1e9)|0,
            popped:false
          });
        }
      }
    }
    function updateBalloons(dt){
      if(!hole?.balloons) return;
      for(let i=hole.balloons.length-1;i>=0;i--){
        const B = hole.balloons[i];
        B.x += B.dir * B.speed * dt;
        const cx = B.x;
        const cy = groundYAt(cx) - (B.baseH + Math.sin(clock*0.9 + (B.seed%1000))*12);
        if((B.dir>0 && cx > hole.w + 260) || (B.dir<0 && cx < -260)){ hole.balloons.splice(i,1); continue; }
        const dx = disc.x - cx, dy = disc.y - cy;
        if(Math.hypot(dx,dy) < (disc.r + B.r)){
          spawnParticles('spark', cx, cy, 18);
          grantRandomPowerup();
          hole.balloons.splice(i,1);
        }
      }
    }
    function drawBalloons(){
      if(!hole?.balloons) return;
      ctx.save();
      for(const B of hole.balloons){
        const cx = B.x - view.x;
        if(cx < -60 || cx > canvas.width/DPR + 60) continue;
        const cyWorld = groundYAt(B.x) - (B.baseH + Math.sin(clock*0.9 + (B.seed%1000))*12);
        const cy = cyWorld - view.y;

        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy + B.r - 2);
        ctx.lineTo(cx, cy + B.r + 22);
        ctx.stroke();

        const col = `hsl(${B.hue},80%,66%)`;
        ctx.fillStyle = col;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath(); ctx.ellipse(cx, cy, B.r*0.9, B.r*1.1, 0, 0, TAU); ctx.fill(); ctx.stroke();

        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(cx - B.r*0.35, cy - B.r*0.25, B.r*0.22, B.r*0.18, 0, 0, TAU); ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(cx - 2, cy + B.r*0.8);
        ctx.lineTo(cx + 2, cy + B.r*0.8);
        ctx.lineTo(cx,     cy + B.r*0.95);
        ctx.closePath(); ctx.fill();
      }
      ctx.restore();
    }

    // ===== Round flow
    function newRound(){
      holeIndex=0;
      roundData={ holes:[], totalPar:0, totalStrokes:0 };
      resetPowerups();
      screenIntro.style.display='none';
      screenSummary.style.display='none';
      nextHole();
    }

    function nextHole(){
      const biome = BIOMES[holeIndex % BIOMES.length];
      currentBiome = biome;
      applyTheme(biome);

      hole = genHole();

      buildScenery();
      buildBalloons();

      backdrop.seed = (Math.random()*1e9)|0;
      buildBackdrop();

      roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par;
      elHole.textContent = (holeIndex+1); elPar.textContent = hole.par;

      windLift = windOn ? (Math.random()*2 - 1) : 0;
      updateWindUI();

      disc.x = hole.tee.x; disc.y = hole.tee.y - disc.r - 1; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; disc.orient=0; disc.spin=0; disc.bank=0; strokes=0; elStrokes.textContent=strokes;
      centerCameraOnDisc();
    }

    function endHole(){
      roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes; holeIndex++;
      if(holeIndex>=HOLES_PER_ROUND){
        sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar; const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
        holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
        screenSummary.style.display='grid';
      } else { nextHole(); }
    }

    // ===== UI build: discs, release, hand (persisted)
    function buildDiscs(){
      clubSeg.innerHTML='';
      DISCS.forEach((d,idx)=>{
        const b=document.createElement('button'); b.className='btn'; b.textContent=d.name; b.dataset.disc=idx;
        b.setAttribute('aria-pressed', idx===1? 'true':'false');
        b.addEventListener('click',()=>selectDisc(idx,true));
        clubSeg.appendChild(b);
      });
      const savedIdx = parseInt(localStorage.getItem('discIdx')||'1',10);
      selectDisc(isFinite(savedIdx)? savedIdx:1, false);
    }
    let currentDisc = DISCS[1];
    function selectDisc(i, persist){ currentDisc = DISCS[i]; [...clubSeg.querySelectorAll('button')].forEach((b,idx)=> b.setAttribute('aria-pressed', idx===i? 'true':'false')); if(persist) localStorage.setItem('discIdx', String(i)); }
    spinSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; releaseMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); localStorage.setItem('releaseMode', String(releaseMode)); });
    handSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; hand = btn.dataset.hand; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); localStorage.setItem('hand', hand); });

    (function restoreControls(){
      const rm = parseInt(localStorage.getItem('releaseMode')||'0',10);
      if([-1,0,1].includes(rm)){ releaseMode = rm; [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', parseInt(b.dataset.spin,10)===rm?'true':'false')); }
      const h = localStorage.getItem('hand')||'RHBH';
      if(['RHBH','LHBH'].includes(h)){ hand = h; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b.dataset.hand===h?'true':'false')); }
    })();

    // ===== Wind UI
    function updateWindUI(){
      const mag = Math.abs(windOn ? windLift : 0);
      elWindVal.textContent = mag.toFixed(1)+'x';
      const rot = (windLift >= 0 ? 180 : 0);
      elWindArrow.style.transform = `rotate(${rot}deg)`;
    }

    // ===== Input (Pointer Events + capture)
    function worldToScreen(x,y){ return { x: (x - view.x)*DPR, y: (y - view.y)*DPR }; }
    function screenToWorld(x,y){ return { x: x/DPR + view.x, y: y/DPR + view.y }; }
    function onPointerDown(e){
      if(!hole || !disc.atRest) return;
      try{ canvas.setPointerCapture?.(e.pointerId); }catch{}
      const w=screenToWorld(e.clientX*DPR,e.clientY*DPR); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x)); aiming = true; meterOn = true; meter = 0; meterDir=1; elPowermeter.dataset.on='1'; e.preventDefault();
    }
    function onPointerMove(e){
      if(!aiming) return;
      const w=screenToWorld(e.clientX*DPR,e.clientY*DPR); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x));
    }
    function onPointerUp(e){
      if(!aiming) return;
      try{ canvas.releasePointerCapture?.(e.pointerId); }catch{}
      aiming=false; meterOn=false; elPowermeter.dataset.on='0'; throwDisc();
    }

    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    // ===== Throw
    function throwDisc(){
      if(!hole || !disc.atRest) return;
      const d = currentDisc;
      const surface = surfaceAt(disc.x); let powerMul = 1.0; if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
      if(surface === 'sand' && PU.sandPowerMin > powerMul) powerMul = PU.sandPowerMin;
      const base = 1650;
      const power = (0.25 + 0.75*meter) * d.speed * powerMul;
      const speed = base * power;
      const dir = aimAngle;

      disc.vx = Math.cos(dir) * speed;
      disc.vy = Math.sin(dir) * speed;

      disc.orient = dir + (NOSE_FAST_DEG * Math.PI/180);
      disc.spin0  = 14 + 20*power;
      disc.spin   = disc.spin0;
      disc.bank   = (releaseMode * 16) * Math.PI/180;

      disc.atRest=false; disc.onGround=false; strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; if(navigator.vibrate) navigator.vibrate(16);
      Sfx.playThrow();
    }

    // ===== Physics update (includes FIX: curve as heading rotation)
    function update(dt){
      if(meterOn){ meter += meterDir * 1.6 * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width = (meter*100).toFixed(1)+'%'; }

      if(!hole){ return; }

      // toasts lifetime
      for(let i=toasts.length-1;i>=0;i--){ const T=toasts[i]; T.t+=dt; if(T.t>T.dur) toasts.splice(i,1); }

      // particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.vy += 1200*dt; p.vx*= (1-0.4*dt); p.vy*=(1-0.06*dt); p.x += p.vx*dt; p.y += p.vy*dt; }

      // balloons
      updateBalloons(dt);

      if(!disc.atRest){
        if(!disc.onGround){
          const v = Math.hypot(disc.vx, disc.vy) || 0.0001;
          const vx = disc.vx, vy = disc.vy;
          const vAngle = Math.atan2(vy, vx);

          const tPow = clamp(v / 1600, 0, 1);
          const spinNorm = clamp(disc.spin / (disc.spin0 || 1), 0, 1);

          const aoaRaw = normalizeAngle(disc.orient - vAngle);
          const aoa = clamp(aoaRaw + 0.06, -0.6, 0.6);
          const dragMulEff = Math.max(0.85, PU.dragMul);
          const dragMag = 0.00050 * v * (1 + 0.7*Math.abs(aoa)) * dragMulEff;
          const dragX = -dragMag * vx;
          const dragY = -dragMag * vy;

          const windScaleEff = 0.50 * Math.max(0.65, PU.windScaleMul);
          const windMul = (windOn ? (1 + clamp(windLift, -1, 1) * windScaleEff) : 1);

          // Base aero lift
          let lift = 0.00450 * currentDisc.glide * v*v * aoa * windMul;

          // Wind Geyser: add pure vertical updraft
          if (hole?.geyser) {
            const G = hole.geyser;
            const gx = G.x + Math.sin(clock*G.drift.speed + G.drift.phase)*G.drift.amp;
            const baseY = groundYAt(gx);
            const dx = Math.abs(disc.x - gx);
            const xFall = Math.exp(-0.5 * (dx*dx) / (G.rx*G.rx));
            const yRatio = clamp((baseY - disc.y) / G.height, 0, 1);
            const profile = xFall * yRatio;

            if (profile > 0) {
              const turb = 0.06 * Math.sin(clock*18 + (disc.x+disc.y)*0.02 + (G.seed & 1023));
              const boost = G.strength * profile * (1 + turb);
              const updraft = 0.00450 * currentDisc.glide * v*v * (Math.abs(aoa) + 0.08) * boost;
              lift += updraft;
            }
          }

          const turnPhase = tPow*tPow;
          const fadePhase = (1 - tPow);
          const hyz = releaseMode;
          let turnAmt = currentDisc.turn * turnPhase * (0.7 + 0.6*spinNorm) * (1 + 0.35*hyz);
          let fadeAmt = currentDisc.fade * fadePhase * (0.9 + 0.5*(1 - spinNorm)) * (1 - 0.25*hyz);
          const bankBias = 0.12 * Math.sin(disc.bank);
          const curve = (turnAmt - fadeAmt + bankBias);
          const curveMulEff = Math.max(0.90, PU.curveMul);
          const side = (hand==='RHBH'?1:-1);

          // 1) Integrate forces without curve "push"
          const ax = dragX;
          const ay = 1500 + dragY - lift;
          disc.vx += ax*dt; disc.vy += ay*dt;

          // 2) Apply heading rotation to simulate turn/fade  (FIX)
          const curveRate = 54 * curveMulEff * curve * side;   // similar scale as before
          const speedNow = Math.hypot(disc.vx, disc.vy);
          if (speedNow > 1e-3) {
            const dTheta = (curveRate / speedNow) * dt;
            if (dTheta) {
              const cosT = Math.cos(dTheta), sinT = Math.sin(dTheta);
              const vx0 = disc.vx, vy0 = disc.vy;
              disc.vx = vx0 * cosT - vy0 * sinT;
              disc.vy = vx0 * sinT + vy0 * cosT;
            }
          }

          // Spin decay and bank relax
          disc.spin *= Math.exp(-0.35 * PU.spinDecayMul * dt);
          const bankRelax = 0.2 + 0.9*(1 - spinNorm);
          disc.bank += (-disc.bank) * (1 - Math.exp(-dt*bankRelax));

          const noseBias = (lerp(NOSE_FAST_DEG, NOSE_SLOW_DEG, 1 - tPow)) * Math.PI/180;
          const targetOrient = vAngle + noseBias;
          disc.orient += (targetOrient - disc.orient) * (1 - Math.exp(-dt*3.4));

          const gy = groundYAt(disc.x);
          if(disc.y + disc.r >= gy){
            const surface = surfaceAt(disc.x);
            disc.y = gy - disc.r - 0.01;

            if(Math.abs(disc.vy) > 120){
              if(surface==='sand') spawnParticles('sand',  disc.x, disc.y+disc.r, 12);
              else                 spawnParticles('dust',  disc.x, disc.y+disc.r,  8);
            }

            const speed = Math.hypot(disc.vx, disc.vy);
            const entryAngle = Math.atan2(Math.abs(disc.vy), Math.abs(disc.vx));
            const shallow = entryAngle < (12 * Math.PI/180);
            const fast    = speed > 900;

            if(surface!=='sand' && surface!=='green' && shallow && fast){
              disc.vy = -Math.max(180, Math.abs(disc.vy)*0.55);
              disc.vx *= 0.88;
              disc.onGround = false;
            } else {
              const rest = SURF[surface]?.rest ?? 0.14;
              disc.vy = -disc.vy * rest;
              let fric = SURF[surface]?.fric ?? 740;
              if(surface==='sand') fric *= PU.sandFricMul;
              disc.vx *= 0.84;
              if(Math.abs(disc.vy) < 120) disc.vy = 0;
              disc.onGround = true;
            }
          }

          if(checkBasketCatch()){
            Sfx.playChain();
            const cupX = hole.cupX;
            const gY = groundYAt(cupX);
            spawnParticles('spark', cupX, gY - 35, 18);
            if(navigator.vibrate) navigator.vibrate([30,40,30]);
            disc.atRest=true; disc.vx=disc.vy=0;
            setTimeout(()=>{ endHole(); }, 520);
          }
        } else {
          const gy = groundYAt(disc.x);
          if(disc.y + disc.r < gy-0.5){
            disc.onGround=false;
          } else {
            disc.y = gy - disc.r;
            const surface = surfaceAt(disc.x);
            let fric = SURF[surface]?.fric ?? 740;
            if(surface==='sand') fric *= PU.sandFricMul;
            const speed = Math.abs(disc.vx);
            let dec = fric * 2.1;
            if(surface === 'sand')  dec = fric * 2.6;
            if(surface === 'green') dec = fric * 2.3;

            const s = Math.sign(disc.vx) || 0;
            let newSpeed = speed - dec*dt;
            if(newSpeed<0) newSpeed=0;
            disc.vx = s * newSpeed;
            disc.x += disc.vx*dt;
            if(Math.abs(disc.vx) < 8){ disc.vx=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; }
          }
        }
        if(inWater(disc.x, disc.y+disc.r*0.6)){
          spawnParticles('splash', disc.x, disc.y, 16);
          if(navigator.vibrate) navigator.vibrate([40,40,30]);
          strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes;
          disc.x = disc.lastSafe.x - 24; disc.y = groundYAt(disc.x)-disc.r; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true;
        }
        if(disc.x<0){ disc.x=0; disc.vx=0; } if(disc.x>hole.w){ disc.x=hole.w; disc.vx=0; }
      }
      centerCameraOnDisc();
    }

    function centerCameraOnDisc(){
      if(!hole){ return; }
      view.x = clamp(disc.x - view.w*0.45, 0, WORLD.w - view.w);
      view.y = clamp(groundYAt(disc.x) - view.h*0.65, 0, WORLD.h - view.h);
    }

    // ===== Scenery
    function buildScenery(){
      scenery.trees = [];
      scenery.rocks = [];
      scenery.fences = [];
      const rng = (i)=>rand01(backdrop.seed, 2000+i);
      const countTrees = 24 + Math.floor(rng(1)*18);
      const avoid = [
        [hole.green.x0-80, hole.green.x1+80],
      ];
      for(const w of hole.waters){ avoid.push([w.x-60, w.x+w.w+60]); }
      function allowedX(x){
        for(const r of avoid){ if(x>=r[0] && x<=r[1]) return false; }
        return x>40 && x < hole.w-40;
      }
      // Trees
      for(let i=0;i<countTrees;i++){
        let x = 80 + rng(10+i)*(WORLD.w-160);
        let tries=0; while(!allowedX(x) && tries++<10){ x = 80 + rng(100+i*7)*(WORLD.w-160); }
        const y = groundYAt(x);
        const h = 56 + rng(200+i)*96;
        const baseW = 14 + rng(300+i)*18;
        const levels = 4 + Math.floor(rng(500+i)*2);
        scenery.trees.push({ x, y, h, w: baseW, levels, sway:rng(400+i)*TAU });
      }
      // Rocks
      const rockN = 6 + Math.floor(Math.random()*6);
      for(let i=0;i<rockN;i++){
        const x = 80 + Math.random()*(WORLD.w-160);
        const y = groundYAt(x);
        const r = 3 + Math.random()*5;
        const seed = (Math.random()*1e9)|0;
        scenery.rocks.push({ x, y, r, seed, skew: (Math.random()*0.6-0.3) });
      }

      // Fences ‚Äî deterministic
      function addFence(x0, x1){
        if(x1 < x0){ const t=x0; x0=x1; x1=t; }
        x0 = clamp(x0, 40, hole.w-40);
        x1 = clamp(x1, 40, hole.w-40);
        if(x0 < hole.green.x1 && x1 > hole.green.x0){
          if(Math.abs(x0 - hole.green.x0) < Math.abs(x1 - hole.green.x1)) x0 = hole.green.x1 + 16;
          else x1 = hole.green.x0 - 16;
        }
        if(x1 - x0 < 80) return;

        const F = {
          x0, x1,
          step: 28 + Math.random()*10,
          height: 16 + Math.random()*8,
          rails: (Math.random()<0.35?3:2),
          seed: (Math.random()*1e9)|0,
          posts: []
        };

        let idx = 0;
        for(let x = x0; x <= x1; x += F.step){
          const tilt  = (rand01(F.seed, idx*2+1) - 0.5) * 0.12;
          const hMul  = 0.88 + rand01(F.seed, idx*2+2) * 0.25;
          F.posts.push({ x, tilt, hMul });
          idx++;
        }

        scenery.fences.push(F);
      }

      const baseX = hole.tee.x + 140;
      if(baseX < hole.cupX - 120) addFence(baseX, baseX + 260 + Math.random()*200);
      if(Math.random() < 0.65){
        const mid = lerp(hole.tee.x+320, hole.cupX-200, Math.random());
        addFence(mid - (120+Math.random()*120), mid + (120+Math.random()*120));
      }
      if(Math.random() < 0.45){
        addFence(hole.cupX - (260+Math.random()*120), hole.cupX - 80);
      }
    }

    function drawScenery(){
      drawFences();

      // Rocks
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.92)';
      for(const r of scenery.rocks){
        const x = r.x - view.x, y = r.y - view.y;
        if(x<-40 || x>canvas.width/DPR+40) continue;
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(r.skew);

        function rr(seed,i){ return (hash32(seed ^ (i*2654435761))>>>0)/4294967295; }
        const lumps = 2 + Math.floor(rr(r.seed,1)*3);
        for(let i=0;i<lumps;i++){
          const ang = rr(r.seed,10+i)*TAU;
          const dist = r.r * (0.2 + rr(r.seed,20+i)*0.9);
          const rad  = r.r * (0.7 + rr(r.seed,30+i)*0.7);
          const ox = Math.cos(ang)*dist;
          const oy = Math.sin(ang)*dist*0.5 - r.r*0.3;
          const rot = (rr(r.seed,40+i)-0.5)*0.8;
          ctx.save(); ctx.translate(ox, oy); ctx.rotate(rot);
          ctx.beginPath(); ctx.ellipse(0, 0, rad, rad*0.65, 0, 0, TAU); ctx.fill();
          ctx.restore();
        }

        ctx.restore();
      }
      ctx.restore();

      // Trees
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.94)';
      for(const t of scenery.trees){
        const x = t.x - view.x, y = t.y - view.y;
        if(x<-60 || x>xMax()) continue;
        const sway = Math.sin(clock*0.3 + t.sway) * 2;

        const trunkW = clamp(t.h*0.045, 3, 7);
        ctx.fillRect(x - trunkW/2, y - t.h, trunkW, t.h);
        ctx.beginPath(); ctx.moveTo(x - trunkW*0.8, y); ctx.lineTo(x + trunkW*0.8, y); ctx.lineTo(x, y - trunkW*0.4); ctx.closePath(); ctx.fill();

        const tierGap = 10;
        for(let k=0;k<t.levels;k++){
          const level = t.h*(0.16 + k*0.18);
          const width = (t.w + k*(t.w*0.28));
          ctx.beginPath();
          ctx.moveTo(x + sway*0.45, y - level - (k*tierGap));
          ctx.lineTo(x - width/2 + sway, y - level + tierGap);
          ctx.lineTo(x + width/2 + sway, y - level + tierGap);
          ctx.closePath(); ctx.fill();
        }
      }
      ctx.restore();

      function xMax(){ return canvas.width/DPR+60; }
    }

    function drawFences(){
      if(!scenery.fences.length) return;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.94)';
      ctx.fillStyle   = 'rgba(0,0,0,0.94)';

      for(const F of scenery.fences){
        // Posts
        for(const P of F.posts){
          const x = P.x;
          const y = groundYAt(x);
          const sx = x - view.x;
          const sy = y - view.y;
          if(sx<-40 || sx>canvas.width/DPR+40) continue;

          const yR  = groundYAt(x+6);
          const ang = Math.atan2(yR - y, 6) + P.tilt;
          const h   = F.height * P.hMul;
          const w   = 3;

          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(ang - Math.PI/2);
          ctx.translate(0.5, 0.5);
          ctx.fillRect(-w/2, 0, w, h);
          ctx.fillRect(-w/2 - 1, 0, w+2, 2);
          ctx.restore();
        }

        // Rails
        const railOffset = (F.rails === 3) ? [6,12,18] : [8,16];
        ctx.lineWidth = 2;
        for(const off of railOffset){
          ctx.beginPath();
          let started=false;
          for(const P of F.posts){
            const sx = P.x - view.x;
            const sy = groundYAt(P.x) - view.y - off;
            if(sx<-60 || sx>canvas.width/DPR+60) continue;
            if(!started){ ctx.moveTo(sx, sy); started=true; }
            else ctx.lineTo(sx, sy);
          }
          if(started) ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ===== Sand bunkers
    function drawBunkerHole(s){
      const cx = s.x - view.x, cy = s.y - view.y;
      const r = s.r;

      const yL = groundYAt(s.x - 6), yR = groundYAt(s.x + 6);
      const ang = Math.atan2(yR - yL, 12);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.scale(1.10, 0.68);

      const ring = ctx.createRadialGradient(0, 0, r*0.72, 0, 0, r);
      ring.addColorStop(0, 'rgba(255,255,255,0)');
      ring.addColorStop(1, 'rgba(255,255,255,0.08)');
      ctx.fillStyle = ring;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      const shade = ctx.createRadialGradient(0, r*0.22, r*0.18, 0, 0, r);
      shade.addColorStop(0, 'rgba(0,0,0,0.30)');
      shade.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = shade;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      ctx.save();
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.clip();
      drawSandGrain(s.seed, r);
      ctx.restore();

      ctx.restore();
    }
    function drawSandGrain(seed, r){
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const N = 140;
      for(let i=0;i<N;i++){
        const u = rand01(seed, i*7+1);
        const v = rand01(seed, i*7+2);
        const theta = v * TAU;
        const rad = Math.sqrt(u) * r * 0.85;
        const x = Math.cos(theta) * rad;
        const y = Math.sin(theta) * rad * 0.82;
        const dir = (rand01(seed, i*7+3)-0.5) * TAU;
        const len = 2 + rand01(seed, i*7+4)*4;

        ctx.beginPath();
        ctx.moveTo(x - Math.cos(dir)*len*0.5, y - Math.sin(dir)*len*0.5);
        ctx.lineTo(x + Math.cos(dir)*len*0.5, y + Math.sin(dir)*len*0.5);
        ctx.stroke();
      }
    }

    // ===== Water rendering
    function drawWaterBodies(){
      if(!hole || !hole.waters?.length) return;
      for(const W of hole.waters){ drawWater(W); }
    }
    function drawWater(W){
      const baseCol = cached.colors.water;

      const left = W.x - view.x;
      const top  = W.y - view.y;
      const width = W.w;
      const height = hole.h - W.y + 80;

      ctx.save();
      ctx.beginPath();
      ctx.rect(left, top, width, height);
      ctx.clip();

      ctx.fillStyle = baseCol;
      ctx.fillRect(left, top, width, height);

      const g = ctx.createLinearGradient(0, top, 0, top + height);
      g.addColorStop(0.00, 'rgba(0,0,0,0.10)');
      g.addColorStop(0.65, 'rgba(0,0,0,0.18)');
      g.addColorStop(1.00, 'rgba(0,0,0,0.28)');
      ctx.fillStyle = g;
      ctx.fillRect(left, top, width, height);

      const q = qualityScale();
      const rippleA = { freq: 0.035, amp: 1.3, speed: 1.6 };
      const rippleB = { freq: 0.070, amp: 0.9,  speed: -1.2 };
      const step = (q < 0.9 ? 18 : 14);
      ctx.lineWidth = 1;

      ctx.strokeStyle = 'rgba(255,255,255,0.09)';
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin((x * rippleA.freq) + clock * rippleA.speed * 2.0) * rippleA.amp +
          Math.sin((x * rippleB.freq) + clock * rippleB.speed * 2.0) * rippleB.amp;
        const y = top + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.10)';
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin((x * rippleA.freq) + clock * rippleA.speed * 2.0 + 1.2) * (rippleA.amp*0.9) +
          Math.sin((x * rippleB.freq) + clock * rippleB.speed * 2.0 + 0.7) * (rippleB.amp*0.9);
        const y = top + 2 + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      const rr = (i)=> (hash32((W.seed ^ (i*2654435761))>>>0) >>> 0) / 4294967295;
      const streaks = (q < 0.9 ? 3 : 4) + Math.floor(rr(1) * (q < 0.9 ? 3 : 4));
      for(let i=0;i<streaks;i++){
        const yRand = rr(10+i);
        const y = top + 6 + yRand * Math.min(38, height - 10);
        const drift = ((clock * 18) + rr(100+i)*2000) % (width + 160);
        const x0 = left + drift - 160;
        const x1 = Math.min(left + width, x0 + (60 + rr(200+i)*120));

        ctx.globalAlpha = 0.07 + rr(300+i)*0.05;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x0, y, x1 - x0, 1);
        ctx.globalAlpha = 1;
      }

      drawFoamBand(left, top, width, W.seed);

      ctx.restore();
    }
    function drawFoamBand(left, top, width, seed){
      const f1 = 0.045, a1 = 1.4;
      const f2 = 0.090, a2 = 0.8;
      const phase = (hash32(seed ^ 0xBEEF) % 628) / 100;
      const step = 10;

      const haloGrad = ctx.createLinearGradient(0, top, 0, top + 6);
      haloGrad.addColorStop(0, 'rgba(255,255,255,0.10)');
      haloGrad.addColorStop(1, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = haloGrad;
      ctx.fillRect(left, top, width, 6);

      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let x=0; x<=width; x+=step){
        const yOff =
          Math.sin(x*f1 + clock*2.0 + phase) * a1 +
          Math.sin(x*f2 - clock*1.6 + phase*1.7) * a2;
        const y = top + 1 + Math.max(0, yOff);
        if(x===0) ctx.moveTo(left + x, y); else ctx.lineTo(left + x, y);
      }
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      for(let x=4; x<width; x+=22){
        const y = top + 2 + Math.sin(x*0.07 + phase)*0.8;
        ctx.fillRect(left + x, y, 1, 1);
      }
    }

    // ===== Background windmills & pre-rendered mountains
    function drawWindmills(){
      if(!backdrop.windmills?.length || !backdrop.mountains?.length) return;

      const L = backdrop.mountains[backdrop.mountains.length - 1];
      const idx = backdrop.mountains.length - 1;
      const parX = L.parallax;
      const parY = 0.06 * idx;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.88)';
      ctx.strokeStyle = 'rgba(0,0,0,0.88)';
      ctx.lineWidth = 1;

      const w = canvas.width / DPR;

      for(const W of backdrop.windmills){
        const sx = W.x - view.x * parX;
        if(sx < -200 || sx > w + 200) continue;

        let baseY = mountainYAt(L, W.x) - view.y * parY;
        baseY += 2;

        const towerTopY = baseY - W.h;
        const cx = sx, cy = towerTopY - 10;

        ctx.beginPath();
        const tw = Math.max(16, W.h * 0.14);
        const bw = tw * 1.25;
        ctx.moveTo(sx - bw/2, baseY);
        ctx.lineTo(sx + bw/2, baseY);
        ctx.lineTo(sx + tw/2, towerTopY);
        ctx.lineTo(sx - tw/2, towerTopY);
        ctx.closePath(); ctx.fill();

        ctx.beginPath();
        ctx.moveTo(sx - bw/2, baseY);
        ctx.lineTo(sx - bw/2 - 10, baseY + 6);
        ctx.moveTo(sx + bw/2, baseY);
        ctx.lineTo(sx + bw/2 + 10, baseY + 6);
        ctx.stroke();

        const railW = Math.max(40, tw*2.2);
        const railH = 10;
        const railY = towerTopY + 4;
        ctx.fillRect(sx - railW/2, railY, railW, 6);
        ctx.save(); ctx.globalAlpha = 0.95;
        ctx.strokeStyle = 'rgba(0,0,0,0.88)';
        ctx.lineWidth = 1;
        ctx.strokeRect(sx - railW/2, railY - railH, railW, railH);
        const vBars = 6;
        for(let i=1;i<vBars;i++){
          const x = sx - railW/2 + (railW/vBars)*i;
          ctx.beginPath(); ctx.moveTo(x, railY - railH); ctx.lineTo(x, railY); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(sx - railW/2, railY - railH/2); ctx.lineTo(sx + railW/2, railY - railH/2); ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(W.tilt);
        ctx.fillRect(-8, -6, 16, 6);
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, TAU); ctx.fill();

        const windFactor = 1 + (windOn ? Math.abs(windLift)*1.2 : 0);
        const theta = W.spin0 + clock * W.speed * windFactor;

        drawBlade(theta,         W.r);
        drawBlade(theta+TAU/4,   W.r);
        drawBlade(theta+TAU/2,   W.r);
        drawBlade(theta+3*TAU/4, W.r);

        ctx.restore();
      }

      ctx.restore();

      function drawBlade(angle, R){
        ctx.save();
        ctx.rotate(angle);

        const bw = Math.max(6, R*0.16);
        const bl = R;
        const root = 4;

        ctx.beginPath();
        ctx.rect(root, -bw/2, bl-root, bw);
        ctx.fill();

        ctx.save();
        ctx.globalAlpha = 0.45;
        const segs = 5;
        for(let i=1;i<segs;i++){
          const x = root + (bl-root)*(i/segs);
          ctx.beginPath(); ctx.moveTo(x, -bw/2); ctx.lineTo(x, bw/2); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(root, 0); ctx.lineTo(bl, 0); ctx.stroke();
        ctx.restore();

        ctx.restore();
      }
    }

    function drawMountains(){
      const w = canvas.width/DPR, h = canvas.height/DPR;
      for(let idx=0; idx<backdrop.mountains.length; idx++){
        const L = backdrop.mountains[idx];
        const img = backdrop.mountainsImg[idx];
        if(!img) continue;
        const parX = L.parallax;
        const parY = 0.06 * idx;
        const sx = -view.x * parX;
        const sy = -view.y * parY;
        ctx.drawImage(img, sx, sy);
      }
    }

    // ===== Geyser visual
    function drawGeyser(){
      if(!hole?.geyser) return;
      const G = hole.geyser;
      const gx = G.x + Math.sin(clock*G.drift.speed + G.drift.phase)*G.drift.amp;
      const gy = groundYAt(gx);

      const sx = gx - view.x;
      const sy = gy - view.y;

      ctx.save();
      ctx.translate(sx, sy);

      ctx.fillStyle = 'rgba(73,208,255,0.10)';
      ctx.beginPath(); ctx.ellipse(0, 2, G.rx, 10, 0, 0, TAU); ctx.fill();

      const H = G.height * 0.85;
      const N = 9;
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const y = -t*H + Math.sin(clock*2.2 + t*6.0 + (G.seed&255))*2;
        const w = G.rx*(1 - 0.18*t);
        const h = 10 + 6*(1 - t);
        ctx.globalAlpha = 0.12 * (1 - t) + 0.04;
        ctx.beginPath(); ctx.ellipse(0, y, w, h, 0, 0, TAU); ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.strokeStyle = 'rgba(73,208,255,0.08)';
      ctx.lineWidth = 1;
      const lines = 6;
      for(let k=0;k<lines;k++){
        const phase = (k/lines)*TAU + (G.seed%100)/50;
        ctx.beginPath(); let started=false;
        for(let s=0; s<=20; s++){
          const t = s/20;
          const y = -t*H + Math.sin(clock*1.6 + t*6 + phase)*4;
          const r = G.rx*(1 - 0.25*t) * (0.75 + 0.25*Math.sin(t*8 + phase));
          const x = Math.sin(t*3 + phase)*r*0.06;
          if(!started){ ctx.moveTo(x, y); started=true; } else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    // ===== Rendering
    function draw(){
      ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
      drawSkyGradient();
      drawSun();
      drawClouds();
      drawMountains();

      if(!hole){ drawVignette(); drawToasts(); return; }

      drawWindmills();
      drawWaterBodies();

      // Ground fill
      ctx.fillStyle = cached.colors.fg;
      ctx.beginPath(); ctx.moveTo(hole.points[0].x - view.x, hole.h - view.y + 100);
      for(const p of hole.points){ ctx.lineTo(p.x - view.x, p.y - view.y); }
      ctx.lineTo(hole.points[hole.points.length-1].x - view.x, hole.h - view.y + 100); ctx.closePath(); ctx.fill();

      drawGrass();
      drawGeyser();

      for(const s of hole.sands){ drawBunkerHole(s); }

      drawScenery();
      drawBalloons();
      drawBasket();

      for(const p of particles){
        let c = '#ffffff';
        if(p.type==='spark') c = cached.colors.accent;
        else if(p.type==='sand') c = '#b48a5a';
        else if(p.type==='dust') c = '#9aa2aa';
        else if(p.type==='splash') c = cached.colors.accent2;
        ctx.globalAlpha = Math.max(0, p.life/0.6);
        ctx.fillStyle=c; ctx.beginPath(); ctx.arc(p.x - view.x, p.y - view.y, 2.2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
      }

      drawDisc();
      if(aiming){ drawAimArrow(); }

      drawVignette();
      drawToasts();
    }

    function drawSkyGradient(){
      if(!cached.skyGradient) rebuildSkyGradient();
      ctx.fillStyle = cached.skyGradient;
      ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    }

    function drawSun(){
      const m = backdrop.sun; if(!m) return;
      const parX = 0.05, parY = 0.02;
      const drift = Math.sin(clock*0.05 + m.phase) * 12;
      const xw = WORLD.w * m.u, yw = WORLD.h * m.v;
      const x = (xw - view.x*parX) + drift;
      const y = (yw - view.y*parY);
      const r = m.baseR;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const halo = ctx.createRadialGradient(x, y, r*0.8, x, y, r*4.0);
      halo.addColorStop(0, 'rgba(255,210,130,0.22)');
      halo.addColorStop(1, 'rgba(255,210,130,0.00)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, r*4.0, 0, TAU); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.fillStyle = '#fff2cf';
      ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.10)'; ctx.lineWidth = 1; ctx.stroke();
      ctx.restore();
    }

    function drawClouds(){
      const w = canvas.width / DPR;
      const span = WORLD.w;
      const q = qualityScale();
      const alphaMul = (q < 0.9 ? 0.85 : 1.0);
      backdrop.clouds.forEach(C=>{
        const baseX = WORLD.w * C.u - clock * C.speed;
        const y = WORLD.h * C.v - view.y * C.parY;
        for(let k=-1; k<=1; k++){
          const x = baseX + k*span - view.x * C.parX;
          if(x < -260 || x > w + 260) continue;
          ctx.save();
          ctx.globalAlpha = alphaMul;
          ctx.drawImage(C.sprite, x - C.spriteW/2, y - C.spriteH/2);
          ctx.restore();
        }
      });
    }

    const GRASS_STEP = 26;
    function drawGrass(){
      if(!hole){ return; }
      const q = qualityScale();
      const density = Math.max(1, Math.round(3 * q));
      ctx.save(); ctx.strokeStyle='rgba(0,0,0,.9)'; ctx.lineWidth=1;
      const start = Math.floor((view.x-40)/GRASS_STEP)*GRASS_STEP; const end = view.x + view.w + 40;
      for(let wx=start; wx<end; wx+=GRASS_STEP){
        const gx = clamp(wx,0,hole.w); const gy = groundYAt(gx) - view.y; if(gy< -20 || gy > canvas.height/DPR+20) continue;
        for(let k=0;k<density;k++){
          const idx = ((gx|0)*7 + k)|0; const hh = 7 + rand01(backdrop.seed ^ 0xabc123, idx)*10; const lean = (rand01(backdrop.seed ^ 0x55aa55, idx+13)-0.5)*8;
          const baseX = gx - view.x + (k-1)*(2 + rand01(backdrop.seed ^ 0x999,idx+21)*2);
          ctx.beginPath(); ctx.moveTo(baseX, gy);
          const ctrlX = baseX + lean*0.45; const ctrlY = gy - hh*0.55; const tipX = baseX + lean; const tipY = gy - hh;
          ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawDisc(){
      const trailColor = cached.colors.accent;
      if(!disc.atRest && Math.hypot(disc.vx,disc.vy)>320){
        ctx.strokeStyle = trailColor; ctx.globalAlpha=0.24; ctx.lineWidth=3;
        ctx.beginPath(); ctx.moveTo(disc.x - view.x, disc.y - view.y);
        ctx.lineTo(disc.x - disc.vx*0.05 - view.x, disc.y - disc.vy*0.05 - view.y);
        ctx.stroke(); ctx.globalAlpha=1;
      }

      let fillCol = '#f8fafc';
      if(currentDisc.id==='DRV') fillCol = '#49d0ff';
      else if(currentDisc.id==='PUT') fillCol = '#ff8a3d';
      else if(currentDisc.id==='MID') fillCol = '#f8fafc';

      ctx.save();
      ctx.translate(disc.x - view.x, disc.y - view.y);
      ctx.rotate(disc.orient);
      ctx.fillStyle = fillCol;
      ctx.strokeStyle = 'rgba(0,0,0,.45)';
      const R = disc.r;
      ctx.beginPath(); ctx.ellipse(0,0, R, R*0.45, 0, 0, TAU); ctx.fill(); ctx.stroke();
      ctx.globalAlpha=0.45; ctx.beginPath(); ctx.ellipse(0,0, R*0.85, R*0.35, 0, 0, TAU); ctx.stroke(); ctx.globalAlpha=1;
      ctx.restore();
    }

    function drawAimArrow(){
      const b = worldToScreen(disc.x, disc.y);
      const len = 80 + meter*160;
      const x2 = b.x + Math.cos(aimAngle)*len;
      const y2 = b.y + Math.sin(aimAngle)*len;
      ctx.save(); ctx.scale(DPR,DPR);
      ctx.strokeStyle = cached.colors.accent3; ctx.lineWidth=3; ctx.globalAlpha=0.9;
      ctx.beginPath(); ctx.moveTo(b.x/DPR, b.y/DPR); ctx.lineTo(x2/DPR, y2/DPR); ctx.stroke();
      const a=aimAngle; const ah = 10; const aw = 7;
      ctx.beginPath(); ctx.moveTo(x2/DPR, y2/DPR);
      ctx.lineTo((x2 - Math.cos(a)*ah + Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah - Math.cos(a)*aw)/DPR);
      ctx.lineTo((x2 - Math.cos(a)*ah - Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah + Math.cos(a)*aw)/DPR);
      ctx.closePath(); ctx.fillStyle=cached.colors.accent; ctx.fill();
      ctx.restore();
    }

    function drawBasket(){
      const gx = hole.cupX;
      const gyCup = groundYAt(gx);
      const x = gx - view.x;
      const groundY = gyCup - view.y;
      const poleH = 74, cageTop = groundY - 24, rimY = groundY - 46;
      const rimW = 28, cageW = 24;

      ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x, groundY - poleH); ctx.stroke();

      ctx.fillStyle = 'rgba(0,0,0,0.80)';
      ctx.fillRect(x - cageW/2, cageTop, cageW, 8);
      ctx.fillRect(x - 2, cageTop - 10, 4, 10);

      ctx.beginPath(); ctx.ellipse(x, rimY, rimW/2, 4, 0, 0, TAU); ctx.fill();

      ctx.strokeStyle='rgba(0,0,0,0.75)'; ctx.lineWidth=1;
      for(let i=0;i<6;i++){
        const t = i/6 * TAU;
        const cx = x + Math.cos(t) * (rimW/2 - 2);
        ctx.beginPath();
        ctx.moveTo(cx, rimY);
        ctx.lineTo(cx, cageTop);
        ctx.stroke();
      }

      const poleTopY = groundY - poleH;
      const stub = 16;
      ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, poleTopY); ctx.lineTo(x, poleTopY - stub); ctx.stroke();

      const anchorX = x;
      const anchorY = poleTopY - stub;

      const dir  = (windOn ? (windLift >= 0 ? 1 : -1) : 1);
      const wmag = windOn ? Math.abs(windLift) : 0;

      const len    = 34 + wmag*26;
      const height = 10;
      const amp    = 2 + wmag*6;
      const speed  = 2.2 + wmag*2.0;
      const phase  = clock * speed;
      const N      = 8;

      ctx.save();
      const flagCol = cached.colors.accent;
      ctx.fillStyle = flagCol;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;

      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t = i/N;
        const px = anchorX + dir * t * len;
        const wave = Math.sin(phase + t*TAU) * amp * (0.6 + 0.4*Math.cos(t*TAU*0.5));
        const py = anchorY + wave;
        if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      for(let i=N;i>=0;i--){
        const t = i/N;
        const px = anchorX + dir * t * len;
        const wave = Math.sin(phase + t*TAU + 0.6) * amp * (0.6 + 0.4*Math.cos(t*TAU*0.5));
        const py = anchorY + height + wave*0.6;
        ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();

      const tipX = anchorX + dir * len;
      const tipY = anchorY + Math.sin(phase + TAU)*amp*0.6 + height*0.5;
      ctx.beginPath();
      ctx.moveTo(tipX,               tipY - height*0.35);
      ctx.lineTo(tipX + dir*6,       tipY);
      ctx.lineTo(tipX,               tipY + height*0.35);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fill();

      ctx.restore();
    }

    function checkBasketCatch(){
      const gx = hole.cupX;
      const gyCup = groundYAt(gx);
      const rimY = gyCup - 46;
      const cageTop = gyCup - 24;
      const rimHalf = 14 + Math.min(3, PU.rimHalfBonus);
      if(disc.vy > 30 * PU.vyThreshMul && disc.y > rimY-6 && disc.y < cageTop+6 && Math.abs(disc.x - gx) < rimHalf){
        return true;
      }
      return false;
    }

    function drawVignette(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.2,w*0.5,h*0.55,Math.max(w,h)*0.7); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h); }

    function drawToasts(){
      if(!toasts.length) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      const w = canvas.width / DPR;
      const y0 = 48;
      ctx.font = '600 14px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial';
      ctx.textAlign = 'center';
      for(let i=0;i<toasts.length;i++){
        const T = toasts[i];
        const alpha = Math.max(0, 1 - (T.t / T.dur));
        const padX = 14, padY = 8, th = 28;
        const tw = T.width + padX*2;
        const x = w/2, y = y0 + i*(th+8);
        ctx.globalAlpha = 0.65 * alpha;
        roundedRect(ctx, x - tw/2, y - th/2, tw, th, 10);
        ctx.fillStyle = 'rgba(0,0,0,0.65)'; ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.stroke();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#e6edf3';
        ctx.fillText(T.msg, x, y + 4);
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }
    function roundedRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    // ===== Resize
    function resize(){ DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); view.w = canvas.width/DPR; view.h = canvas.height/DPR; refreshColorsFromCSS(); rebuildSkyGradient(); rebuildMountainsOffscreen(); }
    window.addEventListener('resize', resize); resize();

    // ===== Main loop (fixed timestep)
    const FIXED_DT = 1/60;
    let last=0; let clock=0; let acc=0;
    function loop(t){
      const now=t/1000;
      let frameDT = Math.min(0.05, last? now-last: 0.016);
      last=now;
      frameEMA = frameEMA*0.9 + frameDT*0.1;
      acc += frameDT;
      const maxSteps = 5;
      let steps = 0;
      while(acc >= FIXED_DT && steps++ < maxSteps){
        clock += FIXED_DT;
        update(FIXED_DT);
        acc -= FIXED_DT;
      }
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== Audio unlock on first interaction
    window.addEventListener('pointerdown', () => {
      try { Sfx.init(); } catch {}
      if (chkAudio && chkAudio.checked) {
        try { Sfx.setEnabled(true); } catch {}
        try { AudioMini.init(); AudioMini.setEnabled(true); } catch {}
      }
    }, { once:true });

    // ===== UI wiring
    btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; Sfx.init(); newRound(); });
    btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; Sfx.init(); newRound(); });
    btnNewRound.addEventListener('click', ()=>{ Sfx.init(); newRound(); });
    btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
    btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });

    // Persisted toggles
    const prefKeys = { reduced:'prefReduced', audio:'prefAudio', wind:'prefWind' };
    (function restorePrefs(){
      const r = localStorage.getItem(prefKeys.reduced); if(r!==null) chkReduced.checked = (r==='1');
      const a = localStorage.getItem(prefKeys.audio);   if(a!==null) chkAudio.checked   = (a==='1');
      const w = localStorage.getItem(prefKeys.wind);    if(w!==null) chkWind.checked    = (w==='1');
      reducedMotion = chkReduced.checked;
      windOn = chkWind.checked;
      updateWindUI();
    })();

    chkReduced.addEventListener('change', ()=>{ reducedMotion = chkReduced.checked; localStorage.setItem(prefKeys.reduced, chkReduced.checked?'1':'0'); });
    chkAudio.addEventListener('change', async ()=>{ const on = chkAudio.checked; localStorage.setItem(prefKeys.audio, on?'1':'0'); Sfx.setEnabled(on); await AudioMini.setEnabled(on); });
    chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; localStorage.setItem(prefKeys.wind, windOn?'1':'0'); updateWindUI(); AudioMini.setWind(windOn); });

    // initialize toggles' effects
    Sfx.setEnabled(chkAudio.checked);
    AudioMini.setEnabled(chkAudio.checked);
    AudioMini.setWind(windOn);

    buildDiscs(); updateWindUI();
  }
})();
</script>
</body>
</html>
``
