<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Dusk Drive ‚Äî Side-View Silhouette Disc Golf (v3.7 ‚Äî recessed grainy bunkers)</title>
<style>
  :root{
    /* defaults; overridden per biome at runtime */
    --bg1:#a54720; --bg2:#f38e41; --bg3:#ffe6ba; --water:#30160f;
    --fg:#050607; --text:#e6edf3; --muted:#a9b1ba;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(5,6,7,.65); --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1100px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}
  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .small{font-size:.9rem;color:var(--muted)}
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}
  @media (orientation:portrait){ #landscapeHint{display:flex} }
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Dusk Drive side-view game canvas"></canvas></div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="topbar">
      <div class="row">
        <div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
        <div class="chip"><span class="label">Par</span> <strong id="parLabel">3</strong></div>
        <div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
      </div>
      <div class="row">
        <div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="panel controls">
        <div class="seg" id="clubSeg" role="group" aria-label="Disc select"></div>
        <div class="seg" id="spinSeg" role="group" aria-label="Release angle">
          <button class="btn" data-spin="-1" aria-pressed="false" title="Hyzer (‚àí15¬∞)">Hyzer</button>
          <button class="btn" data-spin="0"  aria-pressed="true"  title="Flat (0¬∞)">Flat</button>
          <button class="btn" data-spin="1"  aria-pressed="false" title="Anhyzer (+15¬∞)">Anhy</button>
        </div>
        <div class="seg" id="handSeg" role="group" aria-label="Throw style">
          <button class="btn" data-hand="RHBH" aria-pressed="true" title="Right-hand backhand">RHBH</button>
          <button class="btn" data-hand="LHBH" aria-pressed="false" title="Left-hand backhand">LHBH</button>
        </div>
        <button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
      </div>
    </div>

    <div class="powermeter" id="powermeter" aria-hidden="true"><div class="fill" id="powerfill"></div></div>
  </div>

  <!-- Screens -->
  <div id="screenIntro" class="screen" role="dialog" aria-modal="true">
    <div class="card">
      <h1>ü•è Dusk Drive ‚Äî Disc Golf</h1>
      <div class="sub">Drag to aim, hold to charge, release to throw. Hyzer/flat/anhyzer, vertical wind & glide, varied terrain.</div>
      <div class="grid">
        <div class="tag">Drivers ‚Ä¢ Fairways ‚Ä¢ Mids ‚Ä¢ Putters</div>
        <div class="tag">Vertical Wind & Lift</div>
        <div class="tag">Turn/Fade Curve</div>
        <div class="tag">Procedural Holes (+variants)</div>
      </div>
      <p class="small" style="margin-top:.7rem">Best in landscape ‚Ä¢ Mobile-friendly ‚Ä¢ Haptics on chains</p>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlay">Start Round</button></div>
    </div>
  </div>

  <div id="screenSummary" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Round Complete</h2>
      <p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
      <div class="grid" id="holeBreakdown"></div>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
    </div>
  </div>

  <div id="screenSettings" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Settings</h2>
      <div class="grid">
        <label class="chip" style="justify-content:space-between">
          <span>Reduced motion</span>
          <input type="checkbox" id="chkReduced" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Audio (minimal ambience)</span>
          <input type="checkbox" id="chkAudio" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Wind (toggle)</span>
          <input type="checkbox" id="chkWind" checked />
        </label>
      </div>
      <p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
      <div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
    </div>
  </div>

  <div id="landscapeHint"><div class="card small">For best experience, rotate to landscape.</div></div>

<script>
(function initWhenReady(){
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', main, { once:true });
  } else { main(); }

  function main(){
    const TAU = Math.PI*2;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // ===== UI Elements
    const elHole = document.getElementById('holeNum');
    const elHolesTotal = document.getElementById('holesTotal');
    const elPar = document.getElementById('parLabel');
    const elStrokes = document.getElementById('strokes');
    const elWindVal = document.getElementById('windVal');
    const elWindArrow = document.getElementById('windArrow');
    const elPowermeter = document.getElementById('powermeter');
    const elPowerfill = document.getElementById('powerfill');
    const clubSeg = document.getElementById('clubSeg');
    const spinSeg = document.getElementById('spinSeg');
    const handSeg = document.getElementById('handSeg');

    const screenIntro = document.getElementById('screenIntro');
    const screenSummary = document.getElementById('screenSummary');
    const screenSettings = document.getElementById('screenSettings');
    const btnPlay = document.getElementById('btnPlay');
    const btnPlayAgain = document.getElementById('btnPlayAgain');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnSettings = document.getElementById('btnSettings');
    const btnCloseSettings = document.getElementById('btnCloseSettings');
    const chkReduced = document.getElementById('chkReduced');
    const chkAudio = document.getElementById('chkAudio');
    const chkWind = document.getElementById('chkWind');

    const sumStrokes = document.getElementById('sumStrokes');
    const sumPar = document.getElementById('sumPar');
    const sumScore = document.getElementById('sumScore');
    const holeBreakdown = document.getElementById('holeBreakdown');

    // ===== Game Config & State
    const HOLES_PER_ROUND = 3; elHolesTotal.textContent = HOLES_PER_ROUND;
    const WORLD = { w: 3400, h: 950 };
    let view = { x:0, y:0, w:0, h:0 };

    // Discs
    const DISCS = [
      { id:'DRV', name:'Driver',  speed:1.20, glide:1.00, turn:-2.0, fade:2.5 },
      { id:'FAI', name:'Fairway', speed:0.92, glide:1.05, turn:-1.5, fade:2.0 },
      { id:'MID', name:'Mid',     speed:0.80, glide:1.10, turn:-1.0, fade:1.4 },
      { id:'PUT', name:'Putter',  speed:0.62, glide:1.00, turn:-0.3, fade:0.9 }
    ];

    // Surfaces
    const SURF = {
      fairway: { fric: 740,  rest: 0.14 },
      rough:   { fric: 1000, rest: 0.10, powerMul: 0.88 },
      sand:    { fric: 1400, rest: 0.05, powerMul: 0.70 },
      green:   { fric: 520,  rest: 0.10 },
      rock:    { fric: 620,  rest: 0.18 }
    };

    // ==== DISC PHYSICS ====
    const GRAV = 1500;
    const AIR_DRAG = 0.00050;
    const LIFT_K   = 0.00450;
    const TURN_K   = 54;
    const VREF     = 1600;
    const CAMBER   = 0.06;
    const NOSE_FAST_DEG = -6;
    const NOSE_SLOW_DEG =  7;
    const SPIN_DECAY = 0.35;

    let reducedMotion = false;

    // ===== Vertical wind (lift only)
    let windOn = true;
    let windLift = 0;             // -1 .. +1 (down .. up)
    const WIND_LIFT_SCALE = 0.50; // ¬±50% lift modulation at max

    // Release angle / throw style
    let releaseMode = 0;
    let hand = 'RHBH';

    // ---------- Helpers ----------
    const RAND_MAX = 4294967295;
    function hash32(x){ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return x>>>0; }
    function rand01(seed, i){ return hash32((seed ^ (i|0))>>>0) / RAND_MAX; }
    function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    const ease = (t)=>t*t*(3-2*t);

    // Audio (minimal)
    const AudioMini = (()=>{
      let ctx=null, windNode=null, masterGain=null; let enabled=false;
      function init(){
        if(enabled) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = ctx.createGain(); masterGain.gain.value=0.18; masterGain.connect(ctx.destination);
        const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
        const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
        const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(masterGain); o1.start(); o2.start();
        const buff = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
        const data = buff.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
        const noise = ctx.createBufferSource(); noise.buffer=buff; noise.loop=true;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=400;
        const wg = ctx.createGain(); wg.gain.value=0.05; noise.connect(lp); lp.connect(wg); wg.connect(masterGain); noise.start();
        windNode = wg; enabled=true; if(!windOn) wg.gain.value=0.0;
      }
      function setEnabled(on){ if(on){init();} else { if(masterGain){masterGain.gain.value=0;} } }
      function thwack(){ if(!enabled) return; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(220, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(60, ctx.currentTime+0.15); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.18); o.connect(g); g.connect(masterGain); o.start(); o.stop(ctx.currentTime+0.2);} 
      function chains(){ if(!enabled) return; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(760, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(420, ctx.currentTime+0.09); g.gain.setValueAtTime(0.25, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.22); o.connect(g); g.connect(masterGain); o.start(); o.stop(ctx.currentTime+0.25);} 
      function setWind(on){ if(!enabled||!windNode) return; windNode.gain.value = on?0.05:0.0; }
      return { setEnabled, thwack, chains, setWind };
    })();

    // Particles
    const particles=[];
    function spawnParticles(type, x, y, count){
      for(let i=0;i<count;i++){
        const a = Math.random()*TAU; const sp = (type==='spark'? 160 + Math.random()*160 : 80+Math.random()*120);
        const vx = Math.cos(a)*sp, vy = Math.sin(a)*sp - (type==='spark'?0:200);
        particles.push({ type, x, y, vx, vy, life: type==='spark'? 0.25: (type==='sand'?0.5:0.6) });
      }
    }

    // === Biomes ===
    const BIOMES = [
      { name:'dunes',
        sky:{ bg1:'#9d3e25', bg2:'#f38e41', bg3:'#ffe6ba', water:'#30160f' },
        layers:[
          {par:0.08, base:0.52, a1:30,  a2:16,  f1:0.00050, f2:0.00020, shade:0.02, shape:'sin'},
          {par:0.12, base:0.56, a1:50,  a2:24,  f1:0.00065, f2:0.00026, shade:0.035,shape:'sin'},
          {par:0.18, base:0.61, a1:70,  a2:34,  f1:0.00082, f2:0.00032, shade:0.05, shape:'sin'},
          {par:0.26, base:0.66, a1:104, a2:48,  f1:0.00100, f2:0.00042, shade:0.07, shape:'sin'},
          {par:0.33, base:0.70, a1:116, a2:54,  f1:0.00115, f2:0.00048, shade:0.085,shape:'sin'},
          {par:0.40, base:0.74, a1:126, a2:58,  f1:0.00125, f2:0.00052, shade:0.10, shape:'sin'}
        ]
      },
      { name:'crags',
        sky:{ bg1:'#5b1a2b', bg2:'#d5425a', bg3:'#f8c3da', water:'#2c0f19' },
        layers:[
          {par:0.06, base:0.50, a1:60,  a2:36,  f1:0.00055, f2:0.00022, shade:0.02, shape:'crag'},
          {par:0.10, base:0.58, a1:95,  a2:52,  f1:0.00075, f2:0.00030, shade:0.05, shape:'crag'},
          {par:0.16, base:0.64, a1:140, a2:70,  f1:0.00095, f2:0.00040, shade:0.08, shape:'crag'},
          {par:0.24, base:0.70, a1:170, a2:86,  f1:0.00115, f2:0.00055, shade:0.11,shape:'crag'},
          {par:0.36, base:0.76, a1:190, a2:96,  f1:0.00135, f2:0.00065, shade:0.13,shape:'crag'}
        ]
      },
      { name:'hills',
        sky:{ bg1:'#233d6d', bg2:'#5d79b0', bg3:'#cfe2ff', water:'#0e2233' },
        layers:[
          {par:0.10, base:0.54, a1:36,  a2:18,  f1:0.00044, f2:0.00018, shade:0.02, shape:'round'},
          {par:0.16, base:0.60, a1:60,  a2:28,  f1:0.00062, f2:0.00024, shade:0.04, shape:'round'},
          {par:0.22, base:0.66, a1:90,  a2:42,  f1:0.00080, f2:0.00032, shade:0.06, shape:'round'},
          {par:0.30, base:0.71, a1:115, a2:56,  f1:0.00098, f2:0.00040, shade:0.08, shape:'round'},
          {par:0.38, base:0.75, a1:132, a2:64,  f1:0.00112, f2:0.00048, shade:0.10, shape:'round'}
        ]
      },
      { name:'mesas',
        sky:{ bg1:'#6e3b1b', bg2:'#cf7b35', bg3:'#ffe1b0', water:'#2a1a12' },
        layers:[
          {par:0.08, base:0.54, a1:42,  a2:20,  f1:0.00058, f2:0.00022, shade:0.02, shape:'mesa'},
          {par:0.13, base:0.60, a1:70,  a2:32,  f1:0.00076, f2:0.00030, shade:0.04, shape:'mesa'},
          {par:0.20, base:0.66, a1:96,  a2:46,  f1:0.00096, f2:0.00038, shade:0.06, shape:'mesa'},
          {par:0.28, base:0.72, a1:120, a2:56,  f1:0.00116, f2:0.00046, shade:0.08, shape:'mesa'},
          {par:0.36, base:0.76, a1:140, a2:64,  f1:0.00128, f2:0.00054, shade:0.10, shape:'mesa'}
        ]
      }
    ];

    function applyTheme(biome){
      const root = document.documentElement.style;
      root.setProperty('--bg1', biome.sky.bg1);
      root.setProperty('--bg2', biome.sky.bg2);
      root.setProperty('--bg3', biome.sky.bg3);
      root.setProperty('--water', biome.sky.water);
    }

    // Backdrop
    let currentBiome = BIOMES[0];
    const backdrop = {
      seed:(Math.random()*1e9)|0,
      mountains:[],
      sun:null,
      clouds:[],
      cloudDir:1,
      landmarksFar:[],
      flocks:[]
    };

    // Shape helpers
    function triangleWave(x){ return (2/Math.PI)*Math.asin(Math.sin(x)); }
    function mesaWave(x){ const k=2.2; return Math.tanh(Math.sin(x)*k)/Math.tanh(k); }
    function roundWave(x){ const s=Math.sin(x); return Math.sign(s)*Math.pow(Math.abs(s),0.85); }
    function cragWave(x){ return 0.7*triangleWave(x) + 0.3*Math.sin(x*3.0); }
    function shapeSample(shape, x){
      switch(shape){
        case 'mesa':   return mesaWave(x);
        case 'round':  return roundWave(x);
        case 'crag':   return cragWave(x);
        case 'sin':
        default:       return Math.sin(x);
      }
    }

    function buildBackdrop(){
      const L = [];
      currentBiome.layers.forEach((spec, i)=>{
        const s = (backdrop.seed ^ hash32((spec.par*1000)|0) ^ i)>>>0;
        const base = WORLD.h*spec.base;
        const ph   = rand01(s,1)*TAU;
        const curv = { a: 10 + rand01(s,3)*16, f: 0.0012 + rand01(s,4)*0.0006, ph: rand01(s,2)*TAU };
        L.push({ parallax:spec.par, base, a1:spec.a1, a2:spec.a2, f1:spec.f1, f2:spec.f2, ph, shade:spec.shade, curv, shape:spec.shape });
      });
      backdrop.mountains = L;

      // Sun
      const u = 0.20 + rand01(backdrop.seed,101)*0.60;
      const v = 0.16 + rand01(backdrop.seed,102)*0.20;
      const phase = rand01(backdrop.seed,103)*TAU;
      const baseR = 20 + Math.floor(rand01(backdrop.seed,104)*12);
      backdrop.sun = { u, v, phase, baseR };

      // Clouds
      backdrop.cloudDir = rand01(backdrop.seed,399) < 0.5 ? -1 : 1;
      buildCloudField();
      if(hole) buildLandmarks();
      buildFlocks();
    }

    function buildCloudField(){
      backdrop.clouds.length = 0;
      const count = 3 + Math.floor(rand01(backdrop.seed,300)*4);
      for(let i=0;i<count;i++){
        const s = hash32(backdrop.seed ^ (0xA11C10 + i*131));
        const u = rand01(s,1);
        const v = 0.12 + (i+1)/(count+1) * 0.42 + (rand01(s,2)-0.5)*0.05;
        const parX = 0.04 + rand01(s,3)*0.05;
        const parY = 0.015 + rand01(s,4)*0.02;
        const speed = backdrop.cloudDir * (4 + rand01(s,6)*6);
        const alpha = 0.05 + rand01(s,7)*0.08;
        const scale = 0.9 + rand01(s,8)*1.6;
        backdrop.clouds.push({ seed:s, u, v, parX, parY, speed, alpha, scale });
      }
    }

    function mountainYAt(L, wx){
      let y = L.base
        - shapeSample(L.shape, wx*L.f1)*L.a1
        - shapeSample(L.shape, wx*L.f2 + L.ph)*L.a2;
      if(L.curv){
        y -= Math.sin(wx*L.curv.f   + L.curv.ph)      * L.curv.a;
        y -= Math.sin(wx*L.curv.f*2 + L.curv.ph*1.3) * (L.curv.a*0.45);
      }
      return y;
    }

    // ---- Landmarks / Flocks (unchanged) ----
    function buildLandmarks(){ /* omitted here for brevity; kept same as earlier build */ backdrop.landmarksFar=[]; }
    function buildFlocks(){ backdrop.flocks.length=0; }

    // ===== World / Hole
    const disc = { x:0,y:0,vx:0,vy:0,r:7.5, atRest:true, onGround:true, lastSafe:{x:0,y:0}, orient:0, spin:0, spin0:1, bank:0 };
    let strokes=0;
    let holeIndex=0, roundData=null;
    let hole=null;

    // Aim/meter
    let aiming=false, aimAngle=0, meter=0, meterDir=1, meterOn=false;

    // Scenery
    let scenery = { trees:[], rocks:[] };

    // ===== Procedural hole =====
    function genHole(){
      const w = WORLD.w, h = WORLD.h;
      const step=40;

      // Global tilt
      const tilt = (Math.random()*2-1) * 0.16;
      const tiltAmp = 160;

      // Base waves
      let seed = Math.random()*9999;
      function nrand(){ seed = Math.sin(seed)*10000; return seed - Math.floor(seed); }
      const amp1 = 70 + nrand()*110, freq1 = 1/(520+ nrand()*420);
      const amp2 = 22 + nrand()*42,  freq2 = 1/(220 + nrand()*250);

      const baseY0 = h*0.72;
      const points=[];
      for(let x=0;x<=w;x+=step){
        const t = x/w;
        const tiltOffset = (t-0.5) * tiltAmp * tilt;
        const y = baseY0 + tiltOffset - Math.sin(x*freq1)*amp1 - Math.sin(x*freq2)*amp2;
        points.push({x,y});
      }

      // Features
      const featureCount = Math.floor(Math.random()*3);
      for(let f=0; f<featureCount; f++){
        const cx = lerp(w*0.18, w*0.82, Math.random());
        const sigma = 120 + Math.random()*220;
        const amp = (Math.random()<0.5? -1:1) * (50 + Math.random()*90);
        for(let i=0;i<points.length;i++){
          const dx = points[i].x - cx;
          const k = Math.exp(- (dx*dx) / (2*sigma*sigma));
          points[i].y += amp * k;
        }
      }

      // Rare cliff
      if(Math.random() < 0.33){
        const cx = lerp(w*0.30, w*0.70, Math.random());
        const up = Math.random() < 0.5 ? -1 : 1;
        const drop = up * (120 + Math.random()*120);
        const sharp = 60 + Math.random()*80;
        for(let i=0;i<points.length;i++){
          const dx = (points[i].x - cx) / sharp;
          const s = 1/(1+Math.exp(-dx));
          points[i].y += drop * s;
        }
      }

      // Basket & green flatten
      const cupX = lerp(w*0.68, w*0.90, Math.random());
      const gWidth = 200 + Math.random()*160;
      const gx0=cupX-gWidth/2, gx1=cupX+gWidth/2;
      const greenSlope = (Math.random()*0.6-0.3);
      let greenY = 0;
      for(let i=0;i<points.length;i++){
        if(points[i].x>=gx0 && points[i].x<=gx1){
          const t = (points[i].x-gx0)/gWidth;
          const gy = (baseY0-30) + (Math.sin(points[i].x*freq2)*6) + greenSlope*(t-0.5)*40;
          points[i].y = gy; greenY = gy;
        }
      }

      // Water
      const waters=[];
      const wantWater = Math.random() < 0.85 ? 1 : 0;
      const extraWater = Math.random() < 0.35 ? 1 : 0;
      const waterCount = wantWater + extraWater;
      function placeWater(rangeL, rangeR, wmin, wmax, raise= -28){
        const wx = clamp(lerp(rangeL, rangeR, Math.random()), 80, w-280);
        const ww = wmin + Math.random()*(wmax-wmin);
        const idx = Math.floor(wx/step);
        const yLocal = points[ clamp(idx,0,points.length-1) ].y;
        const wy = yLocal + raise + (Math.random()*16-8);
        waters.push({x:wx, y:wy, w:ww, h:h - wy + 60});
      }
      if(waterCount>0){
        const midMin = w*0.28, midMax = cupX-360;
        const guardMin = cupX-300, guardMax = cupX-60;
        if(Math.random()<0.6 && midMax>midMin+160) placeWater(midMin, midMax, 180, 360);
        else placeWater(guardMin, guardMax, 180, 320, -24);
        if(waterCount>1){
          if(Math.random()<0.5) placeWater(w*0.18, w*0.35, 140, 240, -34);
          else placeWater(cupX-520, cupX-280, 140, 220, -18);
        }
      }

      // Sand bunkers (seeded)
      const sands=[];
      function addSand(cx, cy, r){ sands.push({ x:cx, y:cy, r, seed:(Math.random()*1e9)|0 }); }
      const lzX = lerp(w*0.32, cupX-400, Math.random());
      addSand(lzX + (Math.random()*120-60), sampleY(points, lzX) - 8, 58 + Math.random()*28);
      addSand(cupX + (Math.random()*160-80), greenY - 10, 56 + Math.random()*24);
      if(Math.random()<0.33) addSand(cupX - 120 + Math.random()*200, greenY - 10, 42 + Math.random()*24);

      // Rough patches
      const roughs=[];
      const roughN = Math.floor(Math.random()*4);
      for(let i=0;i<roughN;i++){
        const rx = lerp(w*0.20, cupX-140, Math.random());
        const ry = sampleY(points, rx) - 6;
        roughs.push({ x:rx, y:ry, r: 42 + Math.random()*30 });
      }

      // Tee
      const teeX = 120;
      const teeIdx = Math.floor(teeX/step);
      const teeY = points[teeIdx].y - 2;
      points[teeIdx].y = teeY;

      // Valley emphasis
      if(Math.random()<0.6){
        const vX = lerp(w*0.40, w*0.62, Math.random());
        const vIdx = Math.floor(vX/step);
        for(let i=-3;i<=3;i++){ const k=vIdx+i; if(points[k]) points[k].y += Math.abs(i)* (16 + Math.random()*12); }
      }

      const dist = (cupX - teeX);
      let par = 3; if(dist>1900) par=5; else if(dist>1200) par=4;

      return { w,h,points,step,cupX,
        green:{x0:gx0,x1:gx1,y:greenY}, waters,sands,roughs, tee:{x:teeX,y:teeY}, par };
    }

    function sampleY(points, x){
      const step = points[1].x - points[0].x;
      const i = Math.min(Math.max(Math.floor(x/step),0), points.length-2);
      const p0 = points[i], p1 = points[i+1];
      const t = (x - p0.x)/(p1.x - p0.x);
      return lerp(p0.y, p1.y, t);
    }

    function groundYAt(x){ x = clamp(x, 0, hole.w); const i = Math.min(Math.floor(x/hole.step), hole.points.length-2); const p0 = hole.points[i], p1 = hole.points[i+1]; const t = (x - p0.x)/(p1.x - p0.x); return lerp(p0.y, p1.y, t); }

    function surfaceAt(x){
      if(x>=hole.green.x0 && x<=hole.green.x1) return 'green';
      const y = groundYAt(x);
      for(const s of hole.sands){ if(Math.hypot(x - s.x, y - s.y) <= s.r) return 'sand'; }
      for(const r of hole.roughs){ if(Math.hypot(x - r.x, y - r.y) <= r.r) return 'rough'; }
      return 'fairway';
    }

    function inWater(x,y){
      for(const w of hole.waters){ if(x>=w.x && x<=w.x+w.w && y>=w.y) return true; }
      return false;
    }

    // ===== Round flow
    function newRound(){ holeIndex=0; roundData={ holes:[], totalPar:0, totalStrokes:0 }; screenIntro.style.display='none'; screenSummary.style.display='none'; nextHole(); }
    function nextHole(){
      const biome = BIOMES[holeIndex % BIOMES.length];
      currentBiome = biome; applyTheme(biome);
      hole = genHole();
      buildScenery();
      backdrop.seed = (Math.random()*1e9)|0; buildBackdrop();
      roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par;
      elHole.textContent = (holeIndex+1); elPar.textContent = hole.par;
      windLift = windOn ? (Math.random()*2 - 1) : 0; updateWindUI();
      disc.x = hole.tee.x; disc.y = hole.tee.y - disc.r - 1; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; disc.orient=0; disc.spin=0; disc.bank=0; strokes=0; elStrokes.textContent=strokes;
      centerCameraOnDisc();
    }
    function endHole(){
      roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes; holeIndex++;
      if(holeIndex>=HOLES_PER_ROUND){
        sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar; const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
        holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
        screenSummary.style.display='grid';
      } else { nextHole(); }
    }

    // ===== UI
    function buildDiscs(){
      clubSeg.innerHTML='';
      DISCS.forEach((d,idx)=>{
        const b=document.createElement('button'); b.className='btn'; b.textContent=d.name; b.dataset.disc=idx;
        b.setAttribute('aria-pressed', idx===1? 'true':'false');
        b.addEventListener('click',()=>selectDisc(idx));
        clubSeg.appendChild(b);
      });
      selectDisc(1);
    }
    let currentDisc = DISCS[1];
    function selectDisc(i){ currentDisc = DISCS[i]; [...clubSeg.querySelectorAll('button')].forEach((b,idx)=> b.setAttribute('aria-pressed', idx===i? 'true':'false')); }
    spinSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; releaseMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });
    handSeg.addEventListener('click', (e)=>{ const btn = e.target.closest('button'); if(!btn) return; hand = btn.dataset.hand; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });

    function updateWindUI(){
      const mag = Math.abs(windOn ? windLift : 0);
      document.getElementById('windVal').textContent = mag.toFixed(1)+'x';
      document.getElementById('windArrow').style.transform = `rotate(${windLift >= 0 ? 180 : 0}deg)`;
    }

    // Input
    function worldToScreen(x,y){ return { x: (x - view.x)*DPR, y: (y - view.y)*DPR }; }
    function screenToWorld(x,y){ return { x: x/DPR + view.x, y: y/DPR + view.y }; }
    function onPointerDown(e){ if(!hole || !disc.atRest) return; const p = getPoint(e); const w=screenToWorld(p.x,p.y); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x)); aiming = true; meterOn = true; meter = 0; meterDir=1; elPowermeter.dataset.on='1'; e.preventDefault(); }
    function onPointerMove(e){ if(!aiming) return; const p = getPoint(e); const w=screenToWorld(p.x,p.y); aimAngle = Math.atan2((w.y - disc.y), (w.x - disc.x)); }
    function onPointerUp(e){ if(!aiming) return; aiming=false; meterOn=false; elPowermeter.dataset.on='0'; throwDisc(); }
    function getPoint(e){ if(e.changedTouches){ const t=e.changedTouches[0]; return { x:t.clientX*DPR, y:t.clientY*DPR }; } return { x:e.clientX*DPR, y:e.clientY*DPR }; }
    canvas.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive:false}); window.addEventListener('touchmove', onPointerMove, {passive:false}); window.addEventListener('touchend', onPointerUp);

    // Throw
    function throwDisc(){
      if(!hole || !disc.atRest) return;
      const d = currentDisc;
      const surface = surfaceAt(disc.x); let powerMul = 1.0; if(SURF[surface] && SURF[surface].powerMul) powerMul = SURF[surface].powerMul;
      const base = 1650;
      const power = (0.25 + 0.75*meter) * d.speed * powerMul;
      const speed = base * power;
      const dir = aimAngle;

      disc.vx = Math.cos(dir) * speed;
      disc.vy = Math.sin(dir) * speed;

      disc.orient = dir + (-6 * Math.PI/180);
      disc.spin0  = 14 + 20*power;
      disc.spin   = disc.spin0;
      disc.bank   = (releaseMode * 16) * Math.PI/180;

      disc.atRest=false; disc.onGround=false; strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes; if(navigator.vibrate) navigator.vibrate(16); AudioMini.thwack();
    }

    // Physics
    const VREF = 1600;
    function normalizeAngle(a){ while(a > Math.PI) a -= TAU; while(a < -Math.PI) a += TAU; return a; }

    function update(dt){
      if(meterOn){ meter += meterDir * 1.6 * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width = (meter*100).toFixed(1)+'%'; }

      if(!hole) return;

      // particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.vy += 1200*dt; p.vx*= (1-0.4*dt); p.vy*=(1-0.06*dt); p.x += p.vx*dt; p.y += p.vy*dt; }

      if(!disc.atRest){
        if(!disc.onGround){
          const v = Math.hypot(disc.vx, disc.vy) || 0.0001;
          const vx = disc.vx, vy = disc.vy;
          const vAngle = Math.atan2(vy, vx);
          const tPow = clamp(v / VREF, 0, 1);
          const spinNorm = clamp(disc.spin / (disc.spin0 || 1), 0, 1);

          const aoaRaw = normalizeAngle(disc.orient - vAngle);
          const aoa = clamp(aoaRaw + 0.06, -0.6, 0.6);
          const dragMag = 0.00050 * v * (1 + 0.7*Math.abs(aoa));
          const dragX = -dragMag * vx, dragY = -dragMag * vy;
          const windMul = (windOn ? (1 + clamp(windLift, -1, 1) * 0.50) : 1);
          const lift = 0.00450 * currentDisc.glide * v*v * aoa * windMul;

          const turnAmt = currentDisc.turn * (tPow*tPow) * (0.7 + 0.6*spinNorm) * (1 + 0.35*releaseMode);
          const fadeAmt = currentDisc.fade * (1 - tPow) * (0.9 + 0.5*(1 - spinNorm)) * (1 - 0.25*releaseMode);
          const curveAx = 54 * (turnAmt - fadeAmt + 0.12*Math.sin(disc.bank)) * (hand==='RHBH'?1:-1);

          const ax = dragX + curveAx;
          const ay = 1500 + dragY - lift;

          disc.vx += ax*dt; disc.vy += ay*dt;
          disc.x  += disc.vx*dt; disc.y  += disc.vy*dt;

          disc.spin *= Math.exp(-0.35*dt);
          disc.bank += (-disc.bank) * (1 - Math.exp(-dt*(0.2 + 0.9*(1 - spinNorm))));

          const noseBias = (lerp(-6, 7, 1 - tPow)) * Math.PI/180;
          const targetOrient = vAngle + noseBias;
          disc.orient += (targetOrient - disc.orient) * (1 - Math.exp(-dt*3.4));

          // Ground collision
          const gy = groundYAt(disc.x);
          if(disc.y + disc.r >= gy){
            const surface = surfaceAt(disc.x);
            disc.y = gy - disc.r - 0.01;

            if(Math.abs(disc.vy) > 120){
              if(surface==='sand') spawnParticles('sand',  disc.x, disc.y+disc.r, 12);
              else                 spawnParticles('dust',  disc.x, disc.y+disc.r,  8);
            }

            const speed = Math.hypot(disc.vx, disc.vy);
            const entryAngle = Math.atan2(Math.abs(disc.vy), Math.abs(disc.vx));
            const shallow = entryAngle < (12 * Math.PI/180);
            const fast    = speed > 900;

            if(surface!=='sand' && surface!=='green' && shallow && fast){
              disc.vy = -Math.max(180, Math.abs(disc.vy)*0.55);
              disc.vx *= 0.88;
              disc.onGround = false;
            } else {
              const rest = SURF[surface]?.rest ?? 0.14;
              disc.vy = -disc.vy * rest;
              disc.vx *= 0.84;
              if(Math.abs(disc.vy) < 120) disc.vy = 0;
              disc.onGround = true;
            }
          }

          if(checkBasketCatch()){
            AudioMini.chains();
            if(navigator.vibrate) navigator.vibrate([30,40,30]);
            disc.atRest=true; disc.vx=disc.vy=0;
            setTimeout(()=>{ endHole(); }, 520);
          }
        } else {
          const gy = groundYAt(disc.x); 
          if(disc.y + disc.r < gy-0.5){ 
            disc.onGround=false; 
          } else {
            disc.y = gy - disc.r; 
            const surface = surfaceAt(disc.x); 
            const fric = SURF[surface]?.fric ?? 740; 
            const speed = Math.abs(disc.vx); 
            let dec = fric * 2.1;
            if(surface === 'sand')  dec = fric * 2.6;
            if(surface === 'green') dec = fric * 2.3;

            const s = Math.sign(disc.vx) || 0; 
            let newSpeed = speed - dec*dt; 
            if(newSpeed<0) newSpeed=0; 
            disc.vx = s * newSpeed; 
            disc.x += disc.vx*dt; 
            if(Math.abs(disc.vx) < 8){ disc.vx=0; disc.atRest=true; disc.onGround=true; disc.lastSafe={x:disc.x,y:disc.y}; }
          }
        }
        if(inWater(disc.x, disc.y+disc.r*0.6)){
          spawnParticles('splash', disc.x, disc.y, 16);
          if(navigator.vibrate) navigator.vibrate([40,40,30]);
          strokes++; elStrokes.textContent=strokes; roundData.holes[holeIndex].strokes = strokes;
          disc.x = disc.lastSafe.x - 24; disc.y = groundYAt(disc.x)-disc.r; disc.vx=0; disc.vy=0; disc.atRest=true; disc.onGround=true;
        }
        if(disc.x<0){ disc.x=0; disc.vx=0; } if(disc.x>hole.w){ disc.x=hole.w; disc.vx=0; }
      }
      centerCameraOnDisc();
    }

    // Camera follow
    function centerCameraOnDisc(){
      if(!hole) return;
      view.x = clamp(disc.x - view.w*0.45, 0, WORLD.w - view.w);
      view.y = clamp(groundYAt(disc.x) - view.h*0.65, 0, WORLD.h - view.h);
    }

    // ===== Scenery (bigger trees, small rock clusters)
    function buildScenery(){
      scenery.trees = [];
      scenery.rocks = [];
      const rng = (i)=>rand01(backdrop.seed, 2000+i);
      const countTrees = 24 + Math.floor(rng(1)*18);
      const avoid = [[hole.green.x0-80, hole.green.x1+80]];
      for(const w of hole.waters){ avoid.push([w.x-60, w.x+w.w+60]); }
      function allowedX(x){ for(const r of avoid){ if(x>=r[0] && x<=r[1]) return false; } return x>40 && x < hole.w-40; }
      for(let i=0;i<countTrees;i++){
        let x = 80 + rng(10+i)*(WORLD.w-160);
        let tries=0; while(!allowedX(x) && tries++<10){ x = 80 + rng(100+i*7)*(WORLD.w-160); }
        const y = groundYAt(x);
        const h = 56 + rng(200+i)*96;
        const baseW = 14 + rng(300+i)*18;
        const levels = 4 + Math.floor(rng(500+i)*2);
        scenery.trees.push({ x, y, h, w: baseW, levels, sway:rng(400+i)*TAU });
      }
      const rockN = 6 + Math.floor(Math.random()*6);
      for(let i=0;i<rockN;i++){
        const x = 80 + Math.random()*(WORLD.w-160);
        const y = groundYAt(x);
        const r = 3 + Math.random()*5;
        const seed = (Math.random()*1e9)|0;
        scenery.rocks.push({ x, y, r, seed, skew: (Math.random()*0.6-0.3) });
      }
    }

    function drawScenery(){
      // Rocks ‚Äî tiny irregular clusters
      ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.92)';
      for(const r of scenery.rocks){
        const x = r.x - view.x, y = r.y - view.y; if(x<-40 || x>canvas.width/DPR+40) continue;
        ctx.save(); ctx.translate(x,y); ctx.rotate(r.skew);
        function rr(seed,i){ return (hash32(seed ^ (i*2654435761))>>>0)/4294967295; }
        const lumps = 2 + Math.floor(rr(r.seed,1)*3);
        for(let i=0;i<lumps;i++){
          const ang = rr(r.seed,10+i)*TAU;
          const dist = r.r * (0.2 + rr(r.seed,20+i)*0.9);
          const rad  = r.r * (0.7 + rr(r.seed,30+i)*0.7);
          const ox = Math.cos(ang)*dist;
          const oy = Math.sin(ang)*dist*0.5 - r.r*0.3;
          const rot = (rr(r.seed,40+i)-0.5)*0.8;
          ctx.save(); ctx.translate(ox, oy); ctx.rotate(rot);
          ctx.beginPath(); ctx.ellipse(0, 0, rad, rad*0.65, 0, 0, TAU); ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }
      ctx.restore();

      // Trees ‚Äî thicker, multi-tiered
      ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.94)';
      for(const t of scenery.trees){
        const x = t.x - view.x, y = t.y - view.y; if(x<-60 || x>canvas.width/DPR+60) continue;
        const sway = Math.sin(clock*0.3 + t.sway) * 2;
        const trunkW = clamp(t.h*0.045, 3, 7);
        ctx.fillRect(x - trunkW/2, y - t.h, trunkW, t.h);
        ctx.beginPath(); ctx.moveTo(x - trunkW*0.8, y); ctx.lineTo(x + trunkW*0.8, y); ctx.lineTo(x, y - trunkW*0.4); ctx.closePath(); ctx.fill();
        const tierGap = 10;
        for(let k=0;k<t.levels;k++){
          const level = t.h*(0.16 + k*0.18);
          const width = (t.w + k*(t.w*0.28));
          ctx.beginPath();
          ctx.moveTo(x + sway*0.45, y - level - (k*tierGap));
          ctx.lineTo(x - width/2 + sway, y - level + tierGap);
          ctx.lineTo(x + width/2 + sway, y - level + tierGap);
          ctx.closePath(); ctx.fill();
        }
      }
      ctx.restore();
    }

    // ===== Sand bunkers as recessed holes with grain =====
    function drawBunkerHole(s){
      const cx = s.x - view.x, cy = s.y - view.y, r = s.r;
      // align to slope
      const yL = groundYAt(s.x - 6), yR = groundYAt(s.x + 6);
      const ang = Math.atan2(yR - yL, 12);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.scale(1.10, 0.68); // ellipse flatten

      // rim highlight (reads as shallow depression)
      const ring = ctx.createRadialGradient(0, 0, r*0.72, 0, 0, r);
      ring.addColorStop(0, 'rgba(255,255,255,0.00)');
      ring.addColorStop(1, 'rgba(255,255,255,0.08)');
      ctx.fillStyle = ring;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      // inner shade toward downslope
      const shade = ctx.createRadialGradient(0, r*0.22, r*0.18, 0, 0, r);
      shade.addColorStop(0, 'rgba(0,0,0,0.30)');
      shade.addColorStop(1, 'rgba(0,0,0,0.00)');
      ctx.fillStyle = shade;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.fill();

      // grain clipped inside
      ctx.save();
      ctx.beginPath(); ctx.arc(0, 0, r, 0, TAU); ctx.clip();
      drawSandGrain(s.seed, r);
      ctx.restore();

      ctx.restore();
    }
    function drawSandGrain(seed, r){
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const N = 140;
      for(let i=0;i<N;i++){
        const u = rand01(seed, i*7+1);
        const v = rand01(seed, i*7+2);
        const theta = v * TAU;
        const rad = Math.sqrt(u) * r * 0.85;
        const x = Math.cos(theta) * rad;
        const y = Math.sin(theta) * rad * 0.82;
        const dir = (rand01(seed, i*7+3)-0.5) * TAU;
        const len = 2 + rand01(seed, i*7+4)*4;
        ctx.beginPath();
        ctx.moveTo(x - Math.cos(dir)*len*0.5, y - Math.sin(dir)*len*0.5);
        ctx.lineTo(x + Math.cos(dir)*len*0.5, y + Math.sin(dir)*len*0.5);
        ctx.stroke();
      }
    }

    // ===== Rendering =====
    function draw(){
      ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
      drawSkyGradient(); drawSun(); drawClouds(); drawMountains();

      if(!hole){ drawVignette(); return; }

      // water
      const cs = getComputedStyle(document.documentElement);
      ctx.fillStyle = cs.getPropertyValue('--water').trim() || '#30160f';
      for(const w of hole.waters){ ctx.fillRect((w.x - view.x), (w.y - view.y), w.w, hole.h - w.y + 80); }

      // ground silhouette
      ctx.fillStyle = cs.getPropertyValue('--fg');
      ctx.beginPath(); ctx.moveTo(hole.points[0].x - view.x, hole.h - view.y + 100);
      for(const p of hole.points){ ctx.lineTo(p.x - view.x, p.y - view.y); }
      ctx.lineTo(hole.points[hole.points.length-1].x - view.x, hole.h - view.y + 100); ctx.closePath(); ctx.fill();

      drawGrass();

      // recessed grainy bunkers (no solid fill)
      for(const s of hole.sands){ drawBunkerHole(s); }

      // (removed the old landing-zone highlight)

      drawScenery();
      drawBasket();

      // particles
      for(const p of particles){
        let c = '#ffffff';
        if(p.type==='spark') c = getComputedStyle(document.documentElement).getPropertyValue('--accent');
        else if(p.type==='sand') c = '#b48a5a';
        else if(p.type==='dust') c = '#9aa2aa';
        else if(p.type==='splash') c = '#49d0ff';
        ctx.globalAlpha = Math.max(0, p.life/0.6);
        ctx.fillStyle=c; ctx.beginPath(); ctx.arc(p.x - view.x, p.y - view.y, 2.2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
      }

      drawDisc(); if(aiming){ drawAimArrow(); } drawVignette();
    }

    // Sky / Sun / Clouds / Mountains (same as before)
    function drawSkyGradient(){ const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height/DPR); const cs = getComputedStyle(document.documentElement); skyGrad.addColorStop(0, cs.getPropertyValue('--bg3').trim()); skyGrad.addColorStop(0.55, cs.getPropertyValue('--bg2').trim()); skyGrad.addColorStop(1, cs.getPropertyValue('--bg1').trim()); ctx.fillStyle = skyGrad; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); }
    function drawSun(){ /* kept same as earlier build */ }
    function drawClouds(){ /* kept same as earlier build */ }
    function drawMountains(){ /* kept same as earlier build */ }

    // Grass
    const GRASS_STEP = 26, GRASS_DENSITY = 3;
    function drawGrass(){
      if(!hole) return;
      ctx.save(); ctx.strokeStyle='rgba(0,0,0,.9)'; ctx.lineWidth=1;
      const start = Math.floor((view.x-40)/GRASS_STEP)*GRASS_STEP; const end = view.x + view.w + 40;
      for(let wx=start; wx<end; wx+=GRASS_STEP){
        const gx = clamp(wx,0,hole.w); const gy = groundYAt(gx) - view.y; if(gy< -20 || gy > canvas.height/DPR+20) continue;
        for(let k=0;k<GRASS_DENSITY;k++){
          const idx = ((gx|0)*7 + k)|0; const hh = 7 + rand01(backdrop.seed ^ 0xabc123, idx)*10; const lean = (rand01(backdrop.seed ^ 0x55aa55, idx+13)-0.5)*8;
          const baseX = gx - view.x + (k-1)*(2 + rand01(backdrop.seed ^ 0x999,idx+21)*2);
          ctx.beginPath(); ctx.moveTo(baseX, gy);
          const ctrlX = baseX + lean*0.45; const ctrlY = gy - hh*0.55; const tipX = baseX + lean; const tipY = gy - hh;
          ctx.quadraticCurveTo(ctrlX, ctrlY, tipX, tipY); ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawDisc(){ 
      const cs = getComputedStyle(document.documentElement); 
      const trailColor = cs.getPropertyValue('--accent'); 
      if(!disc.atRest && Math.hypot(disc.vx,disc.vy)>320){ 
        ctx.strokeStyle = trailColor; ctx.globalAlpha=0.24; ctx.lineWidth=3; 
        ctx.beginPath(); ctx.moveTo(disc.x - view.x, disc.y - view.y); 
        ctx.lineTo(disc.x - disc.vx*0.05 - view.x, disc.y - disc.vy*0.05 - view.y); 
        ctx.stroke(); ctx.globalAlpha=1; 
      } 
      let fillCol = '#f8fafc'; if(currentDisc.id==='DRV') fillCol = '#49d0ff'; else if(currentDisc.id==='PUT') fillCol = '#ff8a3d';
      ctx.save(); ctx.translate(disc.x - view.x, disc.y - view.y); ctx.rotate(disc.orient); ctx.fillStyle = fillCol; ctx.strokeStyle = 'rgba(0,0,0,.45)';
      const R = disc.r; ctx.beginPath(); ctx.ellipse(0,0, R, R*0.45, 0, 0, TAU); ctx.fill(); ctx.stroke(); ctx.globalAlpha=0.45; ctx.beginPath(); ctx.ellipse(0,0, R*0.85, R*0.35, 0, 0, TAU); ctx.stroke(); ctx.globalAlpha=1; ctx.restore();
    }
    function drawAimArrow(){ const b = worldToScreen(disc.x, disc.y); const len = 80 + meter*160; const x2 = b.x + Math.cos(aimAngle)*len; const y2 = b.y + Math.sin(aimAngle)*len; ctx.save(); ctx.scale(DPR,DPR); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent3'); ctx.lineWidth=3; ctx.globalAlpha=0.9; ctx.beginPath(); ctx.moveTo(b.x/DPR, b.y/DPR); ctx.lineTo(x2/DPR, y2/DPR); ctx.stroke(); const a=aimAngle; const ah = 10; const aw = 7; ctx.beginPath(); ctx.moveTo(x2/DPR, y2/DPR); ctx.lineTo((x2 - Math.cos(a)*ah + Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah - Math.cos(a)*aw)/DPR); ctx.lineTo((x2 - Math.cos(a)*ah - Math.sin(a)*aw)/DPR, (y2 - Math.sin(a)*ah + Math.cos(a)*aw)/DPR); ctx.closePath(); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.fill(); ctx.restore(); }
    function drawBasket(){ const x = hole.cupX - view.x; const groundY = groundYAt(hole.cupX) - view.y; const poleH = 74, cageTop = groundY - 24, rimY = groundY - 46; const rimW = 28, cageW = 24; ctx.strokeStyle='rgba(255,255,255,0.75)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x, groundY - poleH); ctx.stroke(); ctx.fillStyle='rgba(0,0,0,0.80)'; ctx.fillRect(x - cageW/2, cageTop, cageW, 8); ctx.fillRect(x - 2, cageTop - 10, 4, 10); ctx.beginPath(); ctx.ellipse(x, rimY, rimW/2, 4, 0, 0, TAU); ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.75)'; ctx.lineWidth=1; for(let i=0;i<6;i++){ const t = i/6 * TAU; const cx2 = x + Math.cos(t) * (rimW/2 - 2); ctx.beginPath(); ctx.moveTo(cx2, rimY); ctx.lineTo(cx2, cageTop); ctx.stroke(); } }
    function checkBasketCatch(){ const x = disc.x, y = disc.y, vy = disc.vy; const rimY = groundYAt(hole.cupX) - 46; const cageTop = groundYAt(hole.cupX) - 24; const rimHalf = 14; if(vy > 30 && y > rimY-6 && y < cageTop+6 && Math.abs(x - hole.cupX) < rimHalf) return true; return false; }
    function drawVignette(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.2,w*0.5,h*0.55,Math.max(w,h)*0.7); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h); }

    // Resize
    function resize(){ DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); view.w = canvas.width/DPR; view.h = canvas.height/DPR; buildBackdrop(); }
    window.addEventListener('resize', resize); resize();

    // Main loop
    let last=0; let clock=0;
    function loop(t){ const now=t/1000; const dt = Math.min(0.033, last? now-last: 0.016); last=now; clock += dt; update(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // Settings & controls
    btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; newRound(); });
    btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; newRound(); });
    btnNewRound.addEventListener('click', ()=>{ newRound(); });
    btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
    btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });
    chkReduced.addEventListener('change', ()=>{ reducedMotion = chkReduced.checked; });
    chkAudio.addEventListener('change', ()=>{ AudioMini.setEnabled(chkAudio.checked); });
    chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; updateWindUI(); });

    // Build initial UI
    buildDiscs(); updateWindUI();
  }
})();
</script>
</body>
</html>
